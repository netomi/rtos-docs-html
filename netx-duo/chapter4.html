<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="description" content="This chapter contains a description of all NetX Duo services in alphabetic order.">
<title>Chapter 4 - Description of NetX Duo Services</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Chapter 4 - Description of NetX Duo Services</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This chapter contains a description of all NetX Duo services in alphabetic order. Service names are designed so all similar services are grouped together. For example, all ARP services are found at the beginning of this chapter.</p>
</div>
<div class="paragraph">
<p>There are numerous new services in NetX Duo introduced to support IPv6-based protocols and operations. IPv6-enabled services in Net Duo have the prefix <em>*nxd*,</em> indicating that they are designed for IPv4 and IPv6 dual stack operation.</p>
</div>
<div class="paragraph">
<p>Existing services in NetX are fully supported in NetX Duo. NetX applications can be migrated to NetX Duo with minimal porting effort.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>Note that a BSD-Compatible Socket API is available for legacy application code that cannot take full advantage of the high-performance NetX Duo API. Refer to Appendix D for more information on the BSD-Compatible Socket API</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the <strong>Return Values</strong> section of each description, values in <strong>BOLD</strong> are not affected by the <strong>NX_DISABLE_ERROR_CHECKING</strong> option used to disable the API error checking, while values in non-bold are completely disabled. The "Allowed From" sections indicate from which each NetX Duo service can be called.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_arp_dynamic_entries_invalidate">nx_arp_dynamic_entries_invalidate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Invalidate all dynamic entries in the ARP cache</p>
</div>
<div class="sect2">
<h3 id="_prototype">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_arp_dynamic_entries_invalidate(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description">Description</h3>
<div class="paragraph">
<p>This service invalidates all dynamic ARP entries currently in the ARP cache.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful ARP cache invalidate.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) ARP is not enabled.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP address.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Invalidate all dynamic entries in the ARP cache. */
status = nx_arp_dynamic_entries_invalidate(&amp;ip_0);

/* If status is NX_SUCCESS the dynamic ARP entries were
   successfully invalidated. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_arp_dynamic_entry_set">nx_arp_dynamic_entry_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set dynamic ARP entry</p>
</div>
<div class="sect2">
<h3 id="_prototype_2">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_arp_dynamic_entry_set(
    NX_IP *ip_ptr,
    ULONG ip_address,
    ULONG physical_msw,
    ULONG physical_lsw);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_2">Description</h3>
<div class="paragraph">
<p>This service allocates a dynamic entry from the ARP cache and sets up the specified IP to physical address mapping. If a zero physical address is specified, an actual ARP request is sent to the network in order to have the physical address resolved. Also note that this entry will be removed if ARP aging is active or if the ARP cache is exhausted and this is the least recently used ARP entry.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_2">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>ip_address</em>: IP address to map.</p>
</li>
<li>
<p><em>physical_msw</em>: Top 16 bits (47-32) of the physical address.</p>
</li>
<li>
<p><em>physical_lsw</em>: Lower 32 bits (31-0) of the physical address.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_2">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful ARP dynamic entry set.</p>
</li>
<li>
<p><strong>NX_NO_MORE_ENTRIES</strong> (0x17) No more ARP entries are available in the ARP cache.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP address.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance pointer.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_2">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_2">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_2">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Setup a dynamic ARP entry on the previously created IP
   Instance 0. */
status = nx_arp_dynamic_entry_set(&amp;ip_0, IP_ADDRESS(1,2,3,4),
                                  0x1022, 0x1234);

/* If status is NX_SUCCESS, there is now a dynamic mapping between
   the IP address of 1.2.3.4 and the physical hardware address of
   10:22:00:00:12:34. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_2">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_arp_enable">nx_arp_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable Address Resolution Protocol (ARP)</p>
</div>
<div class="sect2">
<h3 id="_prototype_3">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_arp_enable(
    NX_IP *ip_ptr,
    VOID *arp_cache_memory,
    ULONG arp_cache_size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_3">Description</h3>
<div class="paragraph">
<p>This service initializes the ARP component of NetX Duo for the specific IP instance. ARP initialization includes setting up the ARP cache and various ARP processing routines necessary for sending and receiving ARP messages.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_3">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>arp_cache_memory</em>: Pointer to memory area to place ARP cache.</p>
</li>
<li>
<p><em>arp_cache_size</em>: Each ARP entry is 52 bytes, the total number of ARP entries is, therefore, the size divided by 52.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_3">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful ARP enable.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or cache memory pointer.</p>
</li>
<li>
<p><strong>NX_SIZE_ERROR</strong> (0x09) User supplied ARP cache memory is too small.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_ALREADY_ENABLED</strong> (0x15) This component has already been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_3">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_3">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_3">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Enable ARP and supply 1024 bytes of ARP cache memory for
   previously created IP Instance ip_0. */
status = nx_arp_enable(&amp;ip_0, (void *) pointer, 1024);

/* If status is NX_SUCCESS, ARP was successfully enabled for this IP
instance.*/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_3">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_arp_entry_delete">nx_arp_entry_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Delete an ARP entry</p>
</div>
<div class="sect2">
<h3 id="_prototype_4">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_arp_entry_delete(
    NX_IP *ip_ptr,
    ULONG ip_address);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_4">Description</h3>
<div class="paragraph">
<p>This service removes an ARP entry for the given IP address from its IP internal ARP table.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_4">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>ip_address</em>: ARP entry with the specified IP address should be deleted.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_4">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful ARP enable.</p>
</li>
<li>
<p><strong>NX_ENTRY_NOT_FOUND</strong> (0x16) No entry with the specified IP address can be found.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or cache memory pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Specified IP address is invalid.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_4">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_4">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_4">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Delete the ARP entry with the IP address 1.2.3.4. */
status = nx_arp_entry_delete(&amp;ip_0, IP_ADDRESS(1, 2, 3, 4));

/* If status is NX_SUCCESS, ARP entry with the specified IP address
   is deleted.*/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_4">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_arp_gratuitous_send">nx_arp_gratuitous_send</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send gratuitous ARP request</p>
</div>
<div class="sect2">
<h3 id="_prototype_5">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_arp_gratuitous_send(
    NX_IP *ip_ptr,
    VOID (*response_handler)(NX_IP *ip_ptr, NX_PACKET *packet_ptr));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_5">Description</h3>
<div class="paragraph">
<p>This service goes through all the physical interfaces to transmit gratuitous ARP requests as long as the interface IP address is valid. If an ARP response is subsequently received, the supplied response
handler is called to process the response to the gratuitous ARP.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_5">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>response_handler</em>: Pointer to response handling function. If NX_NULL is supplied, responses are ignored.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_5">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful gratuitous ARP send.</p>
</li>
<li>
<p><strong>NX_NO_PACKET</strong> (0x01) No packet available.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) ARP is not enabled.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Current IP address is invalid.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_5">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_5">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_5">Example</h3>
<div class="listingblock">
<div class="content">
<pre>/* Send gratuitous ARP without any response handler. */
status = nx_arp_gratuitous_send(&amp;ip_0, NX_NULL);

/* If status is NX_SUCCESS the gratuitous ARP was successfully
   sent. */</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_5">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_arp_hardware_address_find">nx_arp_hardware_address_find</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Locate physical hardware address given an IP address</p>
</div>
<div class="sect2">
<h3 id="_prototype_6">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_arp_hardware_address_find(
    NX_IP *ip_ptr,
    ULONG ip_address,
    ULONG *physical_msw,
    ULONG *physical_lsw);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_6">Description</h3>
<div class="paragraph">
<p>This service attempts to find a physical hardware address in the ARP cache that is associated with the supplied IP address.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_6">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>ip_address</em>: IP address to search for.</p>
</li>
<li>
<p><em>physical_msw</em>: Pointer to the variable for returning the top 16 bits (47-32) of the physical address.</p>
</li>
<li>
<p><em>physical_lsw</em>: Pointer to the variable for returning the lower 32 bits (31-0) of the physical address.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_6">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful ARP hardware address find.</p>
</li>
<li>
<p><strong>NX_ENTRY_NOT_FOUND</strong> (0x16) Mapping was not found in the ARP cache.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP address.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or memory pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_6">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_6">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_6">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Search for the hardware address associated with the IP address of
   1.2.3.4 in the ARP cache of the previously created IP
   Instance 0. */
status = nx_arp_hardware_address_find(&amp;ip_0, IP_ADDRESS(1,2,3,4),
                                      &amp;physical_msw,
                                      &amp;physical_lsw);

/* If status is NX_SUCCESS, the variables physical_msw and
   physical_lsw contain the hardware address.*/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_6">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_arp_info_get">nx_arp_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve information about ARP activities</p>
</div>
<div class="sect2">
<h3 id="_prototype_7">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_arp_info_get(
    NX_IP *ip_ptr,
    ULONG *arp_requests_sent,
    ULONG *arp_requests_received,
    ULONG *arp_responses_sent,
    ULONG *arp_responses_received,
    ULONG *arp_dynamic_entries,
    ULONG *arp_static_entries,
    ULONG *arp_aged_entries,
    ULONG *arp_invalid_messages);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_7">Description</h3>
<div class="paragraph">
<p>This service retrieves information about ARP activities for the associated IP instance.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>If a destination pointer is NX_NULL, that particular information is not returned to the caller</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_7">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>arp_requests_sent</em>: Pointer to destination for the total ARP requests sent from this IP instance.</p>
</li>
<li>
<p><em>arp_requests_received</em>: Pointer to destination for the total ARP requests received from the network.</p>
</li>
<li>
<p><em>arp_responses_sent</em>: Pointer to destination for the total ARP responses sent from this IP instance.</p>
</li>
<li>
<p><em>arp_responses_received</em>: Pointer to the destination for the total ARP responses received from the network.</p>
</li>
<li>
<p><em>arp_dynamic_entries</em>: Pointer to the destination for the current number of dynamic ARP entries.</p>
</li>
<li>
<p><em>arp_static_entries</em>: Pointer to the destination for the current number of static ARP entries.</p>
</li>
<li>
<p><em>arp_aged_entries</em>: Pointer to the destination of the total number of ARP entries that have aged and became invalid.</p>
</li>
<li>
<p><em>arp_invalid_messages</em>: Pointer to the destination of the total invalid ARP messages received.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_7">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful ARP information retrieval.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_7">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_7">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_7">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Pickup ARP information for ip_0. */
status = nx_arp_info_get(&amp;ip_0, &amp;arp_requests_sent,
                         &amp;arp_requests_received,
                         &amp;arp_responses_sent,
                         &amp;arp_responses_received,
                         &amp;arp_dynamic_entries,
                         &amp;arp_static_entries,
                         &amp;arp_aged_entries,
                         &amp;arp_invalid_messages);

/* If status is NX_SUCCESS, the ARP information has been stored in
   the supplied variables. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_7">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_arp_ip_address_find">nx_arp_ip_address_find</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Locate IP address given a physical address</p>
</div>
<div class="sect2">
<h3 id="_prototype_8">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_arp_ip_address_find(
    NX_IP *ip_ptr,
    ULONG *ip_address,
    ULONG physical_msw,
    ULONG physical_lsw);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_8">Description</h3>
<div class="paragraph">
<p>This service attempts to find an IP address in the ARP cache that is associated with the supplied physical address.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_8">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to return IP address, if one is found that has been mapped.</p>
</li>
<li>
<p><em>physical_msw</em>: Top 16 bits (47-32) of the physical address to search for.</p>
</li>
<li>
<p><em>physical_lsw</em>: Lower 32 bits (31-0) of the physical address to search for.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_8">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful ARP IP address find</p>
</li>
<li>
<p><strong>NX_ENTRY_NOT_FOUND</strong> (0x16) Mapping was not found in the ARP cache.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or memory pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) Physical_msw and physical_lsw are both 0.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_8">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_8">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_8">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Search for the IP address associated with the hardware address of
   0x0:0x01234 in the ARP cache of the previously created IP
   Instance ip_0. */
status = nx_arp_ip_address_find(&amp;ip_0, &amp;ip_address, 0x0, 0x1234);

/* If status is NX_SUCCESS, the variables ip_address contains the
   associated IP address. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_8">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_arp_static_entries_delete">nx_arp_static_entries_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Delete all static ARP entries</p>
</div>
<div class="sect2">
<h3 id="_prototype_9">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_arp_static_entries_delete(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_9">Description</h3>
<div class="paragraph">
<p>This service deletes all static entries in the ARP cache.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_9">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_9">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Static entries are deleted.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid ip_ptr pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_9">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_9">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_9">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Delete all the static ARP entries for IP Instance 0, assuming
   "ip_0" is the NX_IP structure for IP Instance 0. */
status = nx_arp_static_entries_delete(&amp;ip_0);

/* If status is NX_SUCCESS all static ARP entries in the ARP cache
   have been deleted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_9">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_arp_static_entry_create">nx_arp_static_entry_create</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create static IP to hardware mapping in ARP cache</p>
</div>
<div class="sect2">
<h3 id="_prototype_10">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_arp_static_entry_create(
    NX_IP *ip_ptr,
    ULONG ip_address,
    ULONG physical_msw,
    ULONG physical_lsw);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_10">Description</h3>
<div class="paragraph">
<p>This service creates a static IP-to-physical address mapping in the ARP cache for the specified IP instance. Static ARP entries are not subject to ARP periodic updates.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_10">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>ip_address</em>: IP address to map.</p>
</li>
<li>
<p><em>physical_msw</em>: Top 16 bits (47-32) of the physical address to map.</p>
</li>
<li>
<p><em>physical_lsw</em>: Lower 32 bits (31-0) of the physical address to map.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_10">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful ARP static entry create.</p>
</li>
<li>
<p><strong>NX_NO_MORE_ENTRIES</strong> (0x17) No more ARP entries are available in the ARP cache.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP address.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) Physical_msw and physical_lsw are both 0.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_10">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_10">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_10">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Create a static ARP entry on the previously created IP
   Instance 0. */
status = nx_arp_static_entry_create(&amp;ip_0, IP_ADDRESS(1,2,3,4),
                                    0x0, 0x1234);

/* If status is NX_SUCCESS, there is now a static mapping between
   the IP address of 1.2.3.4 and the physical hardware address of
   0x00:0x1234. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_10">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_arp_static_entry_delete">nx_arp_static_entry_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Delete static IP to hardware mapping in ARP cache</p>
</div>
<div class="sect2">
<h3 id="_prototype_11">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_arp_static_entry_delete(
    NX_IP *ip_ptr,
    ULONG ip_address,
    ULONG physical_msw,
    ULONG physical_lsw);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_11">Description</h3>
<div class="paragraph">
<p>This service finds and deletes a previously created static IP-to-physical address mapping in the ARP cache for the specified IP instance.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_11">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>ip_address</em>: IP address that was mapped statically.</p>
</li>
<li>
<p><em>physical_msw</em>: Top 16 bits (47 - **32) of the physical address that was mapped statically.</p>
</li>
<li>
<p><em>physical_lsw</em>: Lower 32 bits (31 - **0) of the physical address that was mapped statically.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_11">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful ARP static entry delete.</p>
</li>
<li>
<p><strong>NX_ENTRY_NOT_FOUND</strong> (0x16) Static ARP entry was not found in the ARP cache.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP address.</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) Physical_msw and physical_lsw are both 0.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_11">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_11">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_11">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Delete a static ARP entry on the previously created IP
   instance ip_0. */
status = nx_arp_static_entry_delete(&amp;ip_0, IP_ADDRESS(1,2,3,4),
                                    0x0, 0x1234);

/* If status is NX_SUCCESS, the previously created static ARP entry
   was successfully deleted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_11">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_icmp_enable">nx_icmp_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable Internet Control Message Protocol (ICMP)</p>
</div>
<div class="sect2">
<h3 id="_prototype_12">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_icmp_enable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_12">Description</h3>
<div class="paragraph">
<p>This service enables the ICMP component for the specified IP instance. The ICMP component is responsible for handling Internet error messages and ping requests and replies.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This service only enables ICMP for IPv4 service. To enable both ICMPv4 and ICMPv6, applications shall use the <strong>nxd_icmp_enable</strong> service</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_12">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_12">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful ICMP enable.</p>
</li>
<li>
<p><strong>NX_ALREADY_ENABLED</strong> (0x15) ICMP is already enabled.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_12">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_12">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_12">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Enable ICMP on the previously created IP Instance ip_0. */
status = nx_icmp_enable(&amp;ip_0);

/* If status is NX_SUCCESS, ICMP is enabled. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_12">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_icmp_info_get</p>
</li>
<li>
<p>nx_icmp_ping</p>
</li>
<li>
<p>nxd_icmp_enable</p>
</li>
<li>
<p>nxd_icmp_ping</p>
</li>
<li>
<p>nxd_icmp_source_ping</p>
</li>
<li>
<p>nxd_icmpv6_ra_flag_callback_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_icmp_info_get">nx_icmp_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve information about ICMP activities</p>
</div>
<div class="sect2">
<h3 id="_prototype_13">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_icmp_info_get(
    NX_IP *ip_ptr,
    ULONG *pings_sent,
    ULONG *ping_timeouts,
    ULONG *ping_threads_suspended,
    ULONG *ping_responses_received,
    ULONG *icmp_checksum_errors,
    ULONG *icmp_unhandled_messages);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_13">Description</h3>
<div class="paragraph">
<p>This service retrieves information about ICMP activities for the specified IP instance.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[!NOTE]<br>
<em>If a destination pointer is NX_NULL, that particular information is not returned to the caller</em>.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_13">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>pings_sent</em>: Pointer to destination for the total number of pings sent.</p>
</li>
<li>
<p><em>ping_timeouts</em>: Pointer to destination for the total number of ping timeouts.</p>
</li>
<li>
<p><em>ping_threads_suspended</em>: Pointer to destination of the total number of threads suspended on ping requests.</p>
</li>
<li>
<p><em>ping_responses_received</em>: Pointer to destination of the total number of ping responses received.</p>
</li>
<li>
<p><em>icmp_checksum_errors</em>: Pointer to destination of the total number of ICMP checksum errors.</p>
</li>
<li>
<p><em>icmp_unhandled_messages</em>: Pointer to destination of the total number of un-handled ICMP messages.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_13">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful ICMP information retrieval.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_13">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_13">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_13">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Retrieve ICMP information from previously created IP
   instance ip_0. */
status = nx_icmp_info_get(&amp;ip_0, &amp;pings_sent, &amp;ping_timeouts,
                          &amp;ping_threads_suspended,
                          &amp;ping_responses_received,
                          &amp;icmp_checksum_errors,
                          &amp;icmp_unhandled_messages);
/* If status is NX_SUCCESS, ICMP information was retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_13">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_icmp_enable</p>
</li>
<li>
<p>nx_icmp_ping</p>
</li>
<li>
<p>nxd_icmp_enable</p>
</li>
<li>
<p>nxd_icmp_ping</p>
</li>
<li>
<p>nxd_icmp_source_ping</p>
</li>
<li>
<p>nxd_icmpv6_ra_flag_callback_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_icmp_ping">nx_icmp_ping</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send ping request to specified IP address</p>
</div>
<div class="sect2">
<h3 id="_prototype_14">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_icmp_ping(
    NX_IP *ip_ptr,
    ULONG ip_address,
    CHAR *data, ULONG data_size,
    NX_PACKET **response_ptr,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_14">Description</h3>
<div class="paragraph">
<p>This service sends a ping request to the specified IP address and waits for the specified amount of time for a ping response message. If no response is received, an error is returned. Otherwise, the entire response message is returned in the variable pointed to by response_ptr.</p>
</div>
<div class="paragraph">
<p>To send a ping request to an IPv6 destination, applications shall use the <strong><em>nxd_icmp_ping</em></strong> or <strong><em>nxd_icmp_source_ping</em></strong> service.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>If NX_SUCCESS is returned, the application is responsible for releasing the received packet after it is no longer needed</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_14">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>ip_address</em>: IP address, in host byte order, to ping.</p>
</li>
<li>
<p><em>data</em>: Pointer to data area for ping message.</p>
</li>
<li>
<p><em>data_size</em>: Number of bytes in the ping data</p>
</li>
<li>
<p><em>response_ptr</em>: Pointer to packet pointer to return the ping response message in.</p>
</li>
<li>
<p><em>wait_option</em>: Defines the number of ThreadX timer ticks to wait for a ping response. The wait options are defined as follows:</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Wait Option</th>
<th class="tableblock halign-left valign-top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_NO_WAIT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(0x00000000)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">timeout value in ticks</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(0x00000001 through 0xFFFFFFFE)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_WAIT_FOREVER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFFFFFFFF</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_return_values_14">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful ping. Response message pointer was placed in the variable pointed to by response_ptr.</p>
</li>
<li>
<p><strong>NX_NO_PACKET</strong> (0x01) Unable to allocate a ping request packet.</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Specified data area exceeds the default packet size for this IP instance.</p>
</li>
<li>
<p><strong>NX_NO_RESPONSE</strong> (0x29) Requested IP did not respond.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP address.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or response pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_14">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_14">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_14">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Issue a ping to IP address 1.2.3.5 from the previously created IP
   Instance ip_0. */
status = nx_icmp_ping(&amp;ip_0, IP_ADDRESS(1,2,3,5), "abcd", 4,
                      &amp;response_ptr, 10);

/* If status is NX_SUCCESS, a ping response was received from IP
   address 1.2.3.5 and the response packet is contained in the
   packet pointed to by response_ptr. It should have the same "abcd"
   four bytes of data. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_14">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_icmp_enable</p>
</li>
<li>
<p>nx_icmp_info_get</p>
</li>
<li>
<p>nxd_icmp_enable</p>
</li>
<li>
<p>nxd_icmp_ping</p>
</li>
<li>
<p>nxd_icmp_source_ping</p>
</li>
<li>
<p>nxd_icmpv6_ra_flag_callback_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_igmp_enable">nx_igmp_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable Internet Group Management Protocol (IGMP)</p>
</div>
<div class="sect2">
<h3 id="_prototype_15">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_igmp_enable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_15">Description</h3>
<div class="paragraph">
<p>This service enables the IGMP component on the specified IP instance. The IGMP component is responsible for providing support for IP multicast group management operations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_15">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_15">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IGMP enable.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_ALREADY_ENABLED</strong> (0x15) This component has already been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_15">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_15">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_15">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Enable IGMP on the previously created IP Instance ip_0. */
status = nx_igmp_enable(&amp;ip_0);

/* If status is NX_SUCCESS, IGMP is enabled. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_15">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_igmp_info_get</p>
</li>
<li>
<p>nx_igmp_loopback_disable</p>
</li>
<li>
<p>nx_igmp_loopback_enable</p>
</li>
<li>
<p>nx_igmp_multicast_interface_join</p>
</li>
<li>
<p>nx_igmp_multicast_join</p>
</li>
<li>
<p>nx_igmp_multicast_interface_leave</p>
</li>
<li>
<p>nx_igmp_multicast_leave</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_join</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_leave</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_join</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_leave</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_igmp_info_get">nx_igmp_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve information about IGMP activities</p>
</div>
<div class="sect2">
<h3 id="_prototype_16">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_igmp_info_get(
    NX_IP *ip_ptr,
    ULONG *igmp_reports_sent,
    ULONG *igmp_queries_received,
    ULONG *igmp_checksum_errors,
    ULONG *current_groups_joined);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_16">Description</h3>
<div class="paragraph">
<p>This service retrieves information about IGMP activities for the specified IP instance.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If a destination pointer is NX_NULL, that particular information is not returned to the caller</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_16">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>igmp_reports_sent</em>: Pointer to destination for the total number of ICMP reports sent.</p>
</li>
<li>
<p><em>igmp_queries_received</em>: Pointer to destination for the total number of queries received by multicast router.</p>
</li>
<li>
<p><em>igmp_checksum_errors</em>: Pointer to destination of the total number of IGMP checksum errors on receive packets.</p>
</li>
<li>
<p><em>current_groups_joined</em>: Pointer to destination of the current number of groups joined through this IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_16">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IGMP information retrieval.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_16">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_16">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_16">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Retrieve IGMP information from previously created IP Instance ip_0. */
status = nx_igmp_info_get(&amp;ip_0, &amp;igmp_reports_sent,
                          &amp;igmp_queries_received,
                          &amp;igmp_checksum_errors,
                          &amp;current_groups_joined);

/* If status is NX_SUCCESS, IGMP information was retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_16">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_igmp_enable</p>
</li>
<li>
<p>nx_igmp_loopback_disable</p>
</li>
<li>
<p>nx_igmp_loopback_enable</p>
</li>
<li>
<p>nx_igmp_multicast_interface_join</p>
</li>
<li>
<p>nx_igmp_multicast_join</p>
</li>
<li>
<p>nx_igmp_multicast_interface_leave</p>
</li>
<li>
<p>nx_igmp_multicast_leave</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_join</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_leave</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_join</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_leave</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_igmp_loopback_disable">nx_igmp_loopback_disable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Disable IGMP loopback</p>
</div>
<div class="sect2">
<h3 id="_prototype_17">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_igmp_loopback_disable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_17">Description</h3>
<div class="paragraph">
<p>This service disables IGMP loopback for all subsequent multicast groups joined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_17">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_17">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IGMP loopback disable.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) IGMP is not enabled.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Caller is not a thread or initialization.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_17">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_17">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_17">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Disable IGMP loopback for all subsequent multicast groups
   joined. */
status = nx_igmp_loopback_disable(&amp;ip_0);

/* If status is NX_SUCCESS IGMP loopback is disabled. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_17">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_igmp_enable</p>
</li>
<li>
<p>nx_igmp_info_get</p>
</li>
<li>
<p>nx_igmp_loopback_enable</p>
</li>
<li>
<p>nx_igmp_multicast_interface_join</p>
</li>
<li>
<p>nx_igmp_multicast_join</p>
</li>
<li>
<p>nx_igmp_multicast_interface_leave</p>
</li>
<li>
<p>nx_igmp_multicast_leave</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_join</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_leave</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_join</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_leave</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_igmp_loopback_enable">nx_igmp_loopback_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable IGMP loopback</p>
</div>
<div class="sect2">
<h3 id="_prototype_18">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_igmp_loopback_enable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_18">Description</h3>
<div class="paragraph">
<p>This service enables IGMP loopback for all subsequent multicast groups joined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_18">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_18">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IGMP loopback disable.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) IGMP is not enabled.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Caller is not a thread or initialization.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_18">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_18">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_18">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Enable IGMP loopback for all subsequent multicast
   groups joined. */
status = nx_igmp_loopback_enable(&amp;ip_0);

/* If status is NX_SUCCESS IGMP loopback is enabled. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_18">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_igmp_enable</p>
</li>
<li>
<p>nx_igmp_info_getnx_igmp_loopback_disable</p>
</li>
<li>
<p>nx_igmp_multicast_interface_join</p>
</li>
<li>
<p>nx_igmp_multicast_join</p>
</li>
<li>
<p>nx_igmp_multicast_interface_leave</p>
</li>
<li>
<p>nx_igmp_multicast_leave</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_join</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_leave</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_join</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_leave</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_igmp_multicast_interface_join">nx_igmp_multicast_interface_join</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Join IP instance to specified multicast group via an interface</p>
</div>
<div class="sect2">
<h3 id="_prototype_19">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_igmp_multicast_interface_join(
    NX_IP *ip_ptr,
    ULONG group_address,
    UINT interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_19">Description</h3>
<div class="paragraph">
<p>This service joins an IP instance to the specified multicast group via a specified network interface. An internal counter is maintained to keep track of the number of times the same group has been joined. After joining the multicast group, the IGMP component will allow reception of IP packets with this group address via the specified network interface and also report to routers that this IP is a member of this multicast group. The IGMP membership join, report, and leave messages are also sent via the specified network interface. To join an IPv4 multicast group without sending IGMP group membership report, application shall use the service <strong><em>nx_ipv4_multicast_interface_join</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_19">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>group_address</em>: Class D IP multicast group address to join in host byte order.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the Interface attached to the NetX Duo instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_19">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful multicast group join.</p>
</li>
<li>
<p><strong>NX_NO_MORE_ENTRIES</strong> (0x17) No more multicast groups can be joined, maximum exceeded.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index points to an invalid network interface.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Multicast group address provided is not a valid class D address.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) IP multicast support is not enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_19">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_19">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_19">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Previously created IP Instance joins the multicast group
   244.0.0.200, via the interface at index 1 in the IP interface
   list. */
#define INTERFACE_INDEX 1
status = nx_igmp_multicast_interface_join
                                 (&amp;ip IP_ADDRESS(244,0,0,200),
                                  INTERFACE_INDEX);

/* If status is NX_SUCCESS, the IP instance has successfully joined
   the multicast group. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_19">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_igmp_enable</p>
</li>
<li>
<p>nx_igmp_info_getnx_igmp_loopback_disable</p>
</li>
<li>
<p>nx_igmp_loopback_enable</p>
</li>
<li>
<p>nx_igmp_multicast_join</p>
</li>
<li>
<p>nx_igmp_multicast_interface_leave</p>
</li>
<li>
<p>nx_igmp_multicast_leave</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_join</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_leave</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_join</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_leave</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_igmp_multicast_interface_leave">nx_igmp_multicast_interface_leave</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Leave specified multicast group via an interface</p>
</div>
<div class="sect2">
<h3 id="_prototype_20">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_igmp_multicast_interface_leave(
    NX_IP *ip_ptr,
    ULONG group_address,
    UINT interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_20">Description</h3>
<div class="paragraph">
<p>This service leaves the specified multicast group via a specified network interface. An internal counter is maintained to keep track of the number of times the same group has been a member of. After leaving the multicast group, the IGMP component will send out proper membership report, and may leave the group if there are no members from this node. To leave an IPv4 multicast group without sending IGMP group membership report, application shall use the service <strong><em>nx_ipv4_multicast_interface_leave</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_20">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>group_address</em>: Class D IP multicast group address to leave. The IP address is in host byte order.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the Interface attached to the NetX Duo instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_20">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful multicast group join.</p>
</li>
<li>
<p><strong>NX_ENTRY_NOT_FOUND</strong> (0x16) The specified multicast group address cannot be found in the local multicast table.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index points to an invalid network interface.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Multicast group address provided is not a valid class D address.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) IP multicast support is not enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_20">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_20">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_20">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Leave the multicast group 244.0.0.200. */
#define INTERFACE_INDEX 1
status = nx_igmp_multicast_interface_leave
                                (&amp;ip IP_ADDRESS(244,0,0,200),
                                 INTERFACE_INDEX);

/* If status is NX_SUCCESS, the IP instance has successfully leaves
   the multicast group 244.0.0.200. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_20">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_igmp_enable</p>
</li>
<li>
<p>nx_igmp_info_getnx_igmp_loopback_disable</p>
</li>
<li>
<p>nx_igmp_loopback_enable</p>
</li>
<li>
<p>nx_igmp_multicast_interface_join</p>
</li>
<li>
<p>nx_igmp_multicast_join</p>
</li>
<li>
<p>nx_igmp_multicast_leave</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_join</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_leave</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_join</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_leave</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_igmp_multicast_join">nx_igmp_multicast_join</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Join IP instance to specified multicast group</p>
</div>
<div class="sect2">
<h3 id="_prototype_21">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_igmp_multicast_join(
    NX_IP *ip_ptr,
    ULONG group_address);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_21">Description</h3>
<div class="paragraph">
<p>This service joins an IP instance to the specified multicast group. An internal counter is maintained to keep track of the number of times the same group has been joined. The driver is commanded to send an IGMP report if this is the first join request out on the network indicating the host&#8217;s intention to join the group. After joining, the IGMP component will allow reception of IP packets with this group address and report to routers that this IP is a member of this multicast group. To join an IPv4 multicast group without sending IGMP group membership report, application shall use the service <strong><em>nx_ipv4_multicast_interface_join</em></strong>.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[!NOTE]<br>
<em>To join a multicast group on a non-primary device, use the service *nx_igmp_multicast_interface_join.*</em></p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_21">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>group_address</em>: Class D IP multicast group address to join.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_21">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful multicast group join.</p>
</li>
<li>
<p><strong>NX_NO_MORE_ENTRIES</strong> (0x17) No more multicast groups can be joined, maximum exceeded.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index points to an invalid network interface.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP group address.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_21">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_21">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_21">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Previously created IP Instance ip_0 joins the multicast group
   224.0.0.200. */
status = nx_igmp_multicast_join(&amp;ip_0, IP_ADDRESS(224,0,0,200);

/* If status is NX_SUCCESS, this IP instance has successfully
   joined the multicast group 224.0.0.200. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_21">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_igmp_enable</p>
</li>
<li>
<p>nx_igmp_info_get</p>
</li>
<li>
<p>nx_igmp_loopback_disable</p>
</li>
<li>
<p>nx_igmp_loopback_enable</p>
</li>
<li>
<p>nx_igmp_multicast_interface_join</p>
</li>
<li>
<p>nx_igmp_multicast_interface_leave</p>
</li>
<li>
<p>nx_igmp_multicast_leave</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_join</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_leave</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_join</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_leave</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_igmp_multicast_leave">nx_igmp_multicast_leave</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cause IP instance to leave specified multicast group</p>
</div>
<div class="sect2">
<h3 id="_prototype_22">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_igmp_multicast_leave(
    NX_IP *ip_ptr,
    ULONG group_address);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_22">Description</h3>
<div class="paragraph">
<p>This service causes an IP instance to leave the specified multicast group, if the number of leave requests matches the number of join requests. Otherwise, the internal join count is simply decremented. To leave an IPv4 multicast group without sending IGMP group membership report, application shall use the service <strong><em>nx_ipv4_multicast_interface_leave</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_22">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>group_address</em>: Multicast group to leave.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_22">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful multicast group join.</p>
</li>
<li>
<p><strong>NX_ENTRY_NOT_FOUND</strong> (0x16) Previous join request was not found.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index points to an invalid network interface.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP group address.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_22">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_22">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_22">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Cause IP instance to leave the multicast group 224.0.0.200. */
status = nx_igmp_multicast_leave(&amp;ip_0, IP_ADDRESS(224,0,0,200);

/* If status is NX_SUCCESS, this IP instance has successfully left
   the multicast group 224.0.0.200. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_22">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_igmp_enable</p>
</li>
<li>
<p>nx_igmp_info_get</p>
</li>
<li>
<p>nx_igmp_loopback_disable</p>
</li>
<li>
<p>nx_igmp_loopback_enable</p>
</li>
<li>
<p>nx_igmp_multicast_interface_join</p>
</li>
<li>
<p>nx_igmp_multicast_join</p>
</li>
<li>
<p>nx_igmp_multicast_interface_leave</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_join</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_leave</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_join</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_leave</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_address_change_notifiy">nx_ip_address_change_notifiy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Notify application if IP address changes</p>
</div>
<div class="sect2">
<h3 id="_prototype_23">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_address_change_notify(
    NX_IP *ip_ptr,
    VOID(*change_notify)(NX_IP *, VOID *),
    VOID *additional_info);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_23">Description</h3>
<div class="paragraph">
<p>This service registers an application notification function that is called whenever the IPv4 address is changed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_23">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>change_notify</em>: Pointer to IP change notification function. If this parameter is NX_NULL, IP address change notification is disabled.</p>
</li>
<li>
<p><em>additional_info</em>: Pointer to optional additional information that is also supplied to the notification function when the IP address is changed.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_23">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP address change notification.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_23">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_23">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_23">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Register the function "my_ip_changed" to be called whenever the
   IP address is changed. */
status = nx_ip_address_change_notify(&amp;ip_0, my_ip_changed,
                                      NX_NULL);

/* If status is NX_SUCCESS, the "my_ip_changed" function will be
   called whenever the IP address changes. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_23">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_address_get">nx_ip_address_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve IPv4 address and network mask</p>
</div>
<div class="sect2">
<h3 id="_prototype_24">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_address_get(
    NX_IP *ip_ptr,
    ULONG *ip_address,
    ULONG *network_mask);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_24">Description</h3>
<div class="paragraph">
<p>This service retrieves IPv4 address and its subnet mask of the primary network interface.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>To obtain information of the secondary device, use the service *nx_ip_interface_address_get*</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_24">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to destination for IP address.</p>
</li>
<li>
<p><em>network_mask</em>: Pointer to destination for network mask.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_24">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP address get.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or return variable pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_24">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_24">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_24">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Get the IP address and network mask from the previously created
   IP Instance ip_0. */
status = nx_ip_address_get(&amp;ip_0, &amp;ip_address, &amp;network_mask);

/* If status is NX_SUCCESS, the variables ip_address and
   network_mask contain the IP and network mask respectively. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_24">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_address_set">nx_ip_address_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set IPv4 address and network mask</p>
</div>
<div class="sect2">
<h3 id="_prototype_25">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_address_set(
    NX_IP *ip_ptr,
    ULONG ip_address,
    ULONG network_mask);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_25">Description</h3>
<div class="paragraph">
<p>This service sets IPv4 address and network mask for the primary network interface.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>To set IP address and network mask for the secondary device, use the service *nx_ip_interface_address_set*</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_25">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>ip_address</em>: New IP address.</p>
</li>
<li>
<p><em>network_mask</em>: New network mask.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_25">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP address set.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP address.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_25">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_25">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_25">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Set the IP address and network mask to 1.2.3.4 and 0xFFFFFF00 for
   the previously created IP Instance ip_0. */
status = nx_ip_address_set(&amp;ip_0, IP_ADDRESS(1,2,3,4),
                           0xFFFFFF00UL);

/* If status is NX_SUCCESS, the IP instance now has an IP address of
   1.2.3.4 and a network mask of 0xFFFFFF00. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_25">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_auxiliary_packet_pool_set">nx_ip_auxiliary_packet_pool_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Configure an auxiliary packet pool</p>
</div>
<div class="sect2">
<h3 id="_prototype_26">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_auxiliary_packet_pool_set(
    NX_IP *ip_ptr,
    NX_PACKET_POOL *aux_pool);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_26">Description</h3>
<div class="paragraph">
<p>This service configures an auxiliary packet pool in the IP instance. For a memory-constrained system, the user may increase memory efficiency by creating the default packet pool with packet size of MTU, and creating an auxiliary packet pool with smaller packet size for the IP thread to transmit small packets with. The recommended packet size for the auxiliary pool is 256 bytes, assuming IPv6 and IPsec are both enabled.</p>
</div>
<div class="paragraph">
<p>By default the IP instance does not accept the auxiliary packet pool. To enable this feature, <em>NX_DUAL_PACKET_POOL_ENABLE</em> must be defined when compiling the NetX Duo library.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_26">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>aux_pool</em>: The auxiliary packet pool to be configured for the IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_26">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP address set.</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) The dual packet pool feature is not compiled in the library.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer or pool pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_26">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_26">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_26">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define SMALL_PAYLOAD_SIZE 256
NX_PACKET small_pool;

nx_packet_pool_create(&amp;small_pool, "small pool", SMALL_PAYLOAD_SIZE,
                       small_pool_memory_ptr, small_pool_size);

/* Add the small packet pool to the IP instance. */
status = nx_ip_auxiliary_packet_pool_set(&amp;ip_0, &amp;small_pool);

/* If status is NX_SUCCESS, the IP instance now is able to use the
   small pool for transmitting small datagram. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_26">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_packet_allocate</p>
</li>
<li>
<p>nx_packet_copy</p>
</li>
<li>
<p>nx_packet_data_append</p>
</li>
<li>
<p>nx_packet_data_extract_offset</p>
</li>
<li>
<p>nx_packet_data_retrieve</p>
</li>
<li>
<p>nx_packet_length_get</p>
</li>
<li>
<p>nx_packet_pool_create</p>
</li>
<li>
<p>nx_packet_pool_delete</p>
</li>
<li>
<p>nx_packet_pool_info_get</p>
</li>
<li>
<p>nx_packet_pool_low_watermark_set</p>
</li>
<li>
<p>nx_packet_release</p>
</li>
<li>
<p>nx_packet_transmit_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_create">nx_ip_create</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create an IP instance</p>
</div>
<div class="sect2">
<h3 id="_prototype_27">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_create(
    NX_IP *ip_ptr,
    CHAR *name, ULONG ip_address,
    ULONG network_mask,
    NX_PACKET_POOL *default_pool,
    VOID (*ip_network_driver)(NX_IP_DRIVER *),
    VOID *memory_ptr,
    ULONG memory_size,
    UINT priority);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_27">Description</h3>
<div class="paragraph">
<p>This service creates an IP instance with the user supplied IP address and network driver. In addition, the application must supply a previously created packet pool for the IP instance to use for internal packet allocation. Note that the supplied application network driver is not called until this IP&#8217;s thread executes.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_27">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to control block to create a new IP instance.</p>
</li>
<li>
<p><em>name</em>: Name of this new IP instance.</p>
</li>
<li>
<p><em>ip_address</em>: IP address for this new IP instance.</p>
</li>
<li>
<p><em>network_mask</em>: Mask to delineate the network portion of the IP address for sub-netting and super-netting uses.</p>
</li>
<li>
<p><em>default_pool</em>: Pointer to control block of previously created NetX Duo packet pool.</p>
</li>
<li>
<p><em>ip_network_driver</em>: User-supplied network driver used to send and receive IP packets.</p>
</li>
<li>
<p><em>memory_ptr</em>: Pointer to memory area for the IP helper thread&#8217;s stack area.</p>
</li>
<li>
<p><em>memory_size</em>: Number of bytes in the memory area for the IP helper thread&#8217;s stack.</p>
</li>
<li>
<p><em>priority</em>: Priority of IP helper thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_27">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP instance creation.</p>
</li>
<li>
<p><strong>NX_NOT_IMPLEMENTED</strong> (0x4A) NetX Duo library is configured incorrectly.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP, network driver function pointer, packet pool, or memory pointer.</p>
</li>
<li>
<p><strong>NX_SIZE_ERROR</strong> (0x09) The supplied stack size is too small.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) The supplied IP address is invalid.</p>
</li>
<li>
<p><strong>NX_OPTION_ERROR</strong> (0x21) The supplied IP thread priority is invalid.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_27">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_27">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_27">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Create an IP instance with an IP address of 1.2.3.4 and a network
   mask of 0xFFFFFF00UL. The "ethernet_driver" specifies the entry
   point of the application specific network driver and the
   "stack_memory_ptr" specifies the start of a 1024 byte memory
   area that is used for this IP instance's helper thread. */
status = nx_ip_create(&amp;ip_0, "NetX IP Instance ip_0",
                      IP_ADDRESS(1, 2, 3, 4),
                      0xFFFFFF00UL, &amp;pool_0, ethernet_driver,
                      stack_memory_ptr, 1024, 1);

/* If status is NX_SUCCESS, the IP instance has been created. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_27">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_delete">nx_ip_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Delete previously created IP instance</p>
</div>
<div class="sect2">
<h3 id="_prototype_28">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_delete(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_28">Description</h3>
<div class="paragraph">
<p>This service deletes a previously created IP instance and releases all of the system resources owned by the IP instance.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_28">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_28">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP deletion.</p>
</li>
<li>
<p><strong>NX_SOCKETS_BOUND</strong> (0x28) This IP instance still has UDP or TCP sockets bound to it. All sockets must be unbound and deleted prior to deleting the IP instance.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_28">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_28">Preemption Possible</h3>
<div class="paragraph">
<p>Yes</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_28">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Delete a previously created IP instance. */
status = nx_ip_delete(&amp;ip_0);

/* If status is NX_SUCCESS, the IP instance has been deleted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_28">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_driver_direct_command">nx_ip_driver_direct_command</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Issue command to network driver</p>
</div>
<div class="sect2">
<h3 id="_prototype_29">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_driver_direct_command
    (NX_IP *ip_ptr,
    UINT command,
    ULONG *return_value_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_29">Description</h3>
<div class="paragraph">
<p>This service provides a direct interface to the application&#8217;s primary network interface driver specified during the <strong><em>nx_ip_create</em></strong> call. Application-specific commands can be used providing their numeric value is greater than or equal to <strong>NX_LINK_USER_COMMAND</strong>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>To issue command for the secondary device, use the <strong>nx_ip_driver_interface_direct_command</strong> service</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_29">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>command</em>: Numeric command code. Standard commands are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_LINK_GET_STATUS</strong> (10)</p>
</li>
<li>
<p><strong>NX_LINK_GET_SPEED</strong> (11)</p>
</li>
<li>
<p><strong>NX_LINK_GET_DUPLEX_TYPE</strong> (12)</p>
</li>
<li>
<p><strong>NX_LINK_GET_ERROR_COUNT</strong> (13)</p>
</li>
<li>
<p><strong>NX_LINK_GET_RX_COUNT</strong> (14)</p>
</li>
<li>
<p><strong>NX_LINK_GET_TX_COUNT</strong> (15)</p>
</li>
<li>
<p><strong>NX_LINK_GET_ALLOC_ERRORS</strong> (16)</p>
</li>
<li>
<p><strong>NX_LINK_USER_COMMAND</strong> (50)</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>return_value_ptr</em>: Pointer to return variable in the caller.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_29">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful network driver direct command.</p>
</li>
<li>
<p><strong>NX_UNHANDLED_COMMAND</strong> (0x44) Unhandled or unimplemented network driver command.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or return value pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid interface index.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_29">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_29">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_29">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Make a direct call to the application-specific network driver
   for the previously created IP instance. For this example, the
   network driver is interrogated for the link status. */
status = nx_ip_driver_direct_command(&amp;ip_0, NX_LINK_GET_STATUS,
                                     &amp;link_status);

/* If status is NX_SUCCESS, the link_status variable contains a
   NX_TRUE or NX_FALSE value representing the status of the
   physical link. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_29">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_driver_interface_direct_command">nx_ip_driver_interface_direct_command</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Issue command to network driver</p>
</div>
<div class="sect2">
<h3 id="_prototype_30">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_driver_interface_direct_command(
    NX_IP *ip_ptr,
    UINT command,
    UINT interface_index,
    ULONG *return_value_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_30">Description</h3>
<div class="paragraph">
<p>This service provides a direct command to the application&#8217;s network device driver in the IP instance. Application-specific commands can be used providing their numeric value is greater than or equal to <em>NX_LINK_USER_COMMAND</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_30">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>command</em>: Numeric command code. Standard commands are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_LINK_GET_STATUS</strong> (10)</p>
</li>
<li>
<p><strong>NX_LINK_GET_SPEED</strong> (11)</p>
</li>
<li>
<p><strong>NX_LINK_GET_DUPLEX_TYPE</strong> (12)</p>
</li>
<li>
<p><strong>NX_LINK_GET_ERROR_COUNT</strong> (13)</p>
</li>
<li>
<p><strong>NX_LINK_GET_RX_COUNT</strong> (14)</p>
</li>
<li>
<p><strong>NX_LINK_GET_TX_COUNT</strong> (15)</p>
</li>
<li>
<p><strong>NX_LINK_GET_ALLOC_ERRORS</strong> (16)</p>
</li>
<li>
<p><strong>NX_LINK_USER_COMMAND</strong> (50)</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface the command should be sent to.</p>
</li>
<li>
<p><em>return_value_ptr</em>: Pointer to return variable in the caller.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_30">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful network driver direct command.</p>
</li>
<li>
<p><strong>NX_UNHANDLED_COMMAND</strong> (0x44) Unhandled or unimplemented network driver command.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid interface index</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or return value pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_30">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_30">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_30">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Make a direct call to the application-specific network driver
   for the previously created IP instance. For this example, the
   network driver is interrogated for the link status. */

/* Set the interface index to the primary device. */
UINT interface_index = 0;

status = nx_ip_driver_interface_direct_command(&amp;ip_0,
                                               NX_LINK_GET_STATUS,
                                               interface_index,
                                               &amp;link_status);

/* If status is NX_SUCCESS, the link_status variable contains a
   NX_TRUE or NX_FALSE value representing the status of the
   physical link. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_30">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_forwarding_disable">nx_ip_forwarding_disable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Disable IP packet forwarding</p>
</div>
<div class="sect2">
<h3 id="_prototype_31">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_forwarding_disable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_31">Description</h3>
<div class="paragraph">
<p>This service disables forwarding IP packets inside the NetX Duo IP component. On creation of the IP task, this service is automatically disabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_31">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_31">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP forwarding disable.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_31">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_31">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_31">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Disable IP forwarding on this IP instance. */
status = nx_ip_forwarding_disable(&amp;ip_0);

/* If status is NX_SUCCESS, IP forwarding has been disabled on the
   previously created IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_31">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_forwarding_enable">nx_ip_forwarding_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable IP packet forwarding</p>
</div>
<div class="sect2">
<h3 id="_prototype_32">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_forwarding_enable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_32">Description</h3>
<div class="paragraph">
<p>This service enables forwarding IP packets inside the NetX Duo IP component. On creation of the IP task, this service is automatically disabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_32">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_32">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP forwarding enable.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_32">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_32">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_32">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Enable IP forwarding on this IP instance. */
status = nx_ip_forwarding_enable(&amp;ip_0);

/* If status is NX_SUCCESS, IP forwarding has been enabled on the
   previously created IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_32">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_fragment_disable">nx_ip_fragment_disable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Disable IP packet fragmenting</p>
</div>
<div class="sect2">
<h3 id="_prototype_33">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_fragment_disable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_33">Description</h3>
<div class="paragraph">
<p>This service disables IPv4 and IPv6 packet fragmenting and reassembling functionality. For packets waiting to be reassembled, this service releases these packets. On creation of the IP task, this service is automatically disabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_33">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_33">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP fragment disable.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) IP Fragmentation is not enabled on the IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_33">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_33">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_33">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Disable IP fragmenting on this IP instance. */
status = nx_ip_fragment_disable(&amp;ip_0);

/* If status is NX_SUCCESS, disables IP fragmenting on the
   previously created IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_33">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_fragment_enable">nx_ip_fragment_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable IP packet fragmenting</p>
</div>
<div class="sect2">
<h3 id="_prototype_34">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_fragment_enable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_34">Description</h3>
<div class="paragraph">
<p>This service enables IPv4 and IPv6 packet fragmenting and reassembling functionality. On creation of the IP task, this service is automatically disabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_34">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_34">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP fragment enable.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) IP Fragmentation features is not compiled into NetX Duo.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_34">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_34">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_34">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Enable IP fragmenting on this IP instance. */
status = nx_ip_fragment_enable(&amp;ip_0);

/* If status is NX_SUCCESS, IP fragmenting has been enabled on the
   previously created IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_34">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_gateway_address_clear">nx_ip_gateway_address_clear</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clear the IPv4 gateway address</p>
</div>
<div class="sect2">
<h3 id="_prototype_35">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_gateway_address_clear(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_35">Description</h3>
<div class="paragraph">
<p>This service clears the IPv4 gateway address configured in the instance. To clear an IPv6 default outer from the IP instance, applications shall use the service <strong><em>nxd_ipv6_default_router_delete.</em></strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_35">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_35">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully cleared the IP gateway address.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Service is not called from system initialization or thread context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_35">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_35">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_35">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Clear the gateway address of IP instance. */
status = nx_ip_gateway_address_clear(&amp;ip_0);

/* If status == NX_SUCCESS, the gateway address was successfully
   cleared from the IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_35">See Also</h3>
<div class="paragraph">
<p>-nx_ip_gateway_address_get
-nx_ip_gateway_address_set
-nx_ip_info_get
-nx_ip_static_route_add
-nx_ip_static_route_delete
-nxd_ipv6_default_router_add
-nxd_ipv6_default_router_delete
-nxd_ipv6_default_router_entry_get
-nxd_ipv6_default_router_get
-nxd_ipv6_default_router_number_of_entries_get</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_gateway_address_get">nx_ip_gateway_address_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Get the IPv4 gateway address</p>
</div>
<div class="sect2">
<h3 id="_prototype_36">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_gateway_address_get(
    NX_IP *ip_ptr,
    ULONG *ip_address);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_36">Description</h3>
<div class="paragraph">
<p>This service retrieves the IPv4 gateway address configured in the IP instance.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_36">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to the memory where the gateway address is stored</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_36">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful get</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer or ip address pointer</p>
</li>
<li>
<p><strong>NX_NOT_FOUND</strong> (0x4E) Gateway address not found</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Service is not called from system initialization or thread context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_36">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_36">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_36">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">ULONG ip_address;

/* Get the gateway address of IP instance. */
status = nx_ip_gateway_address_get(&amp;ip_0, &amp;ip_address);

/* If status == NX_SUCCESS, the gateway address was successfully
   got. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_36">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_gateway_address_clear</p>
</li>
<li>
<p>nx_ip_gateway_address_set</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_static_route_add</p>
</li>
<li>
<p>nx_ip_static_route_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_add</p>
</li>
<li>
<p>nxd_ipv6_default_router_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_entry_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_number_of_entries_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_gateway_address_set">nx_ip_gateway_address_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set Gateway IP address</p>
</div>
<div class="sect2">
<h3 id="_prototype_37">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_gateway_address_set(
    NX_IP *ip_ptr,
    ULONG ip_address);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_37">Description</h3>
<div class="paragraph">
<p>This service sets the IPv4 gateway IP address. All out-of-network traffic are routed to this gateway for transmission. The gateway must be directly accessible through one of the network interfaces. To configure IPv6 gateway address, use the service <strong><em>nxd_ipv6_default_router_add.</em></strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_37">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>ip_address</em>: IP address of the gateway.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_37">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful Gateway IP address set.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance pointer.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP address.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_37">Allowed From</h3>
<div class="paragraph">
<p>Initialization, thread</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_37">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_37">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Setup the Gateway address for previously created IP
   Instance ip_0. */
status = nx_ip_gateway_address_set(&amp;ip_0, IP_ADDRESS(1,2,3,99);

/* If status is NX_SUCCESS, all out-of-network send requests are
   routed to 1.2.3.99. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_37">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_gateway_address_clear</p>
</li>
<li>
<p>nx_ip_gateway_address_get</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_static_route_add</p>
</li>
<li>
<p>nx_ip_static_route_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_add</p>
</li>
<li>
<p>nxd_ipv6_default_router_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_entry_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_number_of_entries_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_info_get">nx_ip_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve information about IP activities</p>
</div>
<div class="sect2">
<h3 id="_prototype_38">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_info_get(
    NX_IP *ip_ptr,
    ULONG *ip_total_packets_sent,
    ULONG *ip_total_bytes_sent,
    ULONG *ip_total_packets_received,
    ULONG *ip_total_bytes_received,
    ULONG *ip_invalid_packets,
    ULONG *ip_receive_packets_dropped,
    ULONG *ip_receive_checksum_errors,
    ULONG *ip_send_packets_dropped,
    ULONG *ip_total_fragments_sent,
    ULONG *ip_total_fragments_received);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_38">Description</h3>
<div class="paragraph">
<p>This service retrieves information about IP activities for the specified IP instance.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[!NOTE]<br>
<em>If a destination pointer is NX_NULL, that particular information is not returned to the caller</em>.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_38">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>ip_total_packets_sent</em>: Pointer to destination for the total number of IP packets sent.</p>
</li>
<li>
<p><em>ip_total_bytes_sent</em>: Pointer to destination for the total number of bytes sent.</p>
</li>
<li>
<p><em>ip_total_packets_received</em>: Pointer to destination of the total number of IP receive packets.</p>
</li>
<li>
<p><em>ip_total_bytes_received</em>: Pointer to destination of the total number of IP bytes received.</p>
</li>
<li>
<p><em>ip_invalid_packets</em>: Pointer to destination of the total number of invalid IP packets.</p>
</li>
<li>
<p><em>ip_receive_packets_dropped</em>: Pointer to destination of the total number of receive packets dropped.</p>
</li>
<li>
<p><em>ip_receive_checksum_errors</em>: Pointer to destination of the total number of checksum errors in receive packets.</p>
</li>
<li>
<p><em>ip_send_packets_dropped</em>: Pointer to destination of the total number of send packets dropped.</p>
</li>
<li>
<p><em>ip_total_fragments_sent</em>: Pointer to destination of the total number of fragments sent.</p>
</li>
<li>
<p><em>ip_total_fragments_received</em>: Pointer to destination of the total number of fragments received.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_38">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP information retrieval.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_38">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_38">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_38">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Retrieve IP information from previously created IP
   Instance 0. */
status = nx_ip_info_get(&amp;ip_0,
                        &amp;ip_total_packets_sent,
                        &amp;ip_total_bytes_sent,
                        &amp;ip_total_packets_received,
                        &amp;ip_total_bytes_received,
                        &amp;ip_invalid_packets,
                        &amp;ip_receive_packets_dropped,
                        &amp;ip_receive_checksum_errors,
                        &amp;ip_send_packets_dropped,
                        &amp;ip_total_fragments_sent,
                        &amp;ip_total_fragments_received);

/* If status is NX_SUCCESS, IP information was retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_38">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_interface_address_get">nx_ip_interface_address_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve interface IP address</p>
</div>
<div class="sect2">
<h3 id="_prototype_39">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_interface_address_get (
    NX_IP *ip_ptr,
    UINT interface_index,
    ULONG *ip_address,
    ULONG *network_mask);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_39">Description</h3>
<div class="paragraph">
<p>This service retrieves the IPv4 address of a specified network interface. To retrieve IPv6 address, application shall use the service <strong><em>nxd_ipv6_address_get</em></strong></p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<em>The specified device, if not the primary device, must be previously attached to the IP instance</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_39">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Interface index, the same value as the index to the network interface attached to the IP instance.</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to destination for the device interface IP address.</p>
</li>
<li>
<p><em>network_mask</em>: Pointer to destination for the device interface network mask.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_39">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP address get.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Specified network interface is invalid.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_39">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_39">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_39">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define INTERFACE_INDEX 1

/* Get device IP address and network mask for the specified
   interface index 1 in IP instance list of interfaces). */
status = nx_ip_interface_address_get(ip_ptr,INTERFACE_INDEX,
                                     &amp;ip_address,
                                     &amp;network_mask);

/* If status is NX_SUCCESS the interface address was successfully
   retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_39">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_mapping_configure</p>
</li>
<li>
<p>nx_ip_interface_address_set</p>
</li>
<li>
<p>nx_ip_interface_attach</p>
</li>
<li>
<p>nx_ip_interface_capability_get</p>
</li>
<li>
<p>nx_ip_interface_capability_set</p>
</li>
<li>
<p>nx_ip_interface_detach</p>
</li>
<li>
<p>nx_ip_interface_info_get</p>
</li>
<li>
<p>nx_ip_interface_mtu_set</p>
</li>
<li>
<p>nx_ip_interface_physical_address_get</p>
</li>
<li>
<p>nx_ip_interface_physical_address_set</p>
</li>
<li>
<p>nx_ip_interface_status_check</p>
</li>
<li>
<p>nx_ip_link_status_change_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_interface_address_mapping_configure">nx_ip_interface_address_mapping_configure</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Configure whether address mapping is needed</p>
</div>
<div class="sect2">
<h3 id="_prototype_40">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_interface_address_mapping_configure(
    NX_IP *ip_ptr,
    UINT interface_index,
    UINT mapping_needed);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_40">Description</h3>
<div class="paragraph">
<p>This service configures whether IP address to MAC address mapping is needed for the specified network interface. This service is typically called from the interface device driver to notify the IP stack whether the underlying interface requires IP address to layer two (MAC) address mapping.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_40">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>interface_index</em>: Index to the network interface</p>
</li>
<li>
<p><em>mapping_needed</em>: NX_TRUE&#8201;&#8212;&#8201;address mapping needed NX_FALSE&#8201;&#8212;&#8201;address mapping not needed</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_40">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful configure</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index is not valid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Service is not called from system initialization or thread context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_40">Allowed From</h3>
<div class="paragraph">
<p>Thread</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_40">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_40">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PRIMARY_INTERFACE 0
UCHAR mapping_needed = NX_TRUE;

/* Configure address mapping needed specified interface. */
status = nx_ip_interface_address_mapping_configure(&amp;ip_0,
                                             PRIMARY_INTERFACE,
                                             mapping_needed);

/* If status == NX_SUCCESS, the address mapping needed was
   successfully configured. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_40">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_get</p>
</li>
<li>
<p>nx_ip_interface_address_set</p>
</li>
<li>
<p>nx_ip_interface_attach</p>
</li>
<li>
<p>nx_ip_interface_capability_get</p>
</li>
<li>
<p>nx_ip_interface_capability_set</p>
</li>
<li>
<p>nx_ip_interface_detach</p>
</li>
<li>
<p>nx_ip_interface_info_get</p>
</li>
<li>
<p>nx_ip_interface_mtu_set</p>
</li>
<li>
<p>nx_ip_interface_physical_address_get</p>
</li>
<li>
<p>nx_ip_interface_physical_address_set</p>
</li>
<li>
<p>nx_ip_interface_status_check</p>
</li>
<li>
<p>nx_ip_link_status_change_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_interface_address_set">nx_ip_interface_address_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set interface IP address and network mask</p>
</div>
<div class="sect2">
<h3 id="_prototype_41">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_interface_address_set(
    NX_IP *ip_ptr,
    UINT interface_index,
    ULONG ip_address,
    ULONG network_mask);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_41">Description</h3>
<div class="paragraph">
<p>This service sets the IPv4 address and network mask for the specified IP interface. To configure IPv6 interface address, application shall use the service <strong><em>nxd_ipv6_address_set</em></strong>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>The specified interface must be previously attached to the IP instance</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_41">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the interface attached to the NetX Duo instance.</p>
</li>
<li>
<p><em>ip_address</em>: New network interface IP address.</p>
</li>
<li>
<p><em>network_mask</em>: New interface network mask.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_41">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP address set.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Specified network interface is invalid.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointers.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP address</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_41">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_41">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_41">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define INTERFACE_INDEX 1

/* Set device IP address and network mask for the specified
   interface index 1 in IP instance list of interfaces). */
status = nx_ip_interface_address_set(ip_ptr, INTERFACE_INDEX,
                                     ip_address,
                                     network_mask);

/* If status is NX_SUCCESS the interface IP address and mask was
   successfully set. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_41">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_get</p>
</li>
<li>
<p>nx_ip_interface_address_mapping_configure</p>
</li>
<li>
<p>nx_ip_interface_attach</p>
</li>
<li>
<p>nx_ip_interface_capability_get</p>
</li>
<li>
<p>nx_ip_interface_capability_set</p>
</li>
<li>
<p>nx_ip_interface_detach</p>
</li>
<li>
<p>nx_ip_interface_info_get</p>
</li>
<li>
<p>nx_ip_interface_mtu_set</p>
</li>
<li>
<p>nx_ip_interface_physical_address_get</p>
</li>
<li>
<p>nx_ip_interface_physical_address_set</p>
</li>
<li>
<p>nx_ip_interface_status_check</p>
</li>
<li>
<p>nx_ip_link_status_change_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_interface_attach">nx_ip_interface_attach</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Attach network interface to IP instance</p>
</div>
<div class="sect2">
<h3 id="_prototype_42">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_interface_attach(
    NX_IP *ip_ptr,
    CHAR *interface_name,
    ULONG ip_address,
    ULONG network_mask,
    VOID(*ip_link_driver)(struct NX_IP_DRIVER_STRUCT *));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_42">Description</h3>
<div class="paragraph">
<p>This service adds a physical network interface to the IP interface. Note the IP instance is created with the primary interface so each additional interface is secondary to the primary interface. The total number of network interfaces attached to the IP instance (including the primary interface) cannot exceed <strong>NX_MAX_PHYSICAL_INTERFACES</strong>.</p>
</div>
<div class="paragraph">
<p>If the IP thread has not been running yet, the secondary interfaces will be initialized as part of the IP thread startup process that initializes all physical interfaces.</p>
</div>
<div class="paragraph">
<p>If the IP thread is not running yet, the secondary interface is initialized as part of the <strong><em>nx_ip_interface_attach</em></strong> service.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>ip_ptr must point to a valid NetX Duo IP structure. <strong>NX_MAX_PHYSICAL_INTERFACES</strong> must be configured for the number of network interfaces for the IP instance. The default value is one</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_42">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_name</em>: Pointer to interface name string.</p>
</li>
<li>
<p><em>ip_address</em>: Device IP address in host byte order.</p>
</li>
<li>
<p><em>network_mask</em>: Device network mask in host byte order.</p>
</li>
<li>
<p><em>ip_link_driver</em>: Ethernet driver for the interface.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_42">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Entry is added to static routing table.</p>
</li>
<li>
<p><strong>NX_NO_MORE_ENTRIES</strong> (0x17) Max number of interfaces. NX_MAX_PHYSICAL_INTERFACES is exceeded. If IPv6 is enabled, this error may also indicate that the driver may not have enough resource to handle IPv6 multicast operations.</p>
</li>
<li>
<p><strong>NX_DUPLICATED_ENTRY</strong> (0x52) The supplied IP address is already used on this IP instance.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointer input.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP address input.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_42">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_42">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_42">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Attach secondary device for device IP address 192.168.1.68 with
   the specified Ethernet driver. */
status = nx_ip_interface_attach(ip_ptr, "secondary_port",
                                IP_ADDRESS(192,168,1,68),
                                0xFFFFFF00UL,
                                nx_etherDriver);

/* If status is NX_SUCCESS the interface was successfully added to
   the IP instance interface table. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_42">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_get</p>
</li>
<li>
<p>nx_ip_interface_address_mapping_configure</p>
</li>
<li>
<p>nx_ip_interface_address_set</p>
</li>
<li>
<p>nx_ip_interface_capability_get</p>
</li>
<li>
<p>nx_ip_interface_capability_set</p>
</li>
<li>
<p>nx_ip_interface_detach</p>
</li>
<li>
<p>nx_ip_interface_info_get</p>
</li>
<li>
<p>nx_ip_interface_mtu_set</p>
</li>
<li>
<p>nx_ip_interface_physical_address_get</p>
</li>
<li>
<p>nx_ip_interface_physical_address_set</p>
</li>
<li>
<p>nx_ip_interface_status_check</p>
</li>
<li>
<p>nx_ip_link_status_change_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_interface_capability_get">nx_ip_interface_capability_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Get interface hardware capability</p>
</div>
<div class="sect2">
<h3 id="_prototype_43">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_interface_capability_get(
    NX_IP *ip_ptr,
    UINT interface_index,
    ULONG *interface_capability_flag);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_43">Description</h3>
<div class="paragraph">
<p>This service retrieves the capability flag from the specified network interface. To use this service, the NetX Duo library must be built with the option <strong><em>NX_ENABLE_INTERFACE_CAPABILITY</em></strong> enabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_43">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface</p>
</li>
<li>
<p><em>interface_capability_flag</em>: Pointer to memory space for the capability flag</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_43">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully obtained interface capability information.</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) Interface capability feature is not supported in this build.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface index is not valid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer or Invalid capability flag pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Service is not called from system initialization or thread context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_43">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_43">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_43">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PRIMARY_INTERFACE 0
ULONG       capability_flag;

/* Get the hardware capability flag of specified interface. */
status = nx_ip_interface_capability_get(&amp;ip_0,
                                        PRIMARY_INTERFACE,
                                        &amp;capability_flag);

/* If status == NX_SUCCESS, the capability flag from the primary
   interface was successfully retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_43">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_get</p>
</li>
<li>
<p>nx_ip_interface_address_mapping_configure</p>
</li>
<li>
<p>nx_ip_interface_address_set</p>
</li>
<li>
<p>nx_ip_interface_attach</p>
</li>
<li>
<p>nx_ip_interface_capability_set</p>
</li>
<li>
<p>nx_ip_interface_detach</p>
</li>
<li>
<p>nx_ip_interface_info_get</p>
</li>
<li>
<p>nx_ip_interface_mtu_set</p>
</li>
<li>
<p>nx_ip_interface_physical_address_get</p>
</li>
<li>
<p>nx_ip_interface_physical_address_set</p>
</li>
<li>
<p>nx_ip_interface_status_check</p>
</li>
<li>
<p>nx_ip_link_status_change_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_interface_capability_set">nx_ip_interface_capability_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set the hardware capability flag</p>
</div>
<div class="sect2">
<h3 id="_prototype_44">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_interface_capability_set(
    NX_IP *ip_ptr,
    UINT interface_index,
    ULONG interface_capability_flag);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_44">Description</h3>
<div class="paragraph">
<p>This service is used by the network device driver to configure the capability flag for a specified network interface. To use this service, the NetX Duo library must be compiled with the option <strong><em>NX_ENABLE_INTERFACE_CAPABILITY</em></strong> defined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_44">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>interface_index</em>: Index of network interface</p>
</li>
<li>
<p><em>interface_capability_flag</em>: Capability flag for output</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_44">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully set interface hardware capability flag.</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) Interface capability feature is not supported in this build.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface index is not valid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Service is not called from system initialization or thread context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_44">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_44">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_44">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PRIMARY_INTERFACE 0
ULONG capability_flag = \
                 NX_INTERFACE_CAPABILITY_IPV4_TX_CHECKSUM |\
                 NX_INTERFACE_CAPABILITY_IPV4_RX_CHECKSUM;
UINT device_index = 0;

/* Set the hardware capability flag of specified interface. */
status = nx_ip_interface_capability_set(&amp;ip_0,
                                        PRIMARY_INTERFACE,
                                        capability_flag);

/* If status == NX_SUCCESS, the hardware capability flag was
   successfully set. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_44">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_get</p>
</li>
<li>
<p>nx_ip_interface_address_mapping_configure</p>
</li>
<li>
<p>nx_ip_interface_address_set</p>
</li>
<li>
<p>nx_ip_interface_attach</p>
</li>
<li>
<p>nx_ip_interface_capability_get</p>
</li>
<li>
<p>nx_ip_interface_detach</p>
</li>
<li>
<p>nx_ip_interface_info_get</p>
</li>
<li>
<p>nx_ip_interface_mtu_set</p>
</li>
<li>
<p>nx_ip_interface_physical_address_get</p>
</li>
<li>
<p>nx_ip_interface_physical_address_set</p>
</li>
<li>
<p>nx_ip_interface_status_check</p>
</li>
<li>
<p>nx_ip_link_status_change_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_interface_detach">nx_ip_interface_detach</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Detach the specified interface from the IP instance</p>
</div>
<div class="sect2">
<h3 id="_prototype_45">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_interface_address_set(
    NX_IP *ip_ptr,
    UINT index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_45">Description</h3>
<div class="paragraph">
<p>This service detaches the specified IP interface from the IP instance. Once an interface is detached, all connected TCP sockets closed, and ND cache and ARP entries for this interface are removed from their
respective tables. IGMP memberships for this interface are removed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_45">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>index</em>: Index of the interface to be removed.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_45">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully removed a physical interface.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Specified network interface is invalid.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointers.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_45">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_45">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_45">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define INTERFACE_INDEX 1

/* Detach interface 1. */
status = nx_ip_interface_detach(&amp;IP_0, INTERFACE_INDEX);

/* If status is NX_SUCCESS the interface is successfully detached
   from the IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_45">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_get</p>
</li>
<li>
<p>nx_ip_interface_address_mapping_configure</p>
</li>
<li>
<p>nx_ip_interface_address_set</p>
</li>
<li>
<p>nx_ip_interface_attach</p>
</li>
<li>
<p>nx_ip_interface_capability_get</p>
</li>
<li>
<p>nx_ip_interface_capability_set</p>
</li>
<li>
<p>nx_ip_interface_info_get</p>
</li>
<li>
<p>nx_ip_interface_mtu_set</p>
</li>
<li>
<p>nx_ip_interface_physical_address_get</p>
</li>
<li>
<p>nx_ip_interface_physical_address_set</p>
</li>
<li>
<p>nx_ip_interface_status_check</p>
</li>
<li>
<p>nx_ip_link_status_change_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_interface_info_get">nx_ip_interface_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve network interface parameters</p>
</div>
<div class="sect2">
<h3 id="_prototype_46">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_interface_info_get(
    NX_IP *ip_ptr,
    UINT interface_index,
    CHAR **interface_name,
    ULONG *ip_address,
    ULONG *network_mask,
    ULONG *mtu_size,
    ULONG *physical_address_msw,
    ULONG *physical_address_lsw);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_46">Description</h3>
<div class="paragraph">
<p>This service retrieves information on network parameters for the specified network interface. All data are retrieved in host byte order.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>ip_ptr must point to a valid NetX Duo IP structure. The specified interface, if not the primary interface, must be previously attached to the IP instance</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_46">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Index specifying network interface.</p>
</li>
<li>
<p><em>interface_name</em>: Pointer to the buffer that holds the name of the network interface.</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to the destination for the IP address of the interface.</p>
</li>
<li>
<p><em>network_mask</em>: Pointer to destination for network mask.</p>
</li>
<li>
<p><em>mtu_size</em>: Pointer to destination for maximum transfer unit for this interface.</p>
</li>
<li>
<p><em>physical_address_msw</em>: Pointer to destination for top 16 bits of the device MAC address.</p>
</li>
<li>
<p><em>physical_address_lsw</em>: Pointer to destination for lower 32 bits of the device MAC address.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_46">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Interface information has been obtained.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointer input.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Service is not called from system initialization or thread context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_46">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_46">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_46">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Retrieve interface parameters for the specified interface (index
   1 in IP instance list of interfaces). */
#define INTERFACE_INDEX 1
status = nx_ip_interface_info_get(ip_ptr, INTERFACE_INDEX,
                                  &amp;name_ptr, &amp;ip_address,
                                  &amp;network_mask,
                                  &amp;mtu_size,
                                  &amp;physical_address_msw,
                                  &amp;physical_address_lsw);

/* If status is NX_SUCCESS the interface information is
   successfully retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_46">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_get</p>
</li>
<li>
<p>nx_ip_interface_address_mapping_configure</p>
</li>
<li>
<p>nx_ip_interface_address_set</p>
</li>
<li>
<p>nx_ip_interface_attach</p>
</li>
<li>
<p>nx_ip_interface_capability_get</p>
</li>
<li>
<p>nx_ip_interface_capability_set</p>
</li>
<li>
<p>nx_ip_interface_detach</p>
</li>
<li>
<p>nx_ip_interface_mtu_set</p>
</li>
<li>
<p>nx_ip_interface_physical_address_get</p>
</li>
<li>
<p>nx_ip_interface_physical_address_set</p>
</li>
<li>
<p>nx_ip_interface_status_check</p>
</li>
<li>
<p>nx_ip_link_status_change_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_interface_mtu_set">nx_ip_interface_mtu_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set the MTU value of a network interface</p>
</div>
<div class="sect2">
<h3 id="_prototype_47">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_interface_mtu_set(
    NX_IP *ip_ptr,
    UINT interface_index,
    ULONG mtu_size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_47">Description</h3>
<div class="paragraph">
<p>This service is used by the device driver to configure the IP MTU value for the specified network interface.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_47">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>interface_index</em>: Index to the network interface</p>
</li>
<li>
<p><em>mtu_size</em>: IP MTU size</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_47">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully set MTU value</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface index is not valid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Service is not called from system initialization or thread context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_47">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_47">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_47">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PRIMARY_INTERFACE 0
ULONG       mtu_size = 1500;

/* Set the MTU size of specified interface. */
status = nx_ip_interface_mtu_set(&amp;ip_0,
                                 PRIMARY_INTERFACE, mtu_size);

/* If status == NX_SUCCESS, the MTU size was successfully set. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_47">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_get</p>
</li>
<li>
<p>nx_ip_interface_address_mapping_configure</p>
</li>
<li>
<p>nx_ip_interface_address_set</p>
</li>
<li>
<p>nx_ip_interface_attach</p>
</li>
<li>
<p>nx_ip_interface_capability_get</p>
</li>
<li>
<p>nx_ip_interface_capability_set</p>
</li>
<li>
<p>nx_ip_interface_detach</p>
</li>
<li>
<p>nx_ip_interface_info_get</p>
</li>
<li>
<p>nx_ip_interface_physical_address_get</p>
</li>
<li>
<p>nx_ip_interface_physical_address_set</p>
</li>
<li>
<p>nx_ip_interface_status_check</p>
</li>
<li>
<p>nx_ip_link_status_change_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_interface_physical_address_get">nx_ip_interface_physical_address_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Get the physical address of a network device</p>
</div>
<div class="sect2">
<h3 id="_prototype_48">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_interface_physical_address_get(
    NX_IP *ip_ptr,
    UINT interface_index,
    ULONG *physical_msw,
    ULONG *physical_lsw);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_48">Description</h3>
<div class="paragraph">
<p>This service retrieves the physical address of a network interface from the IP instance.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_48">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface</p>
</li>
<li>
<p><em>physical_msw</em>: Pointer to destination for top 16 bits of the device MAC address</p>
</li>
<li>
<p><em>physical_lsw</em>: Pointer to destination for lower 32 bits of the device MAC address</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_48">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful get</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface index is not valid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer or physical address pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Service is not called from system initialization or thread context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_48">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_48">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_48">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PRIMARY_INTERFACE 0
ULONG   physical_msw;
ULONG   physical_lsw;

/* Get the physical address of specified interface. */
status = nx_ip_interface_physical_address_get(&amp;ip_0,
                                              PRIMARY_INTERFACE,
                                              &amp;physical_msw,
                                              &amp;physical_lsw);

/* If status == NX_SUCCESS, the physical address was successfully
   retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_48">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_get</p>
</li>
<li>
<p>nx_ip_interface_address_mapping_configure</p>
</li>
<li>
<p>nx_ip_interface_address_set</p>
</li>
<li>
<p>nx_ip_interface_attach</p>
</li>
<li>
<p>nx_ip_interface_capability_get</p>
</li>
<li>
<p>nx_ip_interface_capability_set</p>
</li>
<li>
<p>nx_ip_interface_detach</p>
</li>
<li>
<p>nx_ip_interface_info_get</p>
</li>
<li>
<p>nx_ip_interface_mtu_set</p>
</li>
<li>
<p>nx_ip_interface_physical_address_set</p>
</li>
<li>
<p>nx_ip_interface_status_check</p>
</li>
<li>
<p>nx_ip_link_status_change_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_interface_physical_address_set">nx_ip_interface_physical_address_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set the physical address for a specified network interface</p>
</div>
<div class="sect2">
<h3 id="_prototype_49">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_interface_physical_address_set(
    NX_IP *ip_ptr,
    UINT interface_index,
    ULONG physical_msw,
    ULONG physical_lsw,
    UINT update_driver);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_49">Description</h3>
<div class="paragraph">
<p>This service is used by the application or a device driver to configure the physical address of the MAC address of the specified network interface. The new MAC address is applied to the control block of the interface structure. If the <strong><em>update_driver</em></strong> flag is set, a driver-level command is issued so the device driver is able to update its MAC address programmed into the Ethernet controller.</p>
</div>
<div class="paragraph">
<p>In a typical situation, this service is called from the interface device driver during initialization phase to notify the IP stack of its MAC address. In this case, the <strong><em>update_driver</em></strong> flag should not be set.</p>
</div>
<div class="paragraph">
<p>This routine can also be called from user application to reconfigure the interface MAC address at run time. In this use case, the <strong><em>update_driver</em></strong> flag should be set, so the new MAC address can be applied to the device driver.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_49">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>interface_index</em>: Index to the network interface</p>
</li>
<li>
<p><em>physical_msw</em>: Pointer to destination for top 16 bits of the device MAC address</p>
</li>
<li>
<p><em>physical_lsw</em>: Pointer to destination for lower 32 bits of the device MAC address</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_49">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful set</p>
</li>
<li>
<p><strong>NX_UNHANDLED_COMMAND</strong> (0x4B) Command not recognized by the driver</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface index is not valid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Service is not called from system initialization or thread context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_49">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_49">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_49">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PRIMARY_INTERFACE 0
ULONG       physical_msw = 0x00CF;
ULONG       physical_lsw = 0x01020304;

/* Set the physical address of specified device. */
status = nx_ip_interface_physical_address_set(&amp;ip_0,
                                              PRIMARY_INTERFACE,
                                              physical_msw,
                                              physical_lsw,
                                              NX_TRUE);

/* If status == NX_SUCCESS, the physical address was successfully
   set. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_49">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_get</p>
</li>
<li>
<p>nx_ip_interface_address_mapping_configure</p>
</li>
<li>
<p>nx_ip_interface_address_set</p>
</li>
<li>
<p>nx_ip_interface_attach</p>
</li>
<li>
<p>nx_ip_interface_capability_get</p>
</li>
<li>
<p>nx_ip_interface_capability_set</p>
</li>
<li>
<p>nx_ip_interface_detach</p>
</li>
<li>
<p>nx_ip_interface_info_get</p>
</li>
<li>
<p>nx_ip_interface_mtu_set</p>
</li>
<li>
<p>nx_ip_interface_physical_address_get</p>
</li>
<li>
<p>nx_ip_interface_status_check</p>
</li>
<li>
<p>nx_ip_link_status_change_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_interface_status_check">nx_ip_interface_status_check</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Check status of an IP instance</p>
</div>
<div class="sect2">
<h3 id="_prototype_50">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_interface_status_check(
    NX_IP *ip_ptr,
    UINT interface_index
    ULONG needed_status,
    ULONG *actual_status,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_50">Description</h3>
<div class="paragraph">
<p>This service checks and optionally waits for the specified status of the network interface of a previously created IP instance.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_50">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Interface index number needed_status IP status requested, defined in bit-map form as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_IP_INITIALIZE_DONE</strong>* (0x0001)</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_RESOLVED</strong>* (0x0002)</p>
</li>
<li>
<p><strong>NX_IP_LINK_ENABLED</strong> (0x0004)</p>
</li>
<li>
<p><strong>NX_IP_ARP_ENABLED</strong> (0x0008)</p>
</li>
<li>
<p><strong>NX_IP_UDP_ENABLED</strong> (0x0010)</p>
</li>
<li>
<p><strong>NX_IP_TCP_ENABLED</strong> (0x0020)</p>
</li>
<li>
<p><strong>NX_IP_IGMP_ENABLED</strong> (0x0040)</p>
</li>
<li>
<p><strong>NX_IP_RARP_COMPLETE</strong> (0x0080)</p>
</li>
<li>
<p><strong>NX_IP_INTERFACE_LINK_ENABLED</strong> (0x0100)</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>actual_status</em>: Pointer to destination of actual bits set. wait_option Defines how the service behaves if the requested status bits are not available. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>timeout value</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> 0xFFFFFFFF</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_50">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP status check.</p>
</li>
<li>
<p><strong>NX_NOT_SUCCESSFUL</strong> (0x43) Status request was not satisfied within the timeout specified.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) IP pointer is or has become invalid, or actual status pointer is invalid.</p>
</li>
<li>
<p><strong>NX_OPTION_ERROR</strong> (0x0a) Invalid needed status option.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface_index is out of range. or the interface is not valid.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_50">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_50">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_50">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Wait 10 ticks for the link up status on the previously created IP
   instance. */
status = nx_ip_interface_status_check(&amp;ip_0, 1, NX_IP_LINK_ENABLED,
                                      &amp;actual_status, 10);

/* If status is NX_SUCCESS, the secondary link for the specified IP
   instance is up. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_50">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_get</p>
</li>
<li>
<p>nx_ip_interface_address_mapping_configure</p>
</li>
<li>
<p>nx_ip_interface_address_set</p>
</li>
<li>
<p>nx_ip_interface_attach</p>
</li>
<li>
<p>nx_ip_interface_capability_get</p>
</li>
<li>
<p>nx_ip_interface_capability_set</p>
</li>
<li>
<p>nx_ip_interface_detach</p>
</li>
<li>
<p>nx_ip_interface_info_get</p>
</li>
<li>
<p>nx_ip_interface_mtu_set</p>
</li>
<li>
<p>nx_ip_interface_physical_address_get</p>
</li>
<li>
<p>nx_ip_interface_physical_address_set</p>
</li>
<li>
<p>nx_ip_link_status_change_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_link_status_change_notify_set">nx_ip_link_status_change_notify_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set the link status change notify callback function</p>
</div>
<div class="sect2">
<h3 id="_prototype_51">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_link_status_change_notify_set(
    NX_IP *ip_ptr,
    VOID(*link_status_change_notify)(NX_IP *ip_ptr, UINT interface_index, UINT link_up));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_51">Description</h3>
<div class="paragraph">
<p>This service configures the link status change notify callback function. The user-supplied <em>link_status_change_notify</em> routine is invoked when either the primary or secondary interface status is changed (such as IP address is changed.) If <em>link_status_change_notify</em> is NULL, the link status change notify callback feature is disabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_51">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>link_status_change_notify</em>: User-supplied callback function to be called upon a change to the physical interface.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_51">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful set</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer or new physical address pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Service is not called from system initialization or thread context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_51">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_51">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_51">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Configure a callback function to be used when the physical
   interface status is changed. */
status = nx_ip_link_status_change_notify_set(&amp;ip_0,
                                             my_change_cb);

/* If status == NX_SUCCESS, the link status change notify function
   is set. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_51">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_interface_address_get</p>
</li>
<li>
<p>nx_ip_interface_address_mapping_configure</p>
</li>
<li>
<p>nx_ip_interface_address_set</p>
</li>
<li>
<p>nx_ip_interface_attach</p>
</li>
<li>
<p>nx_ip_interface_capability_get</p>
</li>
<li>
<p>nx_ip_interface_capability_set</p>
</li>
<li>
<p>nx_ip_interface_detach</p>
</li>
<li>
<p>nx_ip_interface_info_get</p>
</li>
<li>
<p>nx_ip_interface_mtu_set</p>
</li>
<li>
<p>nx_ip_interface_physical_address_get</p>
</li>
<li>
<p>nx_ip_interface_physical_address_set</p>
</li>
<li>
<p>nx_ip_interface_status_check</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_max_payload_size_find">nx_ip_max_payload_size_find</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Compute maximum packet data payload</p>
</div>
<div class="sect2">
<h3 id="_prototype_52">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_max_payload_size_find(
    NX_IP *ip_ptr,
    NXD_ADDRESS *dest_address,
    UINT if_index,
    UINT src_port,
    UINT dest_port,
    ULONG protocol,
    ULONG *start_offset_ptr,
    ULONG *payload_length_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_52">Description</h3>
<div class="paragraph">
<p>This service finds the maximum application payload size that will not require IP fragmentation to reach the destination; e.g., payload is at or below the local interface MTU size. (or the Path MTU value obtained via IPv6 Path MTU discovery). IP header and upper application header size (TCP or UDP) are subtracted from the total payload. If NetX Duo IPsec Security Policy applies to this end-point, the IPsec headers (ESP/AH) and associated overhead, such as Initial Vector, are also subtracted from the MTU. This service is applicable for both IPv4 and IPv6 packets.</p>
</div>
<div class="paragraph">
<p>The parameter <em>if_index</em> specifies the interface to use for sending out the packet. For a multihome system, the caller needs to specify the <em>if_index</em> parameter if the destination is a broadcast (IPv4 only), multicast, or IPv6 link-local address.</p>
</div>
<div class="paragraph">
<p>This service returns two values to the caller:</p>
</div>
<div class="paragraph">
<p>1) start_offset_ptr: This is the location after the TCP/UDP/IP/IPsec headers;
2) payload_length_ptr: the amount of data application may transfer without exceeding MTU.</p>
</div>
<div class="paragraph">
<p>There is no equivalent NetX service.</p>
</div>
</div>
<div class="sect2">
<h3 id="_restrictions">Restrictions</h3>
<div class="paragraph">
<p>The IP instance must be previously created.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_52">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to IP instance</p>
</li>
<li>
<p><em>dest_address</em>: Pointer to packet destination address</p>
</li>
<li>
<p><em>if_index</em>: Indicates the index of the interface to use</p>
</li>
<li>
<p><em>src_port</em>: Source port number</p>
</li>
<li>
<p><em>dest_port</em>: Destination port number</p>
</li>
<li>
<p><em>protocol</em>: Upper layer protocol to be used</p>
</li>
<li>
<p><em>start_offset_ptr</em>: Pointer to the start of data for maximum packet payload</p>
</li>
<li>
<p><em>payload_length_ptr</em>: Pointer to payload size excluding headers</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_52">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Payload successfully computed</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface index is invalid, or the interface is not valid.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP address.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer, or invalid destination address</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid address supplied</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) Invalid protocol (not UDP or TCP)</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Service is not called from system initialization or thread context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_52">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_52">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_52">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* The following example determines the maximum payload for UDP
   packet to remote host. */
#define PRIMARY_INTERFACE 0
status = nx_ip_max_payload_size_find(&amp;ip_0,
                                     &amp;dest_ipv6_address,
                                     PRIMARY_INTERFACE,
                                     source_port,
                                     dest_port, NX_PROTOCOL_UDP,
                                     &amp;start_offset,
                                     &amp;payload_length);

/* A return value of NX_SUCCESS indicates the packet payload
   payload_length starting at the offset start_offset is
   successfully computed. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_52">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_raw_packet_disable">nx_ip_raw_packet_disable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Disable raw packet sending/receiving</p>
</div>
<div class="sect2">
<h3 id="_prototype_53">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_raw_packet_disable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_53">Description</h3>
<div class="paragraph">
<p>This service disables transmission and reception of raw IP packets for this IP instance. If the raw packet service was previously enabled, and there are raw packets in the receive queue, this service will release any received raw packets.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_53">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_53">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP raw packet disable.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_53">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_53">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_53">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Disable raw packet sending/receiving for this IP instance. */
status = nx_ip_raw_packet_disable(&amp;ip_0);
/* If status is NX_SUCCESS, raw IP packet sending/receiving has
   been disabled for the previously created IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_53">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_raw_packet_enable</p>
</li>
<li>
<p>nx_ip_raw_packet_filter_set</p>
</li>
<li>
<p>nx_ip_raw_packet_receive</p>
</li>
<li>
<p>nx_ip_raw_packet_send</p>
</li>
<li>
<p>nx_ip_raw_packet_source_send</p>
</li>
<li>
<p>nx_ip_raw_receive_queue_max_set</p>
</li>
<li>
<p>nxd_ip_raw_packet_send</p>
</li>
<li>
<p>nxd_ip_raw_packet_source_send</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_raw_packet_enable">nx_ip_raw_packet_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable raw packet processing</p>
</div>
<div class="sect2">
<h3 id="_prototype_54">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_raw_packet_enable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_54">Description</h3>
<div class="paragraph">
<p>This service enables transmission and reception of raw IP packets for this IP instance. Incoming TCP, UDP, ICMP, and IGMP packets are still processed by NetX Duo. Packets with unknown upper layer protocol types are processed by raw packet reception routine.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_54">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_54">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP raw packet enable.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_54">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_54">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_54">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Enable raw packet sending/receiving for this IP instance. */
status = nx_ip_raw_packet_enable(&amp;ip_0);

/* If status is NX_SUCCESS, raw IP packet sending/receiving has
   been enabled for the previously created IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_54">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_raw_packet_disable</p>
</li>
<li>
<p>nx_ip_raw_packet_filter_set</p>
</li>
<li>
<p>nx_ip_raw_packet_receive</p>
</li>
<li>
<p>nx_ip_raw_packet_send</p>
</li>
<li>
<p>nx_ip_raw_packet_source_send</p>
</li>
<li>
<p>nx_ip_raw_receive_queue_max_set</p>
</li>
<li>
<p>nxd_ip_raw_packet_send</p>
</li>
<li>
<p>nxd_ip_raw_packet_source_send</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_raw_packet_filter_set">nx_ip_raw_packet_filter_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set raw IP packet filter</p>
</div>
<div class="sect2">
<h3 id="_prototype_55">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_raw_packet_filter_set(
    NX_IP *ip_ptr,
    UINT (*raw_packet_filter)(NX_IP *, ULONG, NX_PACKET *));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_55">Description</h3>
<div class="paragraph">
<p>This service configures the IP raw packet filter. The raw packet filter function, implemented by user application, allows an application to receive raw packets based on user-supplied criteria. Note that NetX Duo BSD wrapper layer uses the raw packet filter feature to handle raw socket in the BSD layer. To use this service, the NetX Duo library must be built with the option <strong><em>NX_ENABLE_IP_RAW_PACKET_FILTER</em></strong> defined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_55">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>raw_packet_filter</em>: Function pointer of the raw packet filter</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_55">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully set the raw packet filter routine</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORT</strong> (0x4B) Raw packet support is not available</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_55">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_55">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_55">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT raw_packet_filter(NX_IP *ip_ptr, ULONG protocol,
                       NX_PACKET *packet_ptr)
{

/* Simply filter protocol. */
if(protocol == NX_IP_RAW)
   return NX_SUCCESS;
else
   return NX_NOT_SUCCESSFUL;
}

void raw_packet_thread_entry(ULONG id)
{

/* Set the raw packet filter of IP instance. */
status = nx_ip_raw_packet_filter_set(&amp;ip_0,
                                     raw_packet_filter);

/* If status == NX_SUCCESS, the raw packet filter of IP instance
   was successfully set. */
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_55">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_raw_packet_disable</p>
</li>
<li>
<p>nx_ip_raw_packet_enable</p>
</li>
<li>
<p>nx_ip_raw_packet_receive</p>
</li>
<li>
<p>nx_ip_raw_packet_send</p>
</li>
<li>
<p>nx_ip_raw_packet_source_send</p>
</li>
<li>
<p>nx_ip_raw_receive_queue_max_set</p>
</li>
<li>
<p>nxd_ip_raw_packet_send</p>
</li>
<li>
<p>nxd_ip_raw_packet_source_send</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_raw_packet_receive">nx_ip_raw_packet_receive</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Receive raw IP packet</p>
</div>
<div class="sect2">
<h3 id="_prototype_56">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_raw_packet_receive(
    NX_IP *ip_ptr,
    NX_PACKET **packet_ptr,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_56">Description</h3>
<div class="paragraph">
<p>This service receives a raw IP packet from the specified IP instance. If there are IP packets on the raw packet receive queue, the first (oldest) packet is returned to the caller. Otherwise, if no packets are available, the caller may suspend as specified by the wait option.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<em>If NX_SUCCESS, is returned, the application is responsible for releasing the received packet when it is no longer needed</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_56">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>packet_ptr</em>: Pointer to pointer to place the received raw IP packet in.</p>
</li>
<li>
<p><em>wait_option</em>: Defines how the service behaves if packets are not available. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_56">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP raw packet receive.</p>
</li>
<li>
<p><strong>NX_NO_PACKET</strong> (0x01) No packet was available.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or return packet pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_56">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_56">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_56">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Receive a raw IP packet for this IP instance, wait for a maximum
   of 4 timer ticks. */
status = nx_ip_raw_packet_receive(&amp;ip_0, &amp;packet_ptr, 4);

/* If status is NX_SUCCESS, the raw IP packet pointer is in the
   variable packet_ptr. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_56">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_raw_packet_disable</p>
</li>
<li>
<p>nx_ip_raw_packet_enable</p>
</li>
<li>
<p>nx_ip_raw_packet_filter_set</p>
</li>
<li>
<p>nx_ip_raw_packet_send</p>
</li>
<li>
<p>nx_ip_raw_packet_source_send</p>
</li>
<li>
<p>nx_ip_raw_receive_queue_max_set</p>
</li>
<li>
<p>nxd_ip_raw_packet_send</p>
</li>
<li>
<p>nxd_ip_raw_packet_source_send</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_raw_packet_send">nx_ip_raw_packet_send</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send raw IP packet</p>
</div>
<div class="sect2">
<h3 id="_prototype_57">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_raw_packet_send(
    NX_IP *ip_ptr,
    NX_PACKET *packet_ptr,
    ULONG destination_ip,
    ULONG type_of_service);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_57">Description</h3>
<div class="paragraph">
<p>This service sends a raw IPv4 packet to the destination IP address. Note that this routine returns immediately, and it is therefore not known whether the IP packet has actually been sent. The network driver will be responsible for releasing the packet when the transmission is complete.</p>
</div>
<div class="paragraph">
<p>For a multihome system, NetX Duo uses the destination IP address to find an appropriate network interface and uses the IP address of the interface as the source address. If the destination IP address is broadcast or multicast, the first valid interface is used. Applications use the <strong><em>nx_ip_raw_packet_source_send</em></strong> in this case.</p>
</div>
<div class="paragraph">
<p>To send a raw IPv6 packet, application shall use the service <strong><em>nxd_ip_raw_packet_send,</em></strong> or <strong><em>nxd_ip_raw_packet_source_send.</em></strong></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Unless an error is returned, the application should not release the packet after this call. Doing so will cause unpredictable results because the network driver will release the packet after transmission</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_57">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>packet_ptr</em>: Pointer to the raw IP packet to send.</p>
</li>
<li>
<p><em>destination_ip</em>: Destination IP address, which can be a specific host IP address, a network broadcast, an internal loop-back, or a multicast address.</p>
</li>
<li>
<p><em>type_of_service</em>: Defines the type of service for the transmission, legal values are as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_IP_NORMAL</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_IP_MIN_DELAY</strong> (0x00100000)</p>
</li>
<li>
<p><strong>NX_IP_MAX_DATA</strong> (0x00080000)</p>
</li>
<li>
<p><strong>NX_IP_MAX_RELIABLE</strong> (0x00040000)</p>
</li>
<li>
<p><strong>NX_IP_MIN_COST</strong> (0x00020000)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_57">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP raw packet send initiated.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP address.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) Raw IP feature is not enabled.</p>
</li>
<li>
<p><strong>NX_OPTION_ERROR</strong> (0x0A) Invalid type of service.</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Not enough room to prepend an IP header on the packet.</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Packet append pointer is invalid.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or packet pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_57">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_57">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_57">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Send a raw IP packet to IP address 1.2.3.5. */
status = nx_ip_raw_packet_send(&amp;ip_0, packet_ptr,
                               IP_ADDRESS(1,2,3,5),
                               NX_IP_NORMAL);

/* If status is NX_SUCCESS, the raw IP packet pointed to by
   packet_ptr has been sent. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_57">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_raw_packet_disable</p>
</li>
<li>
<p>nx_ip_raw_packet_enable</p>
</li>
<li>
<p>nx_ip_raw_packet_filter_set</p>
</li>
<li>
<p>nx_ip_raw_packet_receive</p>
</li>
<li>
<p>nx_ip_raw_packet_send</p>
</li>
<li>
<p>nx_ip_raw_packet_source_send</p>
</li>
<li>
<p>nx_ip_raw_receive_queue_max_set</p>
</li>
<li>
<p>nxd_ip_raw_packet_send</p>
</li>
<li>
<p>nxd_ip_raw_packet_source_send</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_raw_packet_source_send">nx_ip_raw_packet_source_send</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send raw IP packet through specified network interface</p>
</div>
<div class="sect2">
<h3 id="_prototype_58">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_raw_packet_source_send(
    NX_IP *ip_ptr,
    NX_PACKET *packet_ptr,
    ULONG destination_ip,
    UINT address_index,
    ULONG type_of_service);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_58">Description</h3>
<div class="paragraph">
<p>This service sends a raw IP packet to the destination IP address using the specified local IPv4 address as the source address, and through the associated network interface. Note that this routine returns immediately, and it is, therefore, not known if the IP packet has actually been sent. The network driver will be responsible for releasing the packet when the transmission is complete. This service differs from other services in that there is no way of knowing if the packet was actually sent. It could get lost on the Internet.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<em>Note that raw IP processing must be enabled</em>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>This service is similar to <strong>nx_ip_raw_packet_send,</strong> except that this service allows an application to send raw IPv4 packet from a specified physical interfaces</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_58">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP task.</p>
</li>
<li>
<p><em>packet_ptr</em>: Pointer to packet to transmit.</p>
</li>
<li>
<p><em>destination_ip</em>: IP address to send packet.</p>
</li>
<li>
<p><em>address_index</em>: Index of the address of the interface to send packet out on.</p>
</li>
<li>
<p><em>type_of_service</em>: Type of service for packet.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_58">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Packet successfully transmitted.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) No suitable outgoing interface available.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) Raw IP packet processing not enabled.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointer input.</p>
</li>
<li>
<p><strong>NX_OPTION_ERROR</strong> (0x0A) Invalid type of service specified.</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Invalid packet prepend pointer.</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Invalid packet prepend pointer.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid interface index specified.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_58">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_58">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_58">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define ADDRESS_IDNEX 1

/* Send packet out on interface 1 with normal type of service. */
status = nx_ip_raw_packet_source_send(ip_ptr, packet_ptr,
                                      destination_ip,
                                      ADDRESS_INDEX,
                                      NX_IP_NORMAL);

/* If status is NX_SUCCESS the packet was successfully
   transmitted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_58">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_raw_packet_disable</p>
</li>
<li>
<p>nx_ip_raw_packet_enable</p>
</li>
<li>
<p>nx_ip_raw_packet_filter_set</p>
</li>
<li>
<p>nx_ip_raw_packet_receive</p>
</li>
<li>
<p>nx_ip_raw_packet_send</p>
</li>
<li>
<p>nx_ip_raw_receive_queue_max_set</p>
</li>
<li>
<p>nxd_ip_raw_packet_send</p>
</li>
<li>
<p>nxd_ip_raw_packet_source_send</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_raw_receive_queue_max_set">nx_ip_raw_receive_queue_max_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set maximum raw receive queue size</p>
</div>
<div class="sect2">
<h3 id="_prototype_59">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_raw_receive_queue_max_set(
    NX_IP *ip_ptr,
    ULONG queue_max);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_59">Description</h3>
<div class="paragraph">
<p>This service configures the maximum depth of the IP raw packet receive queue. Note that the IP raw packet receive queue is shared with both IPv4 and IPv6 packets. When the raw packet receive queue reaches the userconfigured maximum depth, newly received raw packets are dropped. The default IP raw packet receive queue depth is 20.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_59">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>queue_max</em>: New value for the queue size</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_59">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully set raw receive queue maximum depth</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_59">Allowed From</h3>
<div class="paragraph">
<p>Initialization and threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_59">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_59">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">ULONG queue_max = 10;

/* Set the maximum size of the IP raw packet receive queue. */
status = nx_ip_raw_receive_queue_max_set (&amp;ip_0,
                                          queue_max);

/* If status == NX_SUCCESS, the maximum size of the IP raw packet
   receive queue was successfully set. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_59">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_raw_packet_disable</p>
</li>
<li>
<p>nx_ip_raw_packet_enable</p>
</li>
<li>
<p>nx_ip_raw_packet_filter_set</p>
</li>
<li>
<p>nx_ip_raw_packet_receive</p>
</li>
<li>
<p>nx_ip_raw_packet_send</p>
</li>
<li>
<p>nx_ip_raw_packet_source_send</p>
</li>
<li>
<p>nxd_ip_raw_packet_send</p>
</li>
<li>
<p>nxd_ip_raw_packet_source_send</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_static_route_add">nx_ip_static_route_add</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Add static route to the routing table</p>
</div>
<div class="sect2">
<h3 id="_prototype_60">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_static_route_add(
    NX_IP *ip_ptr,
    ULONG network_address,
    ULONG net_mask,
    ULONG next_hop);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_60">Description</h3>
<div class="paragraph">
<p>This service adds an entry to the static routing table. Note that the <em>next_hop</em> address must be directly accessible from one of the local network devices.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<em>Note that ip_ptr must point to a valid NetX Duo IP structure and the NetX Duo library must be built with NX_ENABLE_IP_STATIC_ROUTING defined to use this service. By default NetX Duo is built without NX_ENABLE_IP_STATIC_ROUTING defined</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_60">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>network_address</em>: Target network address, in host byte order</p>
</li>
<li>
<p><em>net_mask</em>: Target network mask, in host byte order</p>
</li>
<li>
<p><em>next_hop</em>: Next hop address for the target network, in host byte order</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_60">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Entry is added to the static routing table.</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Static routing table is full.</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) This feature is not compiled in.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Next hop is not directly accessible via local interfaces.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid ip_ptr pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_60">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_60">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_60">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Specify the next hop for 192.168.1.68 through the gateway
   192.168.1.1. */
status = nx_ip_static_route_add(ip_ptr, IP_ADDRESS(192,168,1,0),
                                0xFFFFFF00UL,
                                IP_ADDRESS(192,168,1,1));

/* If status is NX_SUCCESS the route was successfully added to the
   static routing table. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_60">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_gateway_address_clear</p>
</li>
<li>
<p>nx_ip_gateway_address_get</p>
</li>
<li>
<p>nx_ip_gateway_address_set</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_static_route_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_add</p>
</li>
<li>
<p>nxd_ipv6_default_router_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_entry_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_number_of_entries_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_static_route_delete">nx_ip_static_route_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Delete static route from routing table</p>
</div>
<div class="sect2">
<h3 id="_prototype_61">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_static_route_delete(
    NX_IP *ip_ptr,
    ULONG network_address,
    ULONG net_mask);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_61">Description</h3>
<div class="paragraph">
<p>This service deletes an entry from the static routing table.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Note that ip_ptr must point to a valid NetX Duo IP structure and the NetX Duo library must be built with NX_ENABLE_IP_STATIC_ROUTING defined to use this service. By default NetX Duo is built without NX_ENABLE_IP_STATIC_ROUTING defined</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_61">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>network_address</em>: Target network address, in host byte order.</p>
</li>
<li>
<p><em>net_mask</em>: Target network mask, in host byte order.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_61">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful deletion from the static routing table.</p>
</li>
<li>
<p><strong>NX_NOT_SUCCESSFUL</strong> (0x43) Entry cannot be found in the routing table.</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) This feature is not compiled in.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid ip_ptr pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_61">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_61">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_61">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Remove the static route for 192.168.1.68 from the routing
   table.*/
status = nx_ip_static_route_delete(ip_ptr,
                                   IP_ADDRESS(192,168,1,0),
                                   0xFFFFFF00UL,);

/* If status is NX_SUCCESS the route was successfully removed from
   the static routing table. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_61">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_gateway_address_clear</p>
</li>
<li>
<p>nx_ip_gateway_address_get</p>
</li>
<li>
<p>nx_ip_gateway_address_set</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_static_route_add</p>
</li>
<li>
<p>nxd_ipv6_default_router_add</p>
</li>
<li>
<p>nxd_ipv6_default_router_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_entry_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_number_of_entries_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ip_status_check">nx_ip_status_check</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Check status of an IP instance</p>
</div>
<div class="sect2">
<h3 id="_prototype_62">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ip_status_check(
    NX_IP *ip_ptr,
    ULONG needed_status,
    ULONG *actual_status,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_62">Description</h3>
<div class="paragraph">
<p>This service checks and optionally waits for the specified status of the primary network interface of a previously created IP instance. To obtain status on secondary interfaces, applications shall use the service <strong><em>nx_ip_interface_status_check.</em></strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_62">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>needed_status</em>: IP status requested, defined in bit-map form as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_IP_INITIALIZE_DONE</strong> (0x0001)</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_RESOLVED</strong> (0x0002)</p>
</li>
<li>
<p><strong>NX_IP_LINK_ENABLED</strong> (0x0004)</p>
</li>
<li>
<p><strong>NX_IP_ARP_ENABLED</strong> (0x0008)</p>
</li>
<li>
<p><strong>NX_IP_UDP_ENABLED</strong> (0x0010)</p>
</li>
<li>
<p><strong>NX_IP_TCP_ENABLED</strong> (0x0020)</p>
</li>
<li>
<p><strong>NX_IP_IGMP_ENABLED</strong> (0x0040)</p>
</li>
<li>
<p><strong>NX_IP_RARP_COMPLETE</strong> (0x0080)</p>
</li>
<li>
<p><strong>NX_IP_INTERFACE_LINK_ENABLED</strong> (0x0100)</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>actual_status</em>: Pointer to destination of actual bits set.</p>
</li>
<li>
<p><em>wait_option</em>: Defines how the service behaves if the requested status bits are not available. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> 0x00000000)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> 0xFFFFFFFF</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_62">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful IP status check.</p>
</li>
<li>
<p><strong>NX_NOT_SUCCESSFUL</strong> (0x43) Status request was not satisfied within the timeout specified.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) IP pointer is or has become invalid, or actual status pointer is invalid.</p>
</li>
<li>
<p><strong>NX_OPTION_ERROR</strong> (0x0a) Invalid needed status option.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_62">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_62">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_62">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Wait 10 ticks for the link up status on the previously created IP
   instance. */
status = nx_ip_status_check(&amp;ip_0, NX_IP_LINK_ENABLED,
                            &amp;actual_status, 10);

/* If status is NX_SUCCESS, the link for the specified IP instance
   is up. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_62">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ipv4_multicast_interface_join">nx_ipv4_multicast_interface_join</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Join IP instance to specified multicast group via an interface</p>
</div>
<div class="sect2">
<h3 id="_prototype_63">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ipv4_multicast_interface_join(
    NX_IP *ip_ptr,
    ULONG group_address,
    UINT interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_63">Description</h3>
<div class="paragraph">
<p>This service joins an IP instance to the specified multicast group via a specified network interface. Once the IP instance joins a multicast group, the IP receive logic starts to forward data packets from the give multicast group to the upper layer. Note that this service joins a multicast group without sending IGMP reports.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_63">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>group_address</em>: Class D IP multicast group address to join in host byte order.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the Interface attached to the NetX Duo instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_63">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful multicast group join.</p>
</li>
<li>
<p><strong>NX_NO_MORE_ENTRIES</strong> (0x17) No more multicast groups can be joined, maximum exceeded.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointer to IP instance, or the IP instance is invalid</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_EANABLED</strong> (0x14) IGMP is not enabled in this IP instance</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Multicast group address provided is not a valid class D address.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index points to an invalid network interface.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_63">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_63">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_63">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Previously created IP Instance joins the multicast group
   224.0.0.200, via the interface at index 1 in the IP interface
   list. */
#define INTERFACE_INDEX 1
status = nx_ipv4_multicast_interface_join
                                 (&amp;ip IP_ADDRESS(224,0,0,200),
                                  INTERFACE_INDEX);

/* If status is NX_SUCCESS, the IP instance has successfully joined
   the multicast group. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_63">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_igmp_enable</p>
</li>
<li>
<p>nx_igmp_info_getnx_igmp_loopback_disable</p>
</li>
<li>
<p>nx_igmp_loopback_enable</p>
</li>
<li>
<p>nx_igmp_multicast_interface_join</p>
</li>
<li>
<p>nx_igmp_multicast_join</p>
</li>
<li>
<p>nx_igmp_multicast_interface_leave</p>
</li>
<li>
<p>nx_igmp_multicast_leave</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_leave</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_join</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_leave</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_ipv4_multicast_interface_leave">nx_ipv4_multicast_interface_leave</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Leave specified multicast group via an interface</p>
</div>
<div class="sect2">
<h3 id="_prototype_64">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_ipv4_multicast_interface_leave(
    NX_IP *ip_ptr,
    ULONG group_address,
    UINT interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_64">Description</h3>
<div class="paragraph">
<p>This service leaves the specified multicast group via a specified network interface. After leaving the group, this service does not trigger IGMP messages being generated.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_64">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>group_address</em>: Class D IP multicast group address to leave. The IP address is in host byte order.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the Interface attached to the NetX Duo instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_64">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful multicast group join.</p>
</li>
<li>
<p><strong>NX_ENTRY_NOT_FOUND</strong> (0x16) The specified multicast group address cannot be found in the local multicast table.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index points to an invalid network interface.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Multicast group address provided is not a valid class D address.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointer to IP instance, or the IP instance is invalid</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_64">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_64">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_64">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Leave the multicast group 224.0.0.200. */
#define INTERFACE_INDEX 1
status = nx_ipv4_multicast_interface_leave
                                (&amp;ip, IP_ADDRESS(224,0,0,200),
                                 INTERFACE_INDEX);

/* If status is NX_SUCCESS, the IP instance has successfully leaves
   the multicast group 244.0.0.200. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_64">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_igmp_enable</p>
</li>
<li>
<p>nx_igmp_info_get</p>
</li>
<li>
<p>nx_igmp_loopback_disable</p>
</li>
<li>
<p>nx_igmp_loopback_enable</p>
</li>
<li>
<p>nx_igmp_multicast_interface_join</p>
</li>
<li>
<p>nx_igmp_multicast_join</p>
</li>
<li>
<p>nx_igmp_multicast_interface_leave</p>
</li>
<li>
<p>nx_igmp_multicast_leave</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_join</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_join</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_leave</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_packet_allocate">nx_packet_allocate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Allocate packet from specified pool</p>
</div>
<div class="sect2">
<h3 id="_prototype_65">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_packet_allocate(
    NX_PACKET_POOL *pool_ptr,
    NX_PACKET **packet_ptr,
    ULONG packet_type,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_65">Description</h3>
<div class="paragraph">
<p>This service allocates a packet from the specified pool and adjusts the prepend pointer in the packet according to the type of packet specified. If no packet is available, the service suspends according to the supplied wait option.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_65">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>pool_ptr</em>: Pointer to previously created packet pool.</p>
</li>
<li>
<p><em>packet_ptr</em>: Pointer to the Pointer of the allocated packet Pointer.</p>
</li>
<li>
<p><em>packet_type</em>: Defines the type of packet requested. See "Packet Pools" on page 63 in Chapter 3 for a list of supported packet types.</p>
</li>
<li>
<p><em>wait_option</em>: Defines the wait time in ticks if there are no packets available in the packet pool. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_65">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet allocate.</p>
</li>
<li>
<p><strong>NX_NO_PACKET</strong> (0x01) No packet available.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) Packet size cannot support protocol.</p>
</li>
<li>
<p><strong>NX_OPTION_ERROR</strong> (0x0A) Invalid packet type.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pool or packet return pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid wait option from nonthread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_65">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers, and ISRs (application network drivers). Wait option must be <em>NX_NO_WAIT</em> when used in ISR or in timer context.</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_65">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_65">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Allocate a new UDP packet from the previously created packet pool
   and suspend for a maximum of 5 timer ticks if the pool is
   empty. */
status = nx_packet_allocate(&amp;pool_0, &amp;packet_ptr,
                            NX_UDP_PACKET, 5);

/* If status is NX_SUCCESS, the newly allocated packet pointer is
   found in the variable packet_ptr. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_65">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_packet_copy</p>
</li>
<li>
<p>nx_packet_data_append</p>
</li>
<li>
<p>nx_packet_data_extract_offset</p>
</li>
<li>
<p>nx_packet_data_retrieve</p>
</li>
<li>
<p>nx_packet_length_get</p>
</li>
<li>
<p>nx_packet_pool_create</p>
</li>
<li>
<p>nx_packet_pool_delete</p>
</li>
<li>
<p>nx_packet_pool_info_get</p>
</li>
<li>
<p>nx_packet_pool_low_watermark_set</p>
</li>
<li>
<p>nx_packet_release</p>
</li>
<li>
<p>nx_packet_transmit_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_packet_copy">nx_packet_copy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copy packet</p>
</div>
<div class="sect2">
<h3 id="_prototype_66">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_packet_copy(
    NX_PACKET *packet_ptr,
    NX_PACKET **new_packet_ptr,
    NX_PACKET_POOL *pool_ptr,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_66">Description</h3>
<div class="paragraph">
<p>This service copies the information in the supplied packet to one or more new packets that are allocated from the supplied packet pool. If successful, the pointer to the new packet is returned in destination pointed to by <strong>new_packet_ptr</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_66">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>packet_ptr</em>: Pointer to the source packet.</p>
</li>
<li>
<p><em>new_packet_ptr</em>: Pointer to the destination of where to return the pointer to the new copy of the packet.</p>
</li>
<li>
<p><em>pool_ptr</em>: Pointer to the previously created packet pool that is used to allocate one or more packets for the copy.</p>
</li>
<li>
<p><em>wait_option</em>: Defines how the service waits if there are no packets available. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_66">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet copy.</p>
</li>
<li>
<p><strong>NX_NO_PACKET</strong> (0x01) Packet not available for copy.</p>
</li>
<li>
<p><strong>NX_INVALID_PACKET</strong> (0x12) Empty source packet or copy failed.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) Packet size cannot support protocol.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pool, packet, or destination pointer.</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Invalid packet prepend pointer.</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Invalid packet append pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) A wait option was specified in initialization or in an ISR.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_66">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers, and ISRs</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_66">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_66">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NX_PACKET *new_copy_ptr;

/* Copy packet pointed to by "old_packet_ptr" using packets from
   previously created packet pool_0. */
status = nx_packet_copy(old_packet, &amp;new_copy_ptr, &amp;pool_0, 20);

/* If status is NX_SUCCESS, new_copy_ptr points to the packet copy. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_66">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_packet_allocate</p>
</li>
<li>
<p>nx_packet_data_append</p>
</li>
<li>
<p>nx_packet_data_extract_offset</p>
</li>
<li>
<p>nx_packet_data_retrieve</p>
</li>
<li>
<p>nx_packet_length_get</p>
</li>
<li>
<p>nx_packet_pool_create</p>
</li>
<li>
<p>nx_packet_pool_delete</p>
</li>
<li>
<p>nx_packet_pool_info_get</p>
</li>
<li>
<p>nx_packet_pool_low_watermark_set</p>
</li>
<li>
<p>nx_packet_release</p>
</li>
<li>
<p>nx_packet_transmit_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_packet_data_append">nx_packet_data_append</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Append data to end of packet</p>
</div>
<div class="sect2">
<h3 id="_prototype_67">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_packet_data_append(
    NX_PACKET *packet_ptr,
    VOID *data_start, ULONG data_size,
    NX_PACKET_POOL *pool_ptr,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_67">Description</h3>
<div class="paragraph">
<p>This service appends data to the end of the specified packet. The supplied data area is copied into the packet. If there is not enough memory available, and the chained packet feature is enabled, one or more packets will be allocated to satisfy the request. If the chained packet feature is not enabled, <em>NX_SIZE_ERROR</em> is returned.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_67">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>packet_ptr</em>: Packet pointer.</p>
</li>
<li>
<p><em>data_start</em>: Pointer to the start of the user&#8217;s data area to append to the packet.</p>
</li>
<li>
<p><em>data_size</em>: Size of user&#8217;s data area.</p>
</li>
<li>
<p><em>pool_ptr</em>: Pointer to packet pool from which to allocate another packet if there is not enough room in the current packet.</p>
</li>
<li>
<p><em>wait_option</em>: Defines how the service behaves if there are no packets available. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_67">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet append.</p>
</li>
<li>
<p><strong>NX_NO_PACKET</strong> (0x01) No packet available.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) Packet size cannot support protocol.</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Prepend pointer is less than payload start.</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Append pointer is greater than payload end.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pool, packet, or data Pointer.</p>
</li>
<li>
<p><strong>NX_SIZE_ERROR</strong> (0x09) Invalid data size.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid wait option from nonthread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_67">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers, and ISRs (application network drivers)</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_67">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_67">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Append "abcd" to the specified packet. */
status = nx_packet_data_append(packet_ptr, "abcd", 4, &amp;pool_0, 5);

/* If status is NX_SUCCESS, the additional four bytes "abcd" have
   been appended to the packet. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_67">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_packet_allocate</p>
</li>
<li>
<p>nx_packet_copy</p>
</li>
<li>
<p>nx_packet_data_extract_offset</p>
</li>
<li>
<p>nx_packet_data_retrieve</p>
</li>
<li>
<p>nx_packet_length_get</p>
</li>
<li>
<p>nx_packet_pool_create</p>
</li>
<li>
<p>nx_packet_pool_delete</p>
</li>
<li>
<p>nx_packet_pool_info_get</p>
</li>
<li>
<p>nx_packet_pool_low_watermark_set</p>
</li>
<li>
<p>nx_packet_release</p>
</li>
<li>
<p>nx_packet_transmit_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_packet_data_extract_offset">nx_packet_data_extract_offset</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Extract data from packet via an offset</p>
</div>
<div class="sect2">
<h3 id="_prototype_68">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_packet_data_extract_offset(
    NX_PACKET *packet_ptr,
    ULONG offset,
    VOID *buffer_start,
    ULONG buffer_length,
    ULONG *bytes_copied);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_68">Description</h3>
<div class="paragraph">
<p>This service copies data from a NetX Duo packet (or packet chain) starting at the specified offset from the packet prepend pointer of the specified size in bytes into the specified buffer. The number of bytes actually copied is returned in <em>bytes_copied.</em> This service does not remove data from the packet, nor does it adjust the prepend pointer or other internal state information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_68">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>packet_ptr</em>: Pointer to packet to extract</p>
</li>
<li>
<p><em>offset</em>: Offset from the current prepend pointer.</p>
</li>
<li>
<p><em>buffer_start</em>: Pointer to start of save buffer</p>
</li>
<li>
<p><em>buffer_length</em>: Number of bytes to copy</p>
</li>
<li>
<p><em>bytes_copied</em>: Number of bytes actually copied</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_68">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet copy</p>
</li>
<li>
<p><strong>NX_PACKET_OFFSET_ERROR</strong> (0x53) Invalid offset value was supplied</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid packet pointer or buffer pointer</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_68">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers, and ISRs</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_68">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Extract 10 bytes from the start of the received packet buffer
   into the specified memory area. */
status = nx_packet_data_extract_offset(my_packet, 0, &amp;data[0], 10,
                                       &amp;bytes_copied) ;
/* If status is NX_SUCCESS, 10 bytes were successfully copied into
   the data buffer. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_68">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_packet_allocate</p>
</li>
<li>
<p>nx_packet_copy</p>
</li>
<li>
<p>nx_packet_data_append</p>
</li>
<li>
<p>nx_packet_data_retrieve</p>
</li>
<li>
<p>nx_packet_length_get</p>
</li>
<li>
<p>nx_packet_pool_create</p>
</li>
<li>
<p>nx_packet_pool_delete</p>
</li>
<li>
<p>nx_packet_pool_info_get</p>
</li>
<li>
<p>nx_packet_pool_low_watermark_set</p>
</li>
<li>
<p>nx_packet_release</p>
</li>
<li>
<p>nx_packet_transmit_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_packet_data_retrieve">nx_packet_data_retrieve</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve data from packet</p>
</div>
<div class="sect2">
<h3 id="_prototype_69">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_packet_data_retrieve(
    NX_PACKET *packet_ptr,
    VOID *buffer_start,
    ULONG *bytes_copied);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_69">Description</h3>
<div class="paragraph">
<p>This service copies data from the supplied packet into the supplied buffer. The actual number of bytes copied is returned in the destination pointed to by <strong>bytes_copied</strong>.</p>
</div>
<div class="paragraph">
<p>Note that this service does not change internal state of the packet. The data being retrieved is still available in the packet.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<em>The destination buffer must be large enough to hold the packet&#8217;s contents. If not, memory will be corrupted causing unpredictable results</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_69">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>packet_ptr</em>: Pointer to the source packet.</p>
</li>
<li>
<p><em>buffer_start</em>: Pointer to the start of the buffer area.</p>
</li>
<li>
<p><em>bytes_copied</em>: Pointer to the destination for the number of bytes copied.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_69">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet data retrieve.</p>
</li>
<li>
<p><strong>NX_INVALID_PACKET</strong> (0x12) Invalid packet.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid packet, buffer start, or bytes copied pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_69">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers, and ISRs</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_69">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_68">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UCHAR                 buffer[512];
ULONG                 bytes_copied;

/* Retrieve data from packet pointed to by "packet_ptr". */
status = nx_packet_data_retrieve(packet_ptr, buffer, &amp;bytes_copied);

/* If status is NX_SUCCESS, buffer contains the contents of the
   packet, the size of which is contained in "bytes_copied." */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_69">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_packet_allocate</p>
</li>
<li>
<p>nx_packet_copy</p>
</li>
<li>
<p>nx_packet_data_append</p>
</li>
<li>
<p>nx_packet_data_extract_offset</p>
</li>
<li>
<p>nx_packet_length_get</p>
</li>
<li>
<p>nx_packet_pool_create</p>
</li>
<li>
<p>nx_packet_pool_delete</p>
</li>
<li>
<p>nx_packet_pool_info_get</p>
</li>
<li>
<p>nx_packet_pool_low_watermark_set</p>
</li>
<li>
<p>nx_packet_release</p>
</li>
<li>
<p>nx_packet_transmit_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_packet_length_get">nx_packet_length_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Get length of packet data</p>
</div>
<div class="sect2">
<h3 id="_prototype_70">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_packet_length_get(
    NX_PACKET *packet_ptr,
    ULONG *length);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_70">Description</h3>
<div class="paragraph">
<p>This service gets the length of the data in the specified packet.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_70">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>packet_ptr</em>: Pointer to the packet.</p>
</li>
<li>
<p><em>length</em>: Destination for the packet length.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_70">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet length get.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid packet pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_70">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers, and ISRs</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_70">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_69">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Get the length of the data in "my_packet." */
status = nx_packet_length_get(my_packet, &amp;my_length);

/* If status is NX_SUCCESS, data length is in "my_length". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_70">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_packet_allocate</p>
</li>
<li>
<p>nx_packet_copy</p>
</li>
<li>
<p>nx_packet_data_append</p>
</li>
<li>
<p>nx_packet_data_extract_offset</p>
</li>
<li>
<p>nx_packet_data_retrieve</p>
</li>
<li>
<p>nx_packet_pool_create</p>
</li>
<li>
<p>nx_packet_pool_delete</p>
</li>
<li>
<p>nx_packet_pool_info_get</p>
</li>
<li>
<p>nx_packet_pool_low_watermark_set</p>
</li>
<li>
<p>nx_packet_release</p>
</li>
<li>
<p>nx_packet_transmit_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_packet_pool_create">nx_packet_pool_create</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create packet pool in specified memory area</p>
</div>
<div class="sect2">
<h3 id="_prototype_71">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_packet_pool_create(
    NX_PACKET_POOL *pool_ptr,
    CHAR *name,
    ULONG payload_size,
    VOID *memory_ptr,
    ULONG memory_size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_71">Description</h3>
<div class="paragraph">
<p>This service creates a packet pool of the specified packet size in the memory area supplied by the user.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_71">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>pool_ptr</em>: Pointer to packet pool control block.</p>
</li>
<li>
<p><em>name</em>: Pointer to application&#8217;s name for the packet pool.</p>
</li>
<li>
<p><em>payload_size</em>: Number of bytes in each packet in the pool. This value must be at least 40 bytes and must also be evenly divisible by 4.</p>
</li>
<li>
<p><em>memory_ptr</em>: Pointer to the memory area to place the packet pool in. The pointer should be aligned on an ULONG boundary.</p>
</li>
<li>
<p><em>memory_size</em>: Size of the pool memory area.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_71">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet pool create.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pool or memory pointer.</p>
</li>
<li>
<p><strong>NX_SIZE_ERROR</strong> (0x09) Invalid block or memory size.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_71">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_71">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_70">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Create a packet pool of 32000 bytes starting at physical
   address 0x10000000. */
status = nx_packet_pool_create(&amp;pool_0, "Default Pool", 128,
                               (void *) 0x10000000, 32000);

/* If status is NX_SUCCESS, the packet pool has been successfully
   created. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_71">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_packet_allocate</p>
</li>
<li>
<p>nx_packet_copy</p>
</li>
<li>
<p>nx_packet_data_append</p>
</li>
<li>
<p>nx_packet_data_extract_offset</p>
</li>
<li>
<p>nx_packet_data_retrieve</p>
</li>
<li>
<p>nx_packet_length_get</p>
</li>
<li>
<p>nx_packet_pool_delete</p>
</li>
<li>
<p>nx_packet_pool_info_get</p>
</li>
<li>
<p>nx_packet_pool_low_watermark_set</p>
</li>
<li>
<p>nx_packet_release</p>
</li>
<li>
<p>nx_packet_transmit_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_packet_pool_delete">nx_packet_pool_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Delete previously created packet pool</p>
</div>
<div class="sect2">
<h3 id="_prototype_72">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT  nx_packet_pool_delete(NX_PACKET_POOL *pool_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_72">Description</h3>
<div class="paragraph">
<p>This service deletes a previously created packet pool. NetX Duo checks for any threads currently suspended on packets in the packet pool and clears the suspension.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_72">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>pool_ptr</em>: Packet pool control block pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_72">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet pool delete.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pool pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_72">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_72">Preemption Possible</h3>
<div class="paragraph">
<p>Yes</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_71">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Delete a previously created packet pool. */
status = nx_packet_pool_delete(&amp;pool_0);

/* If status is NX_SUCCESS, the packet pool has been successfully
   deleted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_72">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_packet_allocate</p>
</li>
<li>
<p>nx_packet_copy</p>
</li>
<li>
<p>nx_packet_data_append</p>
</li>
<li>
<p>nx_packet_data_extract_offset</p>
</li>
<li>
<p>nx_packet_data_retrieve</p>
</li>
<li>
<p>nx_packet_length_get</p>
</li>
<li>
<p>nx_packet_pool_create</p>
</li>
<li>
<p>nx_packet_pool_info_get</p>
</li>
<li>
<p>nx_packet_pool_low_watermark_set</p>
</li>
<li>
<p>nx_packet_release</p>
</li>
<li>
<p>nx_packet_transmit_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_packet_pool_info_get">nx_packet_pool_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve information about a packet pool</p>
</div>
<div class="sect2">
<h3 id="_prototype_73">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_packet_pool_info_get(
    NX_PACKET_POOL *pool_ptr,
    ULONG *total_packets,
    ULONG *free_packets,
    ULONG *empty_pool_requests,
    ULONG *empty_pool_suspensions,
    ULONG *invalid_packet_releases);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_73">Description</h3>
<div class="paragraph">
<p>This service retrieves information about the specified packet pool.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If a destination pointer is NX_NULL, that particular information is not returned to the caller</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_73">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>pool_ptr</em>: Pointer to previously created packet pool.</p>
</li>
<li>
<p><em>total_packets</em>: Pointer to destination for the total number of packets in the pool.</p>
</li>
<li>
<p><em>free_packets</em>: Pointer to destination for the total number of currently free packets.</p>
</li>
<li>
<p><em>empty_pool_requests</em>: Pointer to destination of the total number of allocation requests when the pool was empty.</p>
</li>
<li>
<p><em>empty_pool_suspensions</em>: Pointer to destination of the total number of empty pool suspensions.</p>
</li>
<li>
<p><em>invalid_packet_releases</em>: Pointer to destination of the total number of invalid packet releases.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_73">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet pool information retrieval.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_73">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, and timers</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_73">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_72">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Retrieve packet pool information. */
status = nx_packet_pool_info_get(&amp;pool_0,
                                 &amp;total_packets,
                                 &amp;free_packets,
                                 &amp;empty_pool_requests,
                                 &amp;empty_pool_suspensions,
                                 &amp;invalid_packet_releases);

/* If status is NX_SUCCESS, packet pool information was
   retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_73">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_packet_allocate</p>
</li>
<li>
<p>nx_packet_copy</p>
</li>
<li>
<p>nx_packet_data_append</p>
</li>
<li>
<p>nx_packet_data_extract_offset</p>
</li>
<li>
<p>nx_packet_data_retrieve</p>
</li>
<li>
<p>nx_packet_length_get</p>
</li>
<li>
<p>nx_packet_pool_create</p>
</li>
<li>
<p>nx_packet_pool_delete</p>
</li>
<li>
<p>nx_packet_pool_low_watermark_set</p>
</li>
<li>
<p>nx_packet_release</p>
</li>
<li>
<p>nx_packet_transmit_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_packet_pool_low_watermark_set">nx_packet_pool_low_watermark_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set packet pool low watermark</p>
</div>
<div class="sect2">
<h3 id="_prototype_74">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_packet_pool_low_watermark_set(
    NX_PACKET_POOL *pool_ptr,
    ULONG low_watermark);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_74">Description</h3>
<div class="paragraph">
<p>This service configures the low watermark for the specified packet pool. Once the low watermark value is set, TCP or UDP will not queue up the received packets if the number of available packets in the packet pool is less than the packet pool&#8217;s low watermark, preventing the packet pool from being starved of packets. This service is available if the NetX Duo library is built with the option <strong>NX_ENABLE_LOW_WATERMARK</strong> defined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_74">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>pool_ptr</em>: Pointer to packet pool control block.</p>
</li>
<li>
<p><em>low_watermark</em>: Low watermark value to be configured</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_74">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully set the low watermark value.</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) The low watermark feature is not built into NetX Duo.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pool pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_74">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_74">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_73">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Set pool_0 low watermark value to 2. */
status = nx_packet_pool_create(&amp;pool_0, 2);

/* If status is NX_SUCCESS, the low watermark value is set for
   pool_0.*/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_74">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_packet_allocate</p>
</li>
<li>
<p>nx_packet_copy</p>
</li>
<li>
<p>nx_packet_data_append</p>
</li>
<li>
<p>nx_packet_data_extract_offset</p>
</li>
<li>
<p>nx_packet_data_retrieve</p>
</li>
<li>
<p>nx_packet_length_get</p>
</li>
<li>
<p>nx_packet_pool_create</p>
</li>
<li>
<p>nx_packet_pool_delete</p>
</li>
<li>
<p>nx_packet_pool_info_get</p>
</li>
<li>
<p>nx_packet_release</p>
</li>
<li>
<p>nx_packet_transmit_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_packet_release">nx_packet_release</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Release previously allocated packet</p>
</div>
<div class="sect2">
<h3 id="_prototype_75">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_packet_release(NX_PACKET *packet_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_75">Description</h3>
<div class="paragraph">
<p>This service releases a packet, including any additional packets chained to the specified packet. If another thread is blocked on packet allocation, it is given the packet and resumed.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[!NOTE]<br>
<em>The application must prevent releasing a packet more than once, because doing so will cause unpredictable results</em>.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_75">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>packet_ptr</em>: Packet pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_75">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet release.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid packet pointer.</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Prepend pointer is less than payload start.</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Append pointer is greater than payload end.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_75">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers, and ISRs (application network drivers)</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_75">Preemption Possible</h3>
<div class="paragraph">
<p>Yes</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_74">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Release a previously allocated packet. */
status = nx_packet_release(packet_ptr);

/* If status is NX_SUCCESS, the packet has been returned to the
   packet pool it was allocated from. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_75">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_packet_allocate</p>
</li>
<li>
<p>nx_packet_copy</p>
</li>
<li>
<p>nx_packet_data_append</p>
</li>
<li>
<p>nx_packet_data_extract_offset</p>
</li>
<li>
<p>nx_packet_data_retrieve</p>
</li>
<li>
<p>nx_packet_length_get</p>
</li>
<li>
<p>nx_packet_pool_create</p>
</li>
<li>
<p>nx_packet_pool_delete</p>
</li>
<li>
<p>nx_packet_pool_info_get</p>
</li>
<li>
<p>nx_packet_pool_low_watermark_set</p>
</li>
<li>
<p>nx_packet_transmit_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_packet_transmit_release">nx_packet_transmit_release</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Release a transmitted packet</p>
</div>
<div class="sect2">
<h3 id="_prototype_76">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_packet_transmit_release(NX_PACKET *packet_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_76">Description</h3>
<div class="paragraph">
<p>For non-TCP packets, this service releases a transmitted packet, including any additional packets chained to the specified packet. If another thread is blocked on packet allocation, it is given the packet and resumed. For a transmitted TCP packet, the packet is marked as being transmitted but not released till the packet is acknowledged. This service is typically called from the application&#8217;s network driver after a packet is transmitted.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>The network driver should remove the physical media header and adjust the length of the packet before calling this service</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_76">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>packet_ptr</em>: Packet pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_76">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful transmit packet release.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid packet pointer.</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Prepend pointer is less than payload start.</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Append pointer is greater than payload end.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_76">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers, Application network drivers (including ISRs)</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_76">Preemption Possible</h3>
<div class="paragraph">
<p>Yes</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_75">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Release a previously allocated packet that was just transmitted
   from the application network driver. */
status = nx_packet_transmit_release(packet_ptr);

/* If status is NX_SUCCESS, the transmitted packet has been
   returned to the packet pool it was allocated from. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_76">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_packet_allocate</p>
</li>
<li>
<p>nx_packet_copy</p>
</li>
<li>
<p>nx_packet_data_append</p>
</li>
<li>
<p>nx_packet_data_extract_offset</p>
</li>
<li>
<p>nx_packet_data_retrieve</p>
</li>
<li>
<p>nx_packet_length_get</p>
</li>
<li>
<p>nx_packet_pool_create</p>
</li>
<li>
<p>nx_packet_pool_delete</p>
</li>
<li>
<p>nx_packet_pool_info_get</p>
</li>
<li>
<p>nx_packet_pool_low_watermark_set</p>
</li>
<li>
<p>nx_packet_release</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_rarp_disable">nx_rarp_disable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Disable Reverse Address Resolution Protocol (RARP)</p>
</div>
<div class="sect2">
<h3 id="_prototype_77">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_rarp_disable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_77">Description</h3>
<div class="paragraph">
<p>This service disables the RARP component of NetX Duo for the specific IP instance. For a multihome  system, this service disables RARP on all interfaces.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_77">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_77">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful RARP disable.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) RARP was not enabled.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_77">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_77">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_76">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Disable RARP on the previously created IP instance. */
status = nx_rarp_disable(&amp;ip_0);

/* If status is NX_SUCCESS, RARP is disabled. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_77">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_rarp_enable</p>
</li>
<li>
<p>nx_rarp_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_rarp_enable">nx_rarp_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable Reverse Address Resolution Protocol (RARP)</p>
</div>
<div class="sect2">
<h3 id="_prototype_78">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_rarp_enable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_78">Description</h3>
<div class="paragraph">
<p>This service enables the RARP component of NetX Duo for the specific IP instance. The RARP components searches through all attached network interfaces for zero IP address. A zero IP address indicates the
interface does not have IP address assignment yet. RARP attempts to resolve the IP address by enabling RARP process on that interface.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_78">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_78">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful RARP enable.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) IP address is already valid.</p>
</li>
<li>
<p><strong>NX_ALREADY_ENABLED</strong> (0x15) RARP was already enabled.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_78">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_78">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_77">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Enable RARP on the previously created IP instance. */
status = nx_rarp_enable(&amp;ip_0);

/* If status is NX_SUCCESS, RARP is enabled and is attempting to
   resolve this IP instance's address by querying the network. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_78">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_rarp_disable</p>
</li>
<li>
<p>nx_rarp_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_rarp_info_get">nx_rarp_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve information about RARP activities</p>
</div>
<div class="sect2">
<h3 id="_prototype_79">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_rarp_info_get(
    NX_IP *ip_ptr,
    ULONG *rarp_requests_sent,
    ULONG *rarp_responses_received,
    ULONG *rarp_invalid_messages);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_79">Description</h3>
<div class="paragraph">
<p>This service retrieves information about RARP activities for the specified IP instance.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If a destination pointer is NX_NULL, that particular information is not returned to the caller</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_79">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>rarp_requests_sent</em>: Pointer to destination for the total number of RARP requests sent.</p>
</li>
<li>
<p><em>rarp_responses_received</em>: Pointer to destination for the total number of RARP responses received.</p>
</li>
<li>
<p><em>rarp_invalid_messages</em>: Pointer to destination of the total number of invalid messages.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_79">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful RARP information retrieval.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_79">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_79">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_78">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Retrieve RARP information from previously created IP
   Instance 0. */
status = nx_rarp_info_get(&amp;ip_0,
                          &amp;rarp_requests_sent,
                          &amp;rarp_responses_received,
                          &amp;rarp_invalid_messages);

/* If status is NX_SUCCESS, RARP information was retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_79">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_rarp_disable</p>
</li>
<li>
<p>nx_rarp_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_system_initialize">nx_system_initialize</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Initialize NetX Duo System</p>
</div>
<div class="sect2">
<h3 id="_prototype_80">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">VOID nx_system_initialize(VOID);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_80">Description</h3>
<div class="paragraph">
<p>This service initializes the basic NetX Duo system resources in preparation for use. It should be called by the application during initialization and before any other NetX Duo call are made.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_80">Parameters</h3>
<div class="paragraph">
<p>None</p>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_80">Return Values</h3>
<div class="paragraph">
<p>None</p>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_80">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers, ISRs</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_80">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
<div class="paragraph">
<p>System Management</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_79">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Initialize NetX Duo for operation. */
nx_system_initialize();

/* At this point, NetX Duo is ready for IP creation and all
   subsequent network operations. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_80">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_client_socket_bind">nx_tcp_client_socket_bind</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Bind client TCP socket to TCP port</p>
</div>
<div class="sect2">
<h3 id="_prototype_81">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_client_socket_bind(
    NX_TCP_SOCKET *socket_ptr,
    UINT port,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_81">Description</h3>
<div class="paragraph">
<p>This service binds the previously created TCP client socket to the specified TCP port. Valid TCP sockets range from 0 through 0xFFFF. If the specified TCP port is unavailable, the service suspends according to the supplied wait option.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_81">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created TCP socket instance.</p>
</li>
<li>
<p><em>port Port</em>: number to bind (1 through 0xFFFF). If port number is NX_ANY_PORT (0x0000), the IP instance will search for the next free port and use that for the binding.</p>
</li>
<li>
<p><em>wait_option</em>: Defines how the service behaves if the port is already bound to another socket. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>timeout value in ticks</em>: (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_81">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket bind.</p>
</li>
<li>
<p><strong>NX_ALREADY_BOUND</strong> (0x22) This socket is already bound to another TCP port.</p>
</li>
<li>
<p><strong>NX_PORT_UNAVAILABLE</strong> (0x23) Port is already bound to a different socket.</p>
</li>
<li>
<p><strong>NX_NO_FREE_PORTS</strong> (0x45) No free port.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) Invalid port.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_81">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_81">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_80">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Bind a previously created client socket to port 12 and wait for 7
   timer ticks for the bind to complete. */
status = nx_tcp_client_socket_bind(&amp;client_socket, 12, 7);

/* If status is NX_SUCCESS, the previously created client_socket is
   bound to port 12 on the associated IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_81">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_client_socket_connect">nx_tcp_client_socket_connect</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Connect client TCP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_82">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_client_socket_connect(
    NX_TCP_SOCKET *socket_ptr,
    ULONG server_ip,
    UINT server_port,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_82">Description</h3>
<div class="paragraph">
<p>This service connects the previously created and bound TCP client socket to the specified server&#8217;s port. Valid TCP server ports range from 0 through 0xFFFF. If the connection does not complete immediately, the service suspends according to the supplied wait option.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_82">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created TCP socket instance.</p>
</li>
<li>
<p><em>server_ip</em>: Server&#8217;s IP address.</p>
</li>
<li>
<p><em>server_port</em>: Server port number to connect to (1 through 0xFFFF).</p>
</li>
<li>
<p><em>wait_option</em>: Defines how the service behaves while the connection is being established. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_82">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket connect.</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket is not bound.</p>
</li>
<li>
<p><strong>NX_NOT_CLOSED</strong> (0x35) Socket is not in a closed state.</p>
</li>
<li>
<p><strong>NX_IN_PROGRESS</strong> (0x37) No wait was specified, the connection attempt is in progress.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid interface supplied.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid server IP address.</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) Invalid port.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_82">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_82">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_81">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Initiate a TCP connection from a previously created and bound
   client socket. The connection requested in this example is to
   port 12 on the server with the IP address of 1.2.3.5. This
   service will wait 300 timer ticks for the connection to take
   place before giving up. */
status = nx_tcp_client_socket_connect(&amp;client_socket,
                                      IP_ADDRESS(1,2,3,5),
                                      12, 300);

/* If status is NX_SUCCESS, the previously created and bound
   client_socket is connected to port 12 on IP 1.2.3.5. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_82">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_client_socket_port_get">nx_tcp_client_socket_port_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Get port number bound to client TCP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_83">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_client_socket_port_get(
    NX_TCP_SOCKET *socket_ptr,
    UINT *port_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_83">Description</h3>
<div class="paragraph">
<p>This service retrieves the port number associated with the socket, which is useful to find the port allocated by NetX Duo in situations where the NX_ANY_PORT was specified at the time the socket was bound.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_83">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created TCP socket instance.</p>
</li>
<li>
<p><em>port_ptr</em>: Pointer to destination for the return port number. Valid port numbers are (1 through 0xFFFF).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_83">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket bind.</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) This socket is not bound to a port.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer or port return pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_83">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_83">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_82">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Get the port number of previously created and bound client
   socket. */
status = nx_tcp_client_socket_port_get(&amp;client_socket, &amp;port);

/* If status is NX_SUCCESS, the port variable contains the port this
   socket is bound to. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_83">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_client_socket_unbind">nx_tcp_client_socket_unbind</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unbind TCP client socket from TCP port</p>
</div>
<div class="sect2">
<h3 id="_prototype_84">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_client_socket_unbind(NX_TCP_SOCKET *socket_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_84">Description</h3>
<div class="paragraph">
<p>This service releases the binding between the TCP client socket and a TCP port. If there are other threads waiting to bind another socket to the same port number, the first suspended thread is then bound to this port.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_84">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created TCP socket instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_84">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket unbind.</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket was not bound to any port.</p>
</li>
<li>
<p><strong>NX_NOT_CLOSED</strong> (0x35) Socket has not been disconnected.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_84">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_84">Preemption Possible</h3>
<div class="paragraph">
<p>Yes</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_83">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Unbind a previously created and bound client TCP socket. */
status = nx_tcp_client_socket_unbind(&amp;client_socket);

/* If status is NX_SUCCESS, the client socket is no longer
   bound. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_84">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_enable">nx_tcp_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable TCP component of NetX Duo</p>
</div>
<div class="sect2">
<h3 id="_prototype_85">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_enable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_85">Description</h3>
<div class="paragraph">
<p>This service enables the Transmission Control Protocol (TCP) component of NetX Duo. After enabled, TCP connections may be established by the application.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_85">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_85">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful TCP enable.</p>
</li>
<li>
<p><strong>NX_ALREADY_ENABLED</strong> (0x15) TCP is already enabled.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_85">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_85">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_84">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Enable TCP on a previously created IP instance ip_0. */
status = nx_tcp_enable(&amp;ip_0);

/* If status is NX_SUCCESS, TCP is enabled on the IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_85">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_free_port_find">nx_tcp_free_port_find</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Find next available TCP port</p>
</div>
<div class="sect2">
<h3 id="_prototype_86">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_free_port_find(
    NX_IP *ip_ptr,
    UINT port,
    UINT *free_port_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_86">Description</h3>
<div class="paragraph">
<p>This service attempts to locate a free TCP port (unbound) starting from the application supplied port. The search logic will wrap around if the search happens to reach the maximum port value of 0xFFFF. If  the search is successful, the free port is returned in the variable pointed to by <em>free_port_ptr</em>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>This service can be called from another thread and have the same port returned. To prevent this race condition, the application may wish to place this service and the actual client socket bind under the protection of a mutex</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_86">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>port</em>: Port number to start search at (1 through 0xFFFF).</p>
</li>
<li>
<p><em>free_port_ptr</em>: Pointer to the destination free port return value.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_86">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful free port find.</p>
</li>
<li>
<p><strong>NX_NO_FREE_PORTS</strong> (0x45) No free ports found.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) The specified port number is invalid.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_86">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_86">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_85">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Locate a free TCP port, starting at port 12, on a previously
   created IP instance. */
status = nx_tcp_free_port_find(&amp;ip_0, 12, &amp;free_port);

/* If status is NX_SUCCESS, "free_port" contains the next free port
   on the IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_86">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_info_get">nx_tcp_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve information about TCP activities</p>
</div>
<div class="sect2">
<h3 id="_prototype_87">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_info_get(
    NX_IP *ip_ptr,
    ULONG *tcp_packets_sent,
    ULONG *tcp_bytes_sent,
    ULONG *tcp_packets_received,
    ULONG *tcp_bytes_received,
    ULONG *tcp_invalid_packets,
    ULONG *tcp_receive_packets_dropped,
    ULONG *tcp_checksum_errors,
    ULONG *tcp_connections,
    ULONG *tcp_disconnections,
    ULONG *tcp_connections_dropped,
    ULONG *tcp_retransmit_packets);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_87">Description</h3>
<div class="paragraph">
<p>This service retrieves information about TCP activities for the specified IP instance.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If a destination pointer is NX_NULL, that particular information is not returned to the caller</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_87">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>tcp_packets_sent</em>: Pointer to destination for the total number of TCP packets sent.</p>
</li>
<li>
<p><em>tcp_bytes_sent</em>: Pointer to destination for the total number of TCP bytes sent.</p>
</li>
<li>
<p><em>tcp_packets_received</em>: Pointer to destination of the total number of TCP packets received.</p>
</li>
<li>
<p><em>tcp_bytes_received</em>: Pointer to destination of the total number of TCP bytes received.</p>
</li>
<li>
<p><em>tcp_invalid_packets</em>: Pointer to destination of the total number of invalid TCP packets.</p>
</li>
<li>
<p><em>tcp_receive_packets_dropped</em>: Pointer to destination of the total number of TCP receive packets dropped.</p>
</li>
<li>
<p><em>tcp_checksum_errors</em>: Pointer to destination of the total number of TCP packets with checksum errors.</p>
</li>
<li>
<p><em>tcp_connections</em>: Pointer to destination of the total number of TCP connections.</p>
</li>
<li>
<p><em>tcp_disconnections</em>: Pointer to destination of the total number of TCP disconnections.</p>
</li>
<li>
<p><em>tcp_connections_dropped</em>: Pointer to destination of the total number of TCP connections dropped.</p>
</li>
<li>
<p><em>tcp_retransmit_packets</em>: Pointer to destination of the total number of TCP packets retransmitted.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_87">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful TCP information retrieval.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_87">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_87">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_86">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Retrieve TCP information from previously created IP Instance
   ip_0. */
status = nx_tcp_info_get(&amp;ip_0,
                         &amp;tcp_packets_sent,
                         &amp;tcp_bytes_sent,
                         &amp;tcp_packets_received,
                         &amp;tcp_bytes_received,
                         &amp;tcp_invalid_packets,
                         &amp;tcp_receive_packets_dropped,
                         &amp;tcp_checksum_errors,
                         &amp;tcp_connections,
                         &amp;tcp_disconnections
                         &amp;tcp_connections_dropped,
                         &amp;tcp_retransmit_packets);

/* If status is NX_SUCCESS, TCP information was retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_87">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_server_socket_accept">nx_tcp_server_socket_accept</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Accept TCP connection</p>
</div>
<div class="sect2">
<h3 id="_prototype_88">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_server_socket_accept(
    NX_TCP_SOCKET *socket_ptr,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_88">Description</h3>
<div class="paragraph">
<p>This service accepts (or prepares to accept) a TCP client socket connection request for a port that was previously set up for listening. This service may be called immediately after the application calls the listen or re-listen service or after the listen callback routine is called when the client connection is actually present. If a connection cannot not be established right away, the service suspends according to the supplied wait option.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>The application must call <strong>*nx_tcp_server_socket_unaccept*</em> after the connection is no longer needed to remove the server socket&#8217;s binding to the server port</strong>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>Application callback routines are called from within the IP&#8217;s helper thread</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_88">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to the TCP server socket control block.</p>
</li>
<li>
<p><em>wait_option</em>: Defines how the service behaves while the connection is being established. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_88">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful TCP server socket accept (passive connect).</p>
</li>
<li>
<p><strong>NX_NOT_LISTEN_STATE</strong> (0x36) The server socket supplied is not in a listen state.</p>
</li>
<li>
<p><strong>NX_IN_PROGRESS</strong> (0x37) No wait was specified, the connection attempt is in progress.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Socket pointer error.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_88">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_88">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_87">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NX_PACKET_POOL my_pool;
NX_IP my_ip;
NX_TCP_SOCKET server_socket;

void port_12_connect_request(NX_TCP_SOCKET *socket_ptr, UINT port)
{
    /* Simply set the semaphore to wake up the server thread. */
    tx_semaphore_put(&amp;port_12_semaphore);
}

void port_12_disconnect_request(NX_TCP_SOCKET *socket_ptr)
{
    /* The client has initiated a disconnect on this socket. This
       example doesn't use this callback. */
}

void port_12_server_thread_entry(ULONG id)
{
NX_PACKET *my_packet;
UINT status, i;
    /* Assuming that:
       "port_12_semaphore" has already been created with an
        initial count of 0 "my_ip" has already been created and the
        link is enabled "my_pool" packet pool has already been
        created
    */

    /* Create the server socket. */
    nx_tcp_socket_create(&amp;my_ip, &amp;server_socket,
                         "Port 12 Server Socket",
                          NX_IP_NORMAL, NX_FRAGMENT_OKAY,
                          NX_IP_TIME_TO_LIVE, 100,
                          NX_NULL, port_12_disconnect_request);

    /* Setup server listening on port 12. */
    nx_tcp_server_socket_listen(&amp;my_ip, 12, &amp;server_socket, 5,
                                port_12_connect_request);

    /* Loop to process 5 server connections, sending
       "Hello_and_Goodbye" to each client and then disconnecting.*/
    for (i = 0; i &lt; 5; i++)
    {

        /* Get the semaphore that indicates a client connection
        request is present. */
        tx_semaphore_get(&amp;port_12_semaphore, TX_WAIT_FOREVER);

        /* Wait for 200 ticks for the client socket connection to
           complete.*/
        status = nx_tcp_server_socket_accept(&amp;server_socket, 200);

        /* Check for a successful connection. */
        if (status == NX_SUCCESS)
        {

            /* Allocate a packet for the "Hello_and_Goodbye"
               message */
            nx_packet_allocate(&amp;my_pool, &amp;my_packet, NX_TCP_PACKET,
                                         NX_WAIT_FOREVER);

            /* Place "Hello_and_Goodbye" in the packet. */
            nx_packet_data_append(my_packet, "Hello_and_Goodbye",
                                  sizeof("Hello_and_Goodbye"),
                                  &amp;my_pool, NX_WAIT_FOREVER);

            /* Send "Hello_and_Goodbye" to client. */
            nx_tcp_socket_send(&amp;server_socket, my_packet, 200);

            /* Check for an error. */
            if (status)
            {
               /* Error, release the packet. */
               nx_packet_release(my_packet);
            }

            /* Now disconnect the server socket from the client. */
            nx_tcp_socket_disconnect(&amp;server_socket, 200);
         }

         /* Unaccept the server socket. Note that unaccept is called
            even if disconnect or accept fails. */
         nx_tcp_server_socket_unaccept(&amp;server_socket);

         /* Setup server socket for listening with this socket
            again. */
         nx_tcp_server_socket_relisten(&amp;my_ip, 12, &amp;server_socket);
     }

     /* We are now done so unlisten on server port 12. */
     nx_tcp_server_socket_unlisten(&amp;my_ip, 12);

     /* Delete the server socket. */
     nx_tcp_socket_delete(&amp;server_socket);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_88">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_server_socket_listen">nx_tcp_server_socket_listen</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable listening for client connection on TCP port</p>
</div>
<div class="sect2">
<h3 id="_prototype_89">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_server_socket_listen(
    NX_IP *ip_ptr, UINT port,
    NX_TCP_SOCKET *socket_ptr,
    UINT listen_queue_size,
    VOID (*listen_callback)(NX_TCP_SOCKET *socket_ptr, UINT port));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_89">Description</h3>
<div class="paragraph">
<p>This service enables listening for a client connection request on the specified TCP port. When a client connection request is received, the supplied server socket is bound to the specified port and the supplied listen callback function is called.</p>
</div>
<div class="paragraph">
<p>The listen callback routine&#8217;s processing is completely up to the application. It may contain logic to wake up an application thread that subsequently performs an accept operation. If the application already has a thread suspended on accept processing for this socket, the listen callback routine may not be needed.</p>
</div>
<div class="paragraph">
<p>If the application wishes to handle additional client connections on the same port, the <strong><em>nx_tcp_server_socket_relisten</em></strong> must be called with an available socket (a socket in the CLOSED state) for the next connection. Until the re-listen service is called, additional client connections are queued. When the maximum queue depth is exceeded, the oldest connection request is dropped in favor of queuing the new connection request. The maximum queue depth is specified by this service.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>Application callback routines are called from the internal IP helper thread</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_89">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>port</em>: Port number to listen on (1 through 0xFFFF).</p>
</li>
<li>
<p><em>socket_ptr</em>: Pointer to socket to use for the connection.</p>
</li>
<li>
<p><em>listen_queue_size</em>: Number of client connection requests that can be queued.</p>
</li>
<li>
<p><em>listen_callback</em>: Application function to call when the connection is received. If a NULL is specified, the listen callback feature is disabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_89">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful TCP port listen enable.</p>
</li>
<li>
<p><strong>NX_MAX_LISTEN</strong> (0x33) No more listen request structures are available. The constant NX_MAX_LISTEN_REQUESTS in <strong><em>nx_api.h</em></strong> defines how many active listen requests are possible.</p>
</li>
<li>
<p><strong>NX_NOT_CLOSED</strong> (0x35) The supplied server socket is not in a closed state.</p>
</li>
<li>
<p><strong>NX_ALREADY_BOUND</strong> (0x22) The supplied server socket is already bound to a port.</p>
</li>
<li>
<p><strong>NX_DUPLICATE_LISTEN</strong> (0x34) There is already an active listen request for this port.</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) Invalid port specified.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_89">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_89">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_88">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NX_PACKET_POOL my_pool;
NX_IP my_ip;
NX_TCP_SOCKET server_socket;

void port_12_connect_request(NX_TCP_SOCKET *socket_ptr, UINT port)
{
   /* Simply set the semaphore to wake up the server thread.*/
   tx_semaphore_put(&amp;port_12_semaphore);
}

void port_12_disconnect_request(NX_TCP_SOCKET *socket_ptr)
{
   /* The client has initiated a disconnect on this socket.
   This example doesn't use this callback. */
}

void port_12_server_thread_entry(ULONG id)
{
NX_PACKET *my_packet;
UINT status, i;
   /* Assuming that:
      "port_12_semaphore" has already been created with an
      initial count of 0 "my_ip" has already been created
      and the link is enabled "my_pool" packet pool has already
      been created.
   */

   /* Create the server socket. */
   nx_tcp_socket_create(&amp;my_ip, &amp;server_socket, "Port 12 Server
                        Socket",
                        NX_IP_NORMAL, NX_FRAGMENT_OKAY,
                        NX_IP_TIME_TO_LIVE, 100,
                        NX_NULL, port_12_disconnect_request);

   /* Setup server listening on port 12. */
   nx_tcp_server_socket_listen(&amp;my_ip, 12, &amp;server_socket, 5,
                               port_12_connect_request);

   /* Loop to process 5 server connections, sending
      "Hello_and_Goodbye" to
      each client and then disconnecting. */
   for (i = 0; i &lt; 5; i++)
   {

        /* Get the semaphore that indicates a client connection
           request is present. */
        tx_semaphore_get(&amp;port_12_semaphore, TX_WAIT_FOREVER);

        /* Wait for 200 ticks for the client socket connection
           to complete. */
        status = nx_tcp_server_socket_accept(&amp;server_socket, 200);

        /* Check for a successful connection. */
           if (status == NX_SUCCESS)
        {

              /* Allocate a packet for the "Hello_and_Goodbye"
                 message. */
              nx_packet_allocate(&amp;my_pool, &amp;my_packet, NX_TCP_PACKET,
                                 NX_WAIT_FOREVER);

              /* Place "Hello_and_Goodbye" in the packet. */
              nx_packet_data_append(my_packet, "Hello_and_Goodbye",
                                    sizeof("Hello_and_Goodbye"),
                                    &amp;my_pool,
                                    NX_WAIT_FOREVER);

             /* Send "Hello_and_Goodbye" to client. */
             nx_tcp_socket_send(&amp;server_socket, my_packet, 200);

             /* Check for an error. */
             if (status)
             {
                /* Error, release the packet. */
                nx_packet_release(my_packet);
             }

            /* Now disconnect the server socket from the client. */
            nx_tcp_socket_disconnect(&amp;server_socket, 200);
         }
         /* Unaccept the server socket. Note that unaccept is called
            even if disconnect or accept fails. */
         nx_tcp_server_socket_unaccept(&amp;server_socket);

         /* Setup server socket for listening with this socket
         again. */
         nx_tcp_server_socket_relisten(&amp;my_ip, 12, &amp;server_socket);
     }
     /* We are now done so unlisten on server port 12. */
     nx_tcp_server_socket_unlisten(&amp;my_ip, 12);
     /* Delete the server socket. */
     nx_tcp_socket_delete(&amp;server_socket);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_89">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_server_socket_relisten">nx_tcp_server_socket_relisten</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Re-listen for client connection on TCP port</p>
</div>
<div class="sect2">
<h3 id="_prototype_90">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_server_socket_relisten(
    NX_IP *ip_ptr,
    UINT port,
    NX_TCP_SOCKET *socket_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_90">Description</h3>
<div class="paragraph">
<p>This service is called after a connection has been received on a port that was setup previously for listening. The main purpose of this service is to provide a new server socket for the next client connection. If a connection request is queued, the connection will be processed immediately during this service call.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>The same callback routine specified by the original listen request is also called when a connection is present for this new server socket</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_90">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>port</em>: Port number to re-listen on (1 through 0xFFFF).</p>
</li>
<li>
<p><em>socket_ptr</em>: Socket to use for the next client connection.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_90">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful TCP port re-listen.</p>
</li>
<li>
<p><strong>NX_NOT_CLOSED</strong> (0x35) The supplied server socket is not in a closed state.</p>
</li>
<li>
<p><strong>NX_ALREADY_BOUND</strong> (0x22) The supplied server socket is already bound to a port.</p>
</li>
<li>
<p><strong>NX_INVALID_RELISTEN</strong> (0x47) There is already a valid socket pointer for this port or the port specified does not have a listen request active.</p>
</li>
<li>
<p><strong>NX_CONNECTION_PENDING</strong> (0x48) Same as NX_SUCCESS, except there was a queued connection request and it was processed during this call.</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) Invalid port specified.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or listen callback pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_90">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_90">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_89">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NX_PACKET_POOL my_pool;
NX_IP my_ip;
NX_TCP_SOCKET server_socket;

void port_12_connect_request(NX_TCP_SOCKET *socket_ptr, UINT port)
{

   /* Simply set the semaphore to wake up the server thread.*/
   tx_semaphore_put(&amp;port_12_semaphore);
}

void port_12_disconnect_request(NX_TCP_SOCKET *socket_ptr)
{
   /* The client has initiated a disconnect on this socket. This
      example doesn't use this callback. */
}

void port_12_server_thread_entry(ULONG id)
{

NX_PACKET *my_packet;
UINT status, i;

   /* Assuming that:
     "port_12_semaphore" has already been created with an initial
     count of 0.
    "my_ip" has already been created and the link is enabled.
    "my_pool" packet pool has already been created. */

   /* Create the server socket. */
   nx_tcp_socket_create(&amp;my_ip, &amp;server_socket, "Port 12 Server Socket",
                                 NX_IP_NORMAL, NX_FRAGMENT_OKAY,
                                 NX_IP_TIME_TO_LIVE, 100,
                                 NX_NULL, port_12_disconnect_request);

   /* Setup server listening on port 12. */
   nx_tcp_server_socket_listen(&amp;my_ip, 12, &amp;server_socket, 5,
                               port_12_connect_request);

   /* Loop to process 5 server connections, sending
      "Hello_and_Goodbye" to each client then disconnecting. */
   for (i = 0; i &lt; 5; i++)
   {

       /* Get the semaphore that indicates a client connection
          request is present. */
       tx_semaphore_get(&amp;port_12_semaphore, TX_WAIT_FOREVER);

       /* Wait for 200 ticks for the client socket connection to
          complete. */
       status = nx_tcp_server_socket_accept(&amp;server_socket, 200);

       /* Check for a successful connection. */
          if (status == NX_SUCCESS)
       {

             /* Allocate a packet for the "Hello_and_Goodbye"
                message. */
             nx_packet_allocate(&amp;my_pool, &amp;my_packet, NX_TCP_PACKET,
                                NX_WAIT_FOREVER);

             /* Place "Hello_and_Goodbye" in the packet. */
             nx_packet_data_append(my_packet, "Hello_and_Goodbye",
                                   sizeof("Hello_and_Goodbye"),
                                   &amp;my_pool, NX_WAIT_FOREVER);

             /* Send "Hello_and_Goodbye" to client. */
             nx_tcp_socket_send(&amp;server_socket, my_packet, 200);

             /* Check for an error. */
             if (status)
             {

                /* Error, release the packet. */
                nx_packet_release(my_packet);
             }

             /* Now disconnect the server socket from the client. */
             nx_tcp_socket_disconnect(&amp;server_socket, 200);
         }

         /* Unaccept the server socket. Note that unaccept is
            called even if disconnect or accept fails. */
         nx_tcp_server_socket_unaccept(&amp;server_socket);

         /* Setup server socket for listening with this socket
            again. */
         nx_tcp_server_socket_relisten(&amp;my_ip, 12, &amp;server_socket);
     }

     /* We are now done so unlisten on server port 12. */
     nx_tcp_server_socket_unlisten(&amp;my_ip, 12);

     /* Delete the server socket. */
     nx_tcp_socket_delete(&amp;server_socket);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_90">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_server_socket_unaccept">nx_tcp_server_socket_unaccept</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Remove socket association with listening port</p>
</div>
<div class="sect2">
<h3 id="_prototype_91">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_server_socket_unaccept(NX_TCP_SOCKET *socket_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_91">Description</h3>
<div class="paragraph">
<p>This service removes the association between this server socket and the specified server port. The application must call this service after a disconnection or after an unsuccessful accept call.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_91">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously setup server socket instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_91">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful server socket unaccept.</p>
</li>
<li>
<p><strong>NX_NOT_LISTEN_STATE</strong> (0x36) Server socket is in an improper state, and is probably not disconnected.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_91">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_91">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_90">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NX_PACKET_POOL        my_pool;
NX_IP                 my_ip;
NX_TCP_SOCKET         server_socket;
void port_12_connect_request(NX_TCP_SOCKET *socket_ptr, UINT port)
{

   /* Simply set the semaphore to wake up the server thread. */
   tx_semaphore_put(&amp;port_12_semaphore);
}

void port_12_disconnect_request(NX_TCP_SOCKET *socket_ptr)
{
   /* The client has initiated a disconnect on this socket. This example
   doesn't use this callback. */
}

void port_12_server_thread_entry(ULONG id)
{

NX_PACKET  *my_packet;
UINT       status, i;

   /* Assuming that:
     "port_12_semaphore" has already been created with an initial count
      of 0 "my_ip" has already been created and the link is enabled
     "my_pool" packet pool has already been created
   */

    /* Create the server socket. */
    nx_tcp_socket_create(&amp;my_ip, &amp;server_socket, "Port 12 Server
                         Socket",NX_IP_NORMAL, NX_FRAGMENT_OKAY,
                         NX_IP_TIME_TO_LIVE, 100,NX_NULL,
                         port_12_disconnect_request);

    /* Setup server listening on port 12. */
    nx_tcp_server_socket_listen(&amp;my_ip, 12, &amp;server_socket, 5,
                                port_12_connect_request);

    /* Loop to process 5 server connections, sending "Hello_and_Goodbye"
       to
       each client and then disconnecting. */
    for (i = 0; i &lt; 5; i++)
    {

        /* Get the semaphore that indicates a client connection request
           is present. */
        tx_semaphore_get(&amp;port_12_semaphore, TX_WAIT_FOREVER);

        /* Wait for 200 ticks for the client socket connection to
           complete.*/
        status = nx_tcp_server_socket_accept(&amp;server_socket, 200);

       /* Check for a successful connection. */
          if (status == NX_SUCCESS)
       {
             /* Allocate a packet for the "Hello_and_Goodbye" message. */
             nx_packet_allocate(&amp;my_pool, &amp;my_packet, NX_TCP_PACKET,
                                NX_WAIT_FOREVER);

             /* Place "Hello_and_Goodbye" in the packet. */
             nx_packet_data_append(my_packet,
                      "Hello_and_Goodbye",sizeof("Hello_and_Goodbye"),
                      &amp;my_pool, NX_WAIT_FOREVER);

             /* Send "Hello_and_Goodbye" to client. */
             nx_tcp_socket_send(&amp;server_socket, my_packet, 200);

             /* Check for an error. */
             if (status)
             {

                /* Error, release the packet. */
                nx_packet_release(my_packet);
             }

             /* Now disconnect the server socket from the client. */
             nx_tcp_socket_disconnect(&amp;server_socket, 200);
       }

       /* Unaccept the server socket. Note that unaccept is called even
          if disconnect or accept fails. */
       nx_tcp_server_socket_unaccept(&amp;server_socket);

      /* Setup server socket for listening with this socket again. */
      nx_tcp_server_socket_relisten(&amp;my_ip, 12, &amp;server_socket);
    }

    /* We are now done so unlisten on server port 12. */
    nx_tcp_server_socket_unlisten(&amp;my_ip, 12);

    /* Delete the server socket. */
    nx_tcp_socket_delete(&amp;server_socket);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_91">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_server_socket_unlisten">nx_tcp_server_socket_unlisten</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Disable listening for client connection on TCP port</p>
</div>
<div class="sect2">
<h3 id="_prototype_92">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_server_socket_unlisten(
    NX_IP *ip_ptr,
    UINT port);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_92">Description</h3>
<div class="paragraph">
<p>This service disables listening for a client connection request on the specified TCP port.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_92">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>port</em>: Number of port to disable listening (0 through 0xFFFF).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_92">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful TCP listen disable.</p>
</li>
<li>
<p><strong>NX_ENTRY_NOT_FOUND</strong> (0x16) Listening was not enabled for the specified port.</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) Invalid port specified.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_92">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_92">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_91">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NX_PACKET_POOL       my_pool;
NX_IP                my_ip;
NX_TCP_SOCKET        server_socket;

void port_12_connect_request(NX_TCP_SOCKET *socket_ptr, UINT port)
{

     /* Simply set the semaphore to wake up the server thread. */
     tx_semaphore_put(&amp;port_12_semaphore);
}

void port_12_disconnect_request(NX_TCP_SOCKET *socket_ptr)
{

     /* The client has initiated a disconnect on this socket. This example
        doesn't use this callback.*/
}

void port_12_server_thread_entry(ULONG id)
{

NX_PACKET *my_packet;
UINT status, i;

     /* Assuming that:
       "port_12_semaphore" has already been created with an initial count
        of 0 "my_ip" has already been created and the link is enabled
       "my_pool" packet pool has already been created
     */

     /* Create the server socket. */
     nx_tcp_socket_create(&amp;my_ip, &amp;server_socket, "Port 12 Server Socket",
                          NX_IP_NORMAL, NX_FRAGMENT_OKAY,
                          NX_IP_TIME_TO_LIVE, 100,
                          NX_NULL, port_12_disconnect_request);

     /* Setup server listening on port 12. */
     nx_tcp_server_socket_listen(&amp;my_ip, 12, &amp;server_socket, 5,
                                 port_12_connect_request);

     /* Loop to process 5 server connections, sending "Hello_and_Goodbye" to
        each client and then disconnecting. */
     for (i = 0; i &lt; 5; i++)
     {

         /* Get the semaphore that indicates a client connection request is
            present. */
         tx_semaphore_get(&amp;port_12_semaphore, TX_WAIT_FOREVER);

         /* Wait for 200 ticks for the client socket connection to complete.*/
         status = nx_tcp_server_socket_accept(&amp;server_socket, 200);

         /* Check for a successful connection. */
         if (status == NX_SUCCESS)
         {

             /* Allocate a packet for the "Hello_and_Goodbye" message. */
             nx_packet_allocate(&amp;my_pool, &amp;my_packet, NX_TCP_PACKET,
                                NX_WAIT_FOREVER);

             /* Place "Hello_and_Goodbye" in the packet. */
             nx_packet_data_append(my_packet, "Hello_and_Goodbye",
                                   sizeof("Hello_and_Goodbye"), &amp;my_pool,
                                   NX_WAIT_FOREVER);

             /* Send "Hello_and_Goodbye" to client. */
             nx_tcp_socket_send(&amp;server_socket, my_packet, 200);

             /* Check for an error. */
             if (status)
             {

                /* Error, release the packet. */
                nx_packet_release(my_packet);
             }

             /* Now disconnect the server socket from the client. */
             nx_tcp_socket_disconnect(&amp;server_socket, 200);
          }

          /* Unaccept the server socket. Note that unaccept is called even if
             disconnect or accept fails. */
          nx_tcp_server_socket_unaccept(&amp;server_socket);

          /* Setup server socket for listening with this socket again. */
          nx_tcp_server_socket_relisten(&amp;my_ip, 12, &amp;server_socket);
     }

     /* We are now done so unlisten on server port 12. */
     nx_tcp_server_socket_unlisten(&amp;my_ip, 12);

     /* Delete the server socket. */
     nx_tcp_socket_delete(&amp;server_socket);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_92">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_bytes_available">nx_tcp_socket_bytes_available</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieves number of bytes available for retrieval</p>
</div>
<div class="sect2">
<h3 id="_prototype_93">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_bytes_available(
    NX_TCP_SOCKET *socket_ptr,
    ULONG *bytes_available);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_93">Description</h3>
<div class="paragraph">
<p>This service obtains the number of bytes available for retrieval in the specified TCP socket. Note that the TCP socket must already be connected.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_93">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created and connected TCP socket.</p>
</li>
<li>
<p><em>bytes_available</em>: Pointer to destination for bytes available.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_93">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Service executes successfully. Number of bytes available for read is returned to the caller.</p>
</li>
<li>
<p><strong>NX_NOT_CONNECTED</strong> (0x38) Socket is not in a connected state.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointers.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP is not enabled.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_93">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_93">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_92">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Get the bytes available for retrieval on the specified socket. */
status = nx_tcp_socket_bytes_available(&amp;my_socket,&amp;bytes_available);

/* Is status = NX_SUCCESS, the available bytes is returned in
   bytes_available. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_93">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_create">nx_tcp_socket_create</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create TCP client or server socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_94">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_create(
    NX_IP *ip_ptr,
    NX_TCP_SOCKET *socket_ptr,
    CHAR *name,
    ULONG type_of_service,
    ULONG fragment,
    UINT time_to_live,
    ULONG window_size,
    VOID (*urgent_data_callback)(NX_TCP_SOCKET *socket_ptr),
    VOID (*disconnect_callback)(NX_TCP_SOCKET *socket_ptr));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_94">Description</h3>
<div class="paragraph">
<p>This service creates a TCP client or server socket for the specified IP instance.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[!NOTE]<br>
<em>Application callback routines are called from the thread associated with this IP instance</em>.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_94">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>socket_ptr</em>: Pointer to new TCP socket control block.</p>
</li>
<li>
<p><em>name</em>: Application name for this TCP socket.</p>
</li>
<li>
<p><em>type_of_service</em>: Defines the type of service for the transmission, legal values are as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_IP_NORMAL</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_IP_MIN_DELAY</strong> (0x00100000)</p>
</li>
<li>
<p><strong>NX_IP_MAX_DATA</strong> (0x00080000)</p>
</li>
<li>
<p><strong>NX_IP_MAX_RELIABLE</strong> (0x00040000)</p>
</li>
<li>
<p><strong>NX_IP_MIN_COST</strong> (0x00020000)</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>fragment</em>: Specifies whether or not IP fragmenting is allowed. <strong>If NX_FRAGMENT_OKAY</strong> (0x0) is specified, IP fragmenting is allowed. If <strong>NX_DONT_FRAGMENT</strong> (0x4000) is specified, IP fragmenting is disabled.</p>
</li>
<li>
<p><em>time_to_live</em>: Specifies the 8-bit value that defines how many routers this packet can pass before being thrown away. The default value is specified by <strong>NX_IP_TIME_TO_LIVE</strong>.</p>
</li>
<li>
<p><strong>window_size</strong>* Defines the maximum number of bytes allowed in the receive queue for this socket</p>
</li>
<li>
<p><strong>urgent_data_callback</strong>* Application function that is called whenever urgent data is detected in the receive stream. If this value is NX_NULL, urgent data is ignored.</p>
</li>
<li>
<p><strong>disconnect_callback</strong>* Application function that is called whenever a disconnect is issued by the socket at the other end of the connection. If this value is NX_NULL, the disconnect callback function is disabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_94">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful TCP client socket create.</p>
</li>
<li>
<p><strong>NX_OPTION_ERROR</strong> (0x0A) Invalid type-of-service, fragment, invalid window size, or time-tolive option.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_94">Allowed From</h3>
<div class="paragraph">
<p>Initialization and Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_94">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_93">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Create a TCP client socket on the previously created IP instance,
   with normal delivery, IP fragmentation enabled, 0x80 time to
   live, a 200-byte receive window, no urgent callback routine, and
   the "client_disconnect" routine to handle disconnection initiated
   from the other end of the connection. */
status = nx_tcp_socket_create(&amp;ip_0, &amp;client_socket,
                             "Client Socket",
                             NX_IP_NORMAL, NX_FRAGMENT_OKAY,
                             0x80, 200, NX_NULL
                             client_disconnect);

/* If status is NX_SUCCESS, the client socket is created and ready
   to be bound. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_94">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_delete">nx_tcp_socket_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Delete TCP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_95">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_delete(NX_TCP_SOCKET *socket_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_95">Description</h3>
<div class="paragraph">
<p>This service deletes a previously created TCP socket. If the socket is still bound or connected, the service returns an error code.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_95">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Previously created TCP socket</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_95">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket delete.</p>
</li>
<li>
<p><strong>NX_NOT_CREATED</strong> (0x27) Socket was not created.</p>
</li>
<li>
<p><strong>NX_STILL_BOUND</strong> (0x42) Socket is still bound.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_95">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_95">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_94">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Delete a previously created TCP client socket. */
status = nx_tcp_socket_delete(&amp;client_socket);

/* If status is NX_SUCCESS, the client socket is deleted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_95">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_disconnect">nx_tcp_socket_disconnect</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Disconnect client and server socket connections</p>
</div>
<div class="sect2">
<h3 id="_prototype_96">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_disconnect(
    NX_TCP_SOCKET *socket_ptr,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_96">Description</h3>
<div class="paragraph">
<p>This service disconnects an established client or server socket connection. A disconnect of a server socket should be followed by an unaccept request, while a client socket that is disconnected is left in a state ready for another connection request. If the disconnect process cannot finish immediately, the service suspends according to the supplied wait option.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_96">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously connected client or server socket instance.</p>
</li>
<li>
<p><strong>wait_option</strong>* Defines how the service behaves while the disconnection is in progress. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_96">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket disconnect.</p>
</li>
<li>
<p><strong>NX_NOT_CONNECTED</strong> (0x38) Specified socket is not connected.</p>
</li>
<li>
<p><strong>NX_IN_PROGRESS</strong> (0x37) Disconnect is in progress, no wait was specified.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_96">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_96">Preemption Possible</h3>
<div class="paragraph">
<p>Yes</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_95">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Disconnect from a previously established connection and wait a
   maximum of 400 timer ticks. */
status = nx_tcp_socket_disconnect(&amp;client_socket, 400);

/* If status is NX_SUCCESS, the previously connected socket (either
   as a result of the client socket connect or the server accept) is
   disconnected. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_96">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_disconnect_complete_notify">nx_tcp_socket_disconnect_complete_notify</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Install TCP disconnect complete notify callback function</p>
</div>
<div class="sect2">
<h3 id="_prototype_97">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_disconnect_complete_notify(
    NX_TCP_SOCKET *socket_ptr,
    VOID (*tcp_disconnect_complete_notify)(NX_TCP_SOCKET *socket_ptr));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_97">Description</h3>
<div class="paragraph">
<p>This service registers a callback function which is invoked after a socket disconnect operation is completed. The TCP socket disconnect complete callback function is available if NetX Duo is built with the option <strong><em>NX_ENABLE_EXTENDED_NOTIFY_SUPPORT</em></strong> defined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_97">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously connected client or server socket instance.</p>
</li>
<li>
<p><strong>tcp_disconnect_complete_notify</strong>* The callback function to be installed.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_97">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully registered the callback function.</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) The extended notify feature is not built into the NetX Duo library NX_PTR_ERROR** (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP feature is not enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_97">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_97">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_96">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Install the disconnect complete notify callback function. */
status = nx_tcp_socket_disconnect_complete_notify(&amp;client_socket,
                                                  callback);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_97">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_establish_notify</p>
</li>
<li>
<p>nx_tcp_socket_mss_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_peer_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_set</p>
</li>
<li>
<p>nx_tcp_socket_peer_info_get</p>
</li>
<li>
<p>nx_tcp_socket_queue_depth_notify_setnx_tcp_socket_receive_notify</p>
</li>
<li>
<p>nx_tcp_socket_timed_wait_callback</p>
</li>
<li>
<p>nx_tcp_socket_transmit_configure</p>
</li>
<li>
<p>nx_tcp_socket_window_update_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_establish_notify">nx_tcp_socket_establish_notify</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set TCP establish notify callback function</p>
</div>
<div class="sect2">
<h3 id="_prototype_98">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_establish_notify(
    NX_TCP_SOCKET *socket_ptr,
    VOID (*tcp_establish_notify)(NX_TCP_SOCKET *socket_ptr));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_98">Description</h3>
<div class="paragraph">
<p>This service registers a callback function, which is called after a TCP socket makes a connection. The TCP socket establish callback function is available if NetX Duo is built with the option <strong><em>NX_ENABLE_EXTENDED_NOTIFY_SUPPORT</em></strong> defined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_98">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously connected client or server socket instance.</p>
</li>
<li>
<p><strong>tcp_establish_notify</strong>* Callback function invoked after a TCP connection is established.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_98">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully sets the notify function.</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) The extended notify feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP has not been enabled by the application.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_98">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_98">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_97">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Set the function pointer "callback" as the notify function NetX
   Duo will call when the connection is in the established state. */
status = nx_tcp_socket_establish_notify(&amp;client_socket, callback);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_98">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_disconnect_complete_notify</p>
</li>
<li>
<p>nx_tcp_socket_mss_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_peer_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_set</p>
</li>
<li>
<p>nx_tcp_socket_peer_info_get</p>
</li>
<li>
<p>nx_tcp_socket_queue_depth_notify_set</p>
</li>
<li>
<p>nx_tcp_socket_receive_notify</p>
</li>
<li>
<p>nx_tcp_socket_timed_wait_callback</p>
</li>
<li>
<p>nx_tcp_socket_transmit_configure</p>
</li>
<li>
<p>nx_tcp_socket_window_update_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_info_get">nx_tcp_socket_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve information about TCP socket activities</p>
</div>
<div class="sect2">
<h3 id="_prototype_99">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_info_get(
    NX_TCP_SOCKET *socket_ptr,
    ULONG *tcp_packets_sent,
    ULONG *tcp_bytes_sent,
    ULONG *tcp_packets_received,
    ULONG *tcp_bytes_received,
    ULONG *tcp_retransmit_packets,
    ULONG *tcp_packets_queued,
    ULONG *tcp_checksum_errors,
    ULONG *tcp_socket_state,
    ULONG *tcp_transmit_queue_depth,
    ULONG *tcp_transmit_window,
    ULONG *tcp_receive_window);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_99">Description</h3>
<div class="paragraph">
<p>This service retrieves information about TCP socket activities for the specified TCP socket instance.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[!NOTE]<br>
<em>If a destination pointer is NX_NULL, that particular information is not returned to the caller</em>.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_99">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously created TCP socket instance.</p>
</li>
<li>
<p><strong>tcp_packets_sent</strong>* Pointer to destination for the total number of TCP packets sent on socket.</p>
</li>
<li>
<p><strong>tcp_bytes_sent</strong>* Pointer to destination for the total number of TCP bytes sent on socket.</p>
</li>
<li>
<p><strong>tcp_packets_received</strong>* Pointer to destination of the total number of TCP packets received on socket.</p>
</li>
<li>
<p><strong>tcp_bytes_received</strong>* Pointer to destination of the total number of TCP bytes received on socket.</p>
</li>
<li>
<p><strong>tcp_retransmit_packets</strong>* Pointer to destination of the total number of TCP packet retransmissions.</p>
</li>
<li>
<p><strong>tcp_packets_queued</strong>* Pointer to destination of the total number of queued TCP packets on socket.</p>
</li>
<li>
<p><strong>tcp_checksum_errors</strong>* Pointer to destination of the total number of TCP packets with checksum errors on socket.</p>
</li>
<li>
<p><strong>tcp_socket_state</strong>* Pointer to destination of the socket&#8217;s current state.</p>
</li>
<li>
<p><strong>tcp_transmit_queue_depth</strong>* Pointer to destination of the total number of transmit packets still queued waiting for ACK.</p>
</li>
<li>
<p><strong>tcp_transmit_window</strong>* Pointer to destination of the current transmit window size.</p>
</li>
<li>
<p><strong>tcp_receive_window</strong>* Pointer to destination of the current receive window size.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_99">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful TCP socket information retrieval.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_99">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_99">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_98">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Retrieve TCP socket information from previously created
   socket_0.*/
status = nx_tcp_socket_info_get(&amp;socket_0,
                                &amp;tcp_packets_sent,
                                &amp;tcp_bytes_sent,
                                &amp;tcp_packets_received,
                                &amp;tcp_bytes_received,
                                &amp;tcp_retransmit_packets,
                                &amp;tcp_packets_queued,
                                &amp;tcp_checksum_errors,
                                &amp;tcp_socket_state,
                                &amp;tcp_transmit_queue_depth,
                                &amp;tcp_transmit_window,
                                &amp;tcp_receive_window);

/* If status is NX_SUCCESS, TCP socket information was retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_99">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_mss_get">nx_tcp_socket_mss_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Get MSS of socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_100">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_mss_get(
    NX_TCP_SOCKET *socket_ptr,
    ULONG *mss);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_100">Description</h3>
<div class="paragraph">
<p>This service retrieves the specified socket&#8217;s local Maximum Segment Size (MSS).</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_100">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously created socket.</p>
</li>
<li>
<p><strong>mss</strong>* Destination for returning MSS.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_100">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful MSS get.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket or MSS destination pointer.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP is not enabled.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Caller is not a thread or initialization.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_100">Allowed From</h3>
<div class="paragraph">
<p>Initialization and threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_100">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_99">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Get the MSS for the socket "my_socket". */
status = nx_tcp_socket_mss_get(&amp;my_socket, &amp;mss_value);

/* If status is NX_SUCCESS, the "mss_value" variable contains the
   socket's current MSS value. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_100">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_disconnect_complete_notify</p>
</li>
<li>
<p>nx_tcp_socket_establish_notify</p>
</li>
<li>
<p>nx_tcp_socket_mss_peer_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_set</p>
</li>
<li>
<p>nx_tcp_socket_peer_info_get</p>
</li>
<li>
<p>nx_tcp_socket_queue_depth_notify_set</p>
</li>
<li>
<p>nx_tcp_socket_receive_notify</p>
</li>
<li>
<p>nx_tcp_socket_timed_wait_callback</p>
</li>
<li>
<p>nx_tcp_socket_transmit_configure</p>
</li>
<li>
<p>nx_tcp_socket_window_update_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_mss_peer_get">nx_tcp_socket_mss_peer_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Get MSS of the peer TCP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_101">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_mss_peer_get(
    NX_TCP_SOCKET *socket_ptr,
    ULONG *mss);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_101">Description</h3>
<div class="paragraph">
<p>This service retrieves the Maximum Segment Size (MSS) advertised by the peer socket.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_101">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously created and connected socket.</p>
</li>
<li>
<p><strong>mss</strong>* Destination for returning the MSS.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_101">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful peer MSS get.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket or MSS destination pointer.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP is not enabled.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Caller is not a thread or initialization.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_101">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_101">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_100">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Get the MSS of the connected peer to the socket "my_socket". */
status = nx_tcp_socket_mss_peer_get(&amp;my_socket, &amp;mss_value);

/* If status is NX_SUCCESS, the "mss_value" variable contains the
   socket peer's advertised MSS value. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_101">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_disconnect_complete_notify</p>
</li>
<li>
<p>nx_tcp_socket_establish_notify</p>
</li>
<li>
<p>nx_tcp_socket_mss_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_set</p>
</li>
<li>
<p>nx_tcp_socket_peer_info_get</p>
</li>
<li>
<p>nx_tcp_socket_queue_depth_notify_set</p>
</li>
<li>
<p>nx_tcp_socket_receive_notify</p>
</li>
<li>
<p>nx_tcp_socket_timed_wait_callback</p>
</li>
<li>
<p>nx_tcp_socket_transmit_configure</p>
</li>
<li>
<p>nx_tcp_socket_window_update_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_mss_set">nx_tcp_socket_mss_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set MSS of socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_102">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_mss_set(
    NX_TCP_SOCKET *socket_ptr,
    ULONG mss);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_102">Description</h3>
<div class="paragraph">
<p>This service sets the specified socket&#8217;s Maximum Segment Size (MSS). Note the MSS value must be within the network interface IP MTU, allowing room for IP and TCP headers.</p>
</div>
<div class="paragraph">
<p>This service should be used before a TCP socket starts the connection process. If the service is used after a TCP connection is established, the new value has no effect on the connection.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_102">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously created socket.</p>
</li>
<li>
<p><strong>mss</strong>* Value of MSS to set.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_102">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful MSS set.</p>
</li>
<li>
<p><strong>NX_SIZE_ERROR</strong> (0x09) Specified MSS value is too large.</p>
</li>
<li>
<p><strong>NX_NOT_CONNECTED</strong> (0x38) TCP connection has not been established</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP is not enabled.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Caller is not a thread or initialization.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_102">Allowed From</h3>
<div class="paragraph">
<p>Initialization and threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_102">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_101">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Set the MSS of the socket "my_socket" to 1000 bytes. */
status = nx_tcp_socket_mss_set(&amp;my_socket, 1000);

/* If status is NX_SUCCESS, the MSS of "my_socket" is 1000 bytes. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_102">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_disconnect_complete_notify</p>
</li>
<li>
<p>nx_tcp_socket_establish_notify</p>
</li>
<li>
<p>nx_tcp_socket_mss_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_peer_get</p>
</li>
<li>
<p>nx_tcp_socket_peer_info_get</p>
</li>
<li>
<p>nx_tcp_socket_queue_depth_notify_set</p>
</li>
<li>
<p>nx_tcp_socket_receive_notify</p>
</li>
<li>
<p>nx_tcp_socket_timed_wait_callback</p>
</li>
<li>
<p>nx_tcp_socket_transmit_configure</p>
</li>
<li>
<p>nx_tcp_socket_window_update_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_peer_info_get">nx_tcp_socket_peer_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve information about peer TCP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_103">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_peer_info_get(
    NX_TCP_SOCKET *socket_ptr,
    ULONG *peer_ip_address,
    ULONG *peer_port);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_103">Description</h3>
<div class="paragraph">
<p>This service retrieves peer IP address and port information for the connected TCP socket over IPv4 network. The equivalent service that also supports IPv6 network is <strong><em>nxd_tcp_socket_peer_info_get.</em></strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_103">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously created TCP socket.</p>
</li>
<li>
<p><strong>peer_ip_address</strong>* Pointer to destination for peer IP address, in host byte order.</p>
</li>
<li>
<p><strong>peer_port</strong>* Pointer to destination for peer port number, in host byte order.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_103">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Service executes successfully. Peer IP address and port number are returned to the caller.</p>
</li>
<li>
<p><strong>NX_NOT_CONNECTED</strong> (0x38) Socket is not in a connected state.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointers.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP is not enabled.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_103">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_103">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_102">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Obtain peer IP address and port on the specified TCP socket. */
status = nx_tcp_socket_peer_info_get(&amp;my_socket, &amp;peer_ip_address,
                                     &amp;peer_port);

/* If status = NX_SUCCESS, the data was successfully obtained. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_103">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_disconnect_complete_notify</p>
</li>
<li>
<p>nx_tcp_socket_establish_notify</p>
</li>
<li>
<p>nx_tcp_socket_mss_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_peer_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_set</p>
</li>
<li>
<p>nx_tcp_socket_queue_depth_notify_set</p>
</li>
<li>
<p>nx_tcp_socket_receive_notify</p>
</li>
<li>
<p>nx_tcp_socket_timed_wait_callback</p>
</li>
<li>
<p>nx_tcp_socket_transmit_configure</p>
</li>
<li>
<p>nx_tcp_socket_window_update_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_queue_depth_notify_set">nx_tcp_socket_queue_depth_notify_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set the TCP transmit queue notify function</p>
</div>
<div class="sect2">
<h3 id="_prototype_104">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_queue_depth_notify_set(
              NX_TCP_SOCKET *socket_ptr,
              VOID(*tcp_socket_queue_depth_notify)(NX_TCP_SOCKET *));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_104">Description</h3>
<div class="paragraph">
<p>This service sets the transmit queue depth update notify function specified by the application, which is called whenever the specified socket determines that it has released packets from the transmit queue such that the queue depth is no longer exceeding its limit. If an application would be blocked on transmit due to queue depth, the callback function serves as a notification to the application that it may start transmitting again. This service is available only if the NetX Duo library is built with the option <strong><em>NX_ENABLE_TCP_QUEUE_DEPTH_UPDATE_NOTIFY</em></strong> defined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_104">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to the socket structure</p>
</li>
<li>
<p><strong>tcp_socket_queue_depth_notify</strong>* The notify function to be installed</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_104">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully installed the notify function</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) The TCP socket queue depth notify feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointer to the socket control block or the notify function</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP feature is not enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_104">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_104">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_103">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">VOID tcp_socket_queue_depth_notify(NX_TCP_SOCKET *socket_ptr)
{
   /* Notify the application to resume sending. */

}
/* Install the TCP transmit queue notify function .*/
status = nxd_tcp_socket_queue_depth_notify_set(&amp;tcp_socket,
                                  tcp_socket_queue_depth_notify);

/* If status == NX_SUCCESS, the callback function is successfully
   installed. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_104">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_disconnect_complete_notify</p>
</li>
<li>
<p>nx_tcp_socket_establish_notify</p>
</li>
<li>
<p>nx_tcp_socket_mss_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_peer_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_set</p>
</li>
<li>
<p>nx_tcp_socket_peer_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive_notify</p>
</li>
<li>
<p>nx_tcp_socket_timed_wait_callback</p>
</li>
<li>
<p>nx_tcp_socket_transmit_configure</p>
</li>
<li>
<p>nx_tcp_socket_window_update_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_receive">nx_tcp_socket_receive</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Receive data from TCP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_105">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_receive(
    NX_TCP_SOCKET *socket_ptr,
    NX_PACKET **packet_ptr,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_105">Description</h3>
<div class="paragraph">
<p>This service receives TCP data from the specified socket. If no data is queued on the specified socket, the caller suspends based on the supplied wait option.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<em>If NX_SUCCESS is returned, the application is responsible for releasing the received packet when it is no longer needed</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_105">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously created TCP socket instance.</p>
</li>
<li>
<p><strong>packet_ptr</strong>* Pointer to TCP packet pointer.</p>
</li>
<li>
<p><strong>wait_option</strong>* Defines how the service behaves if do data are currently queued on this socket. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_105">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket data receive.</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket is not bound yet.</p>
</li>
<li>
<p><strong>NX_NO_PACKET</strong> (0x01) No data received.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_NOT_CONNECTED</strong> (0x38) The socket is no longer connected.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket or return packet pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_105">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_105">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_104">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Receive a packet from the previously created and connected TCP
   client socket. If no packet is available, wait for 200 timer
   ticks before giving up. */
status = nx_tcp_socket_receive(&amp;client_socket, &amp;packet_ptr, 200);

/* If status is NX_SUCCESS, the received packet is pointed to by
   "packet_ptr". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_105">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_receive_notify">nx_tcp_socket_receive_notify</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Notify application of received packets</p>
</div>
<div class="sect2">
<h3 id="_prototype_106">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_receive_notify(
    NX_TCP_SOCKET *socket_ptr,
    VOID (*tcp_receive_notify)(NX_TCP_SOCKET *socket_ptr));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_106">Description</h3>
<div class="paragraph">
<p>This service configures the receive notify function pointer with the callback function specified by the application. This callback function is then called whenever one or more packets are received on the socket. If a NX_NULL pointer is supplied, the notify function is disabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_106">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to the TCP socket.</p>
</li>
<li>
<p><strong>tcp_receive_notify</strong>* Application callback function pointer that is called when one or more packets are received on the socket.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_106">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket receive notify.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP feature is not enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_106">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_106">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_105">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Setup a receive packet callback function for the "client_socket"
   socket. */
status = nx_tcp_socket_receive_notify(&amp;client_socket,
                                      my_receive_notify);

/* If status is NX_SUCCESS, NetX Duo will call the function named
   "my_receive_notify" whenever one or more packets are received for
   "client_socket". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_106">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_disconnect_complete_notify</p>
</li>
<li>
<p>nx_tcp_socket_establish_notify</p>
</li>
<li>
<p>nx_tcp_socket_mss_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_peer_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_set</p>
</li>
<li>
<p>nx_tcp_socket_peer_info_get</p>
</li>
<li>
<p>nx_tcp_socket_queue_depth_notify_set</p>
</li>
<li>
<p>nx_tcp_socket_timed_wait_callback</p>
</li>
<li>
<p>nx_tcp_socket_transmit_configure</p>
</li>
<li>
<p>nx_tcp_socket_window_update_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_send">nx_tcp_socket_send</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send data through a TCP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_107">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_send(
    NX_TCP_SOCKET *socket_ptr,
    NX_PACKET *packet_ptr,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_107">Description</h3>
<div class="paragraph">
<p>This service sends TCP data through a previously connected TCP socket. If the receiver&#8217;s last advertised window size is less than this request, the service optionally suspends based on the wait option specified. This service guarantees that no packet data larger than MSS is sent to the IP layer.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Unless an error is returned, the application should not release the packet after this call. Doing so will cause unpredictable results because the network driver will also try to release the packet after
transmission</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_107">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously connected TCP socket instance.</p>
</li>
<li>
<p><strong>packet_ptr</strong>* TCP data packet pointer.</p>
</li>
<li>
<p><strong>wait_option</strong>* Defines how the service behaves if the request is greater than the window size of the receiver. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_107">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket send.</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket was not bound to any port.</p>
</li>
<li>
<p><strong>NX_NO_INTERFACE_ADDRESS</strong> (0x50) No suitable outgoing interface found.</p>
</li>
<li>
<p><strong>NX_NOT_CONNECTED</strong> (0x38) Socket is no longer connected.</p>
</li>
<li>
<p><strong>NX_WINDOW_OVERFLOW</strong> (0x39) Request is greater than receiver&#8217;s advertised window size in bytes.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_INVALID_PACKET</strong> (0x12) Packet is not allocated.</p>
</li>
<li>
<p><strong>NX_TX_QUEUE_DEPTH</strong> (0x49) Maximum transmit queue depth has been reached.</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Packet append pointer is invalid.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Packet prepend pointer is invalid.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_107">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_107">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_106">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Send a packet out on the previously created and connected TCP
   socket. If the receive window on the other side of the connection
   is less than the packet size, wait 200 timer ticks before giving
   up. */
status = nx_tcp_socket_send(&amp;client_socket, packet_ptr, 200);

/* If status is NX_SUCCESS, the packet has been sent! */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_107">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_state_wait">nx_tcp_socket_state_wait</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Wait for TCP socket to enter specific state</p>
</div>
<div class="sect2">
<h3 id="_prototype_108">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_state_wait(
    NX_TCP_SOCKET *socket_ptr,
    UINT desired_state,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_108">Description</h3>
<div class="paragraph">
<p>This service waits for the socket to enter the desired state. If the socket is not in the desired state, the service suspends according to the supplied wait option.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_108">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously connected TCP socket instance.</p>
</li>
<li>
<p><strong>desired_state</strong>* Desired TCP state. Valid TCP socket states are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_TCP_CLOSED</strong> (0x01)</p>
</li>
<li>
<p><strong>NX_TCP_LISTEN_STATE</strong> (0x02)</p>
</li>
<li>
<p><strong>NX_TCP_SYN_SENT</strong> (0x03)</p>
</li>
<li>
<p><strong>NX_TCP_SYN_RECEIVED</strong> (0x04)</p>
</li>
<li>
<p><strong>NX_TCP_ESTABLISHED</strong> (0x05)</p>
</li>
<li>
<p><strong>NX_TCP_CLOSE_WAIT</strong> (0x06)</p>
</li>
<li>
<p><strong>NX_TCP_FIN_WAIT_1</strong> (0x07)</p>
</li>
<li>
<p><strong>NX_TCP_FIN_WAIT_2</strong> (0x08)</p>
</li>
<li>
<p><strong>NX_TCP_CLOSING</strong> (0x09)</p>
</li>
<li>
<p><strong>NX_TCP_TIMED_WAIT</strong> (0x0A)</p>
</li>
<li>
<p><strong>NX_TCP_LAST_ACK</strong> (0x0B)</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>wait_option</strong>* Defines how the service behaves if the requested state is not present. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFF)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_108">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful state wait.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_NOT_SUCCESSFUL</strong> (0x43) State not present within the specified wait time.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
<li>
<p><strong>NX_OPTION_ERROR</strong> (0x0A) The desired socket state is invalid.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_108">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_108">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_107">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Wait 300 timer ticks for the previously created socket to enter
   the established state in the TCP state machine. */
status = nx_tcp_socket_state_wait(&amp;client_socket,
                                  NX_TCP_ESTABLISHED, 300);

/* If status is NX_SUCCESS, the socket is now in the established
   state! */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_108">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_timed_wait_callback">nx_tcp_socket_timed_wait_callback</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Install callback for timed wait state</p>
</div>
<div class="sect2">
<h3 id="_prototype_109">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_timed_wait_callback(
    NX_TCP_SOCKET *socket_ptr,
    VOID (*tcp_timed_wait_callback)(NX_TCP_SOCKET *socket_ptr));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_109">Description</h3>
<div class="paragraph">
<p>This service registers a callback function which is invoked when the TCP socket is in timed wait state. To use this service, the NetX Duo library must be built with the option <strong><em>NX_ENABLE_EXTENDED_NOTIFY</em></strong> defined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_109">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously connected client or server socket instance.</p>
</li>
<li>
<p><strong>tcp_timed_wait_callback</strong>* The timed wait callback function</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_109">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully registers the callback function socket</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) NetX Duo library is built without the extended notify feature enabled.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP feature is not enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_109">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_109">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_108">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Install the timed wait callback function */
nx_tcp_socket_timed_wait_callback(&amp;client_socket, callback);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_109">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_disconnect_complete_notify</p>
</li>
<li>
<p>nx_tcp_socket_establish_notify</p>
</li>
<li>
<p>nx_tcp_socket_mss_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_peer_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_set</p>
</li>
<li>
<p>nx_tcp_socket_peer_info_get</p>
</li>
<li>
<p>nx_tcp_socket_queue_depth_notify_set</p>
</li>
<li>
<p>nx_tcp_socket_receive_notify</p>
</li>
<li>
<p>nx_tcp_socket_transmit_configure</p>
</li>
<li>
<p>nx_tcp_socket_window_update_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_transmit_configure">nx_tcp_socket_transmit_configure</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Configure socket&#8217;s transmit parameters</p>
</div>
<div class="sect2">
<h3 id="_prototype_110">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_transmit_configure(
    NX_TCP_SOCKET *socket_ptr,
    ULONG max_queue_depth,
    ULONG timeout,
    ULONG max_retries,
    ULONG timeout_shift);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_110">Description</h3>
<div class="paragraph">
<p>This service configures various transmit parameters of the specified TCP socket.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_110">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to the TCP socket.</p>
</li>
<li>
<p><strong>max_queue_depth</strong>* Maximum number of packets allowed to be queued for transmission.</p>
</li>
<li>
<p><strong>timeout</strong>* Number of ThreadX timer ticks an ACK is waited for before the packet is sent again.</p>
</li>
<li>
<p><strong>max_retries</strong>* Maximum number of retries allowed.</p>
</li>
<li>
<p><strong>timeout_shift</strong>* Value to shift the timeout for each subsequent retry. A value of 0, results in the same timeout between successive retries. A value of 1, doubles the timeout between retries.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_110">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful transmit socket configure.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_OPTION_ERROR</strong> (0x0a) Invalid queue depth option.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP feature is not enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_110">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_110">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_109">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Configure the "client_socket" for a maximum transmit queue depth of
   12, 100 tick timeouts, a maximum of 20 retries, and a timeout double
   on each successive retry. */
status = nx_tcp_socket_transmit_configure(&amp;client_socket,12,100,20,1);

/* If status is NX_SUCCESS, the socket's transmit retry has been
   configured. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_110">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_disconnect_complete_notify</p>
</li>
<li>
<p>nx_tcp_socket_establish_notify</p>
</li>
<li>
<p>nx_tcp_socket_mss_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_peer_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_set</p>
</li>
<li>
<p>nx_tcp_socket_peer_info_get</p>
</li>
<li>
<p>nx_tcp_socket_queue_depth_notify_set</p>
</li>
<li>
<p>nx_tcp_socket_receive_notify</p>
</li>
<li>
<p>nx_tcp_socket_timed_wait_callback</p>
</li>
<li>
<p>nx_tcp_socket_window_update_notify_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_tcp_socket_window_update_notify_set">nx_tcp_socket_window_update_notify_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Notify application of window size updates</p>
</div>
<div class="sect2">
<h3 id="_prototype_111">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_tcp_socket_window_update_notify_set(
    NX_TCP_SOCKET *socket_ptr,
    VOID (*tcp_window_update_notify)(NX_TCP_SOCKET *socket_ptr));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_111">Description</h3>
<div class="paragraph">
<p>This service installs a socket window update callback routine. This routine is called automatically whenever the specified socket receives a packet indicating an increase in the window size of the remote host.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_111">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously created TCP socket.</p>
</li>
<li>
<p><strong>tcp_window_update_notify</strong>* Callback routine to be called when the window size changes. A value of NULL disables the window change update.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_111">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Callback routine is installed on the socket.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointers.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP feature is not enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_111">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_111">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_110">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Set the function pointer to the windows update callback after creating the
   socket. */
status = nx_tcp_socket_window_update_notify_set(&amp;data_socket,
                                                my_windows_update_callback);

/* Define the window callback function in the host application. */
void my_windows_update_callback(&amp;data_socket)
{

/* Process update on increase TCP transmit socket window size. */
   return;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_111">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_disconnect_complete_notify</p>
</li>
<li>
<p>nx_tcp_socket_establish_notify</p>
</li>
<li>
<p>nx_tcp_socket_mss_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_peer_get</p>
</li>
<li>
<p>nx_tcp_socket_mss_set</p>
</li>
<li>
<p>nx_tcp_socket_peer_info_get</p>
</li>
<li>
<p>nx_tcp_socket_queue_depth_notify_set</p>
</li>
<li>
<p>nx_tcp_socket_receive_notify</p>
</li>
<li>
<p>nx_tcp_socket_timed_wait_callback</p>
</li>
<li>
<p>nx_tcp_socket_transmit_configure</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_enable">nx_udp_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable UDP component of NetX Duo</p>
</div>
<div class="sect2">
<h3 id="_prototype_112">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_enable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_112">Description</h3>
<div class="paragraph">
<p>This service enables the User Datagram Protocol (UDP) component of NetX Duo. After enabled, UDP datagrams may be sent and received by the application.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_112">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>ip_ptr</strong>* Pointer to previously created IP instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_112">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful UDP enable.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_ALREADY_ENABLED</strong> (0x15) This component has already been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_112">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_112">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_111">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Enable UDP on the previously created IP instance. */
status = nx_udp_enable(&amp;ip_0);

/* If status is NX_SUCCESS, UDP is now enabled on the specified IP
   instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_112">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_free_port_find">nx_udp_free_port_find</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Find next available UDP port</p>
</div>
<div class="sect2">
<h3 id="_prototype_113">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_free_port_find(
    NX_IP *ip_ptr,
    UINT port,
    UINT *free_port_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_113">Description</h3>
<div class="paragraph">
<p>This service looks for a free UDP port (unbound) starting from the application supplied port number. The search logic will wrap around if the search reaches the maximum port value of 0xFFFF. If the search is successful, the free port is returned in the variable pointed to by free_port_ptr.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>This service can be called from another thread and can have the same port returned. To prevent this race condition, the application may wish to place this service and the actual socket bind under the protection of a mutex</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_113">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>ip_ptr</strong>* Pointer to previously created IP instance.</p>
</li>
<li>
<p><strong>port</strong>* Port number to start search (1 through 0xFFFF).</p>
</li>
<li>
<p><strong>free_port_ptr</strong>* Pointer to the destination free port return variable.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_113">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful free port find.</p>
</li>
<li>
<p><strong>NX_NO_FREE_PORTS</strong> (0x45) No free ports found.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) Specified port number is invalid.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_113">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_113">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_112">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Locate a free UDP port, starting at port 12, on a previously
   created IP instance. */
status = nx_udp_free_port_find(&amp;ip_0, 12, &amp;free_port);

/* If status is NX_SUCCESS pointer, "free_port" identifies the next
   free UDP port on the IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_113">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_info_get">nx_udp_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve information about UDP activities</p>
</div>
<div class="sect2">
<h3 id="_prototype_114">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_info_get(
    NX_IP *ip_ptr,
    ULONG *udp_packets_sent,
    ULONG *udp_bytes_sent,
    ULONG *udp_packets_received,
    ULONG *udp_bytes_received,
    ULONG *udp_invalid_packets,
    ULONG *udp_receive_packets_dropped,
    ULONG *udp_checksum_errors);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_114">Description</h3>
<div class="paragraph">
<p>This service retrieves information about UDP activities for the specified IP instance.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If a destination pointer is NX_NULL, that particular information is not returned to the caller</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_114">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>ip_ptr</strong>* Pointer to previously created IP instance.</p>
</li>
<li>
<p><strong>udp_packets_sent</strong>* Pointer to destination for the total number of UDP packets sent.</p>
</li>
<li>
<p><strong>udp_bytes_sent</strong>* Pointer to destination for the total number of UDP bytes sent.</p>
</li>
<li>
<p><strong>udp_packets_received</strong>* Pointer to destination of the total number of UDP packets received.</p>
</li>
<li>
<p><strong>udp_bytes_received</strong>* Pointer to destination of the total number of UDP bytes received.</p>
</li>
<li>
<p><strong>udp_invalid_packets</strong>* Pointer to destination of the total number of invalid UDP packets.</p>
</li>
<li>
<p><strong>udp_receive_packets_dropped</strong>* Pointer to destination of the total number of UDP receive packets dropped.</p>
</li>
<li>
<p><strong>udp_checksum_errors</strong>* Pointer to destination of the total number of UDP packets with checksum errors.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_114">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful UDP information retrieval.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_114">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, and timers</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_114">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_113">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Retrieve UDP information from previously created IP Instance
   ip_0. */
status = nx_udp_info_get(&amp;ip_0, &amp;udp_packets_sent,
                         &amp;udp_bytes_sent,
                         &amp;udp_packets_received,
                         &amp;udp_bytes_received,
                         &amp;udp_invalid_packets,
                         &amp;udp_receive_packets_dropped,
                         &amp;udp_checksum_errors);

/* If status is NX_SUCCESS, UDP information was retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_114">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_packet_info_extract">nx_udp_packet_info_extract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Extract network parameters from UDP packet</p>
</div>
<div class="sect2">
<h3 id="_prototype_115">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_packet_info_extract(
    NX_PACKET *packet_ptr,
    ULONG *ip_address,
    UINT *protocol,
    UINT *port,
    UINT *interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_115">Description</h3>
<div class="paragraph">
<p>This service extracts network parameters, such as IPv4 address, peer port number, protocol type (this service always returns UDP type) from a packet received on an incoming interface. To obtain information on a packet coming from IPv4 or IPv6 network, application shall use the service <strong><em>nxd_udp_packet_info_extract.</em></strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_115">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>packet_ptr</strong>* Pointer to packet.</p>
</li>
<li>
<p><strong>ip_address</strong>* Pointer to sender IP address.</p>
</li>
<li>
<p><strong>protocol</strong>* Pointer to protocol (UDP).</p>
</li>
<li>
<p><strong>port</strong>* Pointer to sender&#8217;s port number.</p>
</li>
<li>
<p><strong>interface_index</strong>* Pointer to receiving interface index.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_115">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Packet interface data successfully extracted.</p>
</li>
<li>
<p><strong>NX_INVALID_PACKET</strong> (0x12) Packet does not contain IPv4 frame.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointer input</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_115">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_115">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_114">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Extract network data from UDP packet interface.*/
status = nx_udp_packet_info_extract(packet_ptr, &amp;ip_address,
                                     &amp;protocol, &amp;port,
                                     &amp;interface_index);

/* If status is NX_SUCCESS packet data was successfully
   retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_115">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_bind">nx_udp_socket_bind</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Bind UDP socket to UDP port</p>
</div>
<div class="sect2">
<h3 id="_prototype_116">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_bind(
    NX_UDP_SOCKET *socket_ptr,
    UINT port,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_116">Description</h3>
<div class="paragraph">
<p>This service binds the previously created UDP socket to the specified UDP port. Valid UDP sockets range from 0 through 0xFFFF. If the requested port number is bound to another socket, this service waits for specified period of time for the socket to unbind from the port number.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_116">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously created UDP socket instance.</p>
</li>
<li>
<p><strong>port<strong> Port number to bind to</strong> (1 through 0xFFFF). If port number is NX_ANY_PORT</strong>* (0x0000), the IP instance will search for the next free port and use that for the binding.</p>
</li>
<li>
<p><strong>wait_option</strong>* Defines how the service behaves if the port is already bound to another socket. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_116">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket bind.</p>
</li>
<li>
<p><strong>NX_ALREADY_BOUND</strong> (0x22) This socket is already bound to another port.</p>
</li>
<li>
<p><strong>NX_PORT_UNAVAILABLE</strong> (0x23) Port is already bound to a different socket.</p>
</li>
<li>
<p><strong>NX_NO_FREE_PORTS</strong> (0x45) No free port.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) Invalid port specified.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_116">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_116">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_115">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Bind the previously created UDP socket to port 12 on the
   previously created IP instance. If the port is already bound,
   wait for 300 timer ticks before giving up. */
status = nx_udp_socket_bind(&amp;udp_socket, 12, 300);

/* If status is NX_SUCCESS, the UDP socket is now bound to
   port 12.*/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_116">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_bytes_available">nx_udp_socket_bytes_available</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieves number of bytes available for retrieval</p>
</div>
<div class="sect2">
<h3 id="_prototype_117">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_bytes_available(
    NX_UDP_SOCKET *socket_ptr,
    ULONG *bytes_available);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_117">Description</h3>
<div class="paragraph">
<p>This service retrieves number of bytes available for reception in the specified UDP socket.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_117">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously created UDP socket.</p>
</li>
<li>
<p><strong>bytes_available</strong>* Pointer to destination for bytes available.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_117">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful bytes available retrieval.</p>
</li>
<li>
<p><strong>NX_NOT_SUCCESSFUL</strong> (0x43) Socket not bound to a port.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointers.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) UDP feature is not enabled.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_117">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_117">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_116">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Get the bytes available for retrieval from the UDP socket. */
status = nx_udp_socket_bytes_available(&amp;my_socket,
                                       &amp;bytes_available);

/* If status == NX_SUCCESS, the number of bytes was successfully
   retrieved.*/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_117">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_checksum_disable">nx_udp_socket_checksum_disable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Disable checksum for UDP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_118">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_checksum_disable(NX_UDP_SOCKET *socket_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_118">Description</h3>
<div class="paragraph">
<p>This service disables the checksum logic for sending and receiving packets on the specified UDP socket. When the checksum logic is disabled, a value of zero is loaded into the UDP header&#8217;s checksum field for all packets sent through this socket. A zero-value checksum value in the UDP header signals the  receiver that checksum is not computed for this packet.</p>
</div>
<div class="paragraph">
<p>Also note that this has no effect if <strong>NX_DISABLE_UDP_RX_CHECKSUM</strong> and <strong>NX_DISABLE_UDP_TX_CHECKSUM</strong> are defined when receiving and sending UDP packets respectively,</p>
</div>
<div class="paragraph">
<p>Note that this service has no effect on packets on the IPv6 network since UDP checksum is mandatory for IPv6.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_118">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously created UDP socket instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_118">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket checksum disable.</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket is not bound.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_118">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timer</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_118">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_117">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Disable the UDP checksum logic for packets sent on this socket. */
status = nx_udp_socket_checksum_disable(&amp;udp_socket);

/* If status is NX_SUCCESS, outgoing packets will not have a checksum
   calculated. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_118">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_checksum_enable">nx_udp_socket_checksum_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable checksum for UDP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_119">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_checksum_enable(NX_UDP_SOCKET *socket_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_119">Description</h3>
<div class="paragraph">
<p>This service enables the checksum logic for sending and receiving packets on the specified UDP socket. The checksum covers the entire UDP data area as well as a pseudo IP header.</p>
</div>
<div class="paragraph">
<p>Also note that this has no effect if <strong>NX_DISABLE_UDP_RX_CHECKSUM</strong> and <strong>NX_DISABLE_UDP_TX_CHECKSUM</strong> are defined when receiving and sending UDP packets respectively.</p>
</div>
<div class="paragraph">
<p>Note that this service has no effect on packets on the IPv6 network. UDP checksum is mandatory in IPv6.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_119">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>socket_ptr</strong>* Pointer to previously created UDP socket instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_119">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket checksum enable.</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket is not bound.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_119">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timer</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_119">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_118">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Enable the UDP checksum logic for packets sent on this socket. */
status = nx_udp_socket_checksum_enable(&amp;udp_socket);

/* If status is NX_SUCCESS, outgoing packets will have a checksum
   calculated. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_119">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_create">nx_udp_socket_create</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create UDP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_120">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_create(
    NX_IP *ip_ptr,
    NX_UDP_SOCKET *socket_ptr,
    CHAR *name,
    ULONG type_of_service,
    ULONG fragment,
    UINT time_to_live,
    ULONG queue_maximum);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_120">Description</h3>
<div class="paragraph">
<p>This service creates a UDP socket for the specified IP instance.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_120">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><strong>ip_ptr</strong>* Pointer to previously created IP instance.</p>
</li>
<li>
<p><strong>socket_ptr</strong>* Pointer to new UDP socket control bloc.</p>
</li>
<li>
<p><strong>name</strong>* Application name for this UDP socket.</p>
</li>
<li>
<p><strong>type_of_service</strong>* Defines the type of service for the transmission, legal values are as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_IP_NORMAL</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_IP_MIN_DELAY</strong> (0x00100000)</p>
</li>
<li>
<p><strong>NX_IP_MAX_DATA</strong> (0x00080000)</p>
</li>
<li>
<p><strong>NX_IP_MAX_RELIABLE</strong> (0x00040000)</p>
</li>
<li>
<p><strong>NX_IP_MIN_COST</strong> (0x00020000)</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>fragment Specifies</em>: whether or not IP fragmenting is allowed. If NX_FRAGMENT_OKAY (0x0) is specified, IP fragmenting is allowed. If NX_DONT_FRAGMENT (0x4000) is specified, IP fragmenting is disabled.</p>
</li>
<li>
<p><em>time_to_live</em>: Specifies the 8-bit value that defines how many routers this packet can pass before being thrown away. The default value is specified by <strong>NX_IP_TIME_TO_LIVE</strong>.</p>
</li>
<li>
<p><em>queue_maximum</em>: Defines the maximum number of UDP datagrams that can be queued for this socket. After the queue limit is reached, for every new packet received the oldest UDP packet is released.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_120">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful UDP socket create.</p>
</li>
<li>
<p><strong>NX_OPTION_ERROR</strong> (0x0A) Invalid type-of-service, fragment, or time-to-live option.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_120">Allowed From</h3>
<div class="paragraph">
<p>Initialization and Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_120">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_119">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Create a UDP socket with a maximum receive queue of 30 packets.*/
status = nx_udp_socket_create(&amp;ip_0, &amp;udp_socket, "Sample UDP Socket",
                              NX_IP_NORMAL, NX_FRAGMENT_OKAY, 0x80,
                              30);

/* If status is NX_SUCCESS, the new UDP socket has been created and
   is ready for binding. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_120">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_delete">nx_udp_socket_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Delete UDP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_121">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_delete(NX_UDP_SOCKET *socket_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_121">Description</h3>
<div class="paragraph">
<p>This service deletes a previously created UDP socket. If the socket was bound to a port, the socket must be unbound first.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_121">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created UDP socket instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_121">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket delete.</p>
</li>
<li>
<p><strong>NX_STILL_BOUND</strong> (0x42) Socket is still bound.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_121">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_121">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_120">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Delete a previously created UDP socket. */
status = nx_udp_socket_delete(&amp;udp_socket);

/* If status is NX_SUCCESS, the previously created UDP socket has
   been deleted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_121">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_info_get">nx_udp_socket_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve information about UDP socket activities</p>
</div>
<div class="sect2">
<h3 id="_prototype_122">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_info_get(
    NX_UDP_SOCKET *socket_ptr,
    ULONG *udp_packets_sent,
    ULONG *udp_bytes_sent,
    ULONG *udp_packets_received,
    ULONG *udp_bytes_received,
    ULONG *udp_packets_queued,
    ULONG *udp_receive_packets_dropped,
    ULONG *udp_checksum_errors);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_122">Description</h3>
<div class="paragraph">
<p>This service retrieves information about UDP socket activities for the specified UDP socket instance.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If a destination pointer is NX_NULL, that particular information is not returned to the caller</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_122">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created UDP socket instance.</p>
</li>
<li>
<p><em>udp_packets_sent</em>: Pointer to destination for the total number of UDP packets sent on socket.</p>
</li>
<li>
<p><em>udp_bytes_sent</em>: Pointer to destination for the total number of UDP bytes sent on socket.</p>
</li>
<li>
<p><em>udp_packets_received</em>: Pointer to destination of the total number of UDP packets received on socket.</p>
</li>
<li>
<p><em>udp_bytes_received</em>: Pointer to destination of the total number of UDP bytes received on socket.</p>
</li>
<li>
<p><em>udp_packets_queued</em>: Pointer to destination of the total number of queued UDP packets on socket.</p>
</li>
<li>
<p><em>udp_receive_packets_dropped</em>: Pointer to destination of the total number of UDP receive packets dropped for socket due to queue size being exceeded.</p>
</li>
<li>
<p><em>udp_checksum_errors</em>: Pointer to destination of the total number of UDP packets with checksum errors on socket.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_122">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful UDP socket information retrieval.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_122">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, and timers</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_122">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_121">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Retrieve UDP socket information from socket 0.*/
status = nx_udp_socket_info_get(&amp;socket_0,
                                &amp;udp_packets_sent,
                                &amp;udp_bytes_sent,
                                &amp;udp_packets_received,
                                &amp;udp_bytes_received,
                                &amp;udp_queued_packets,
                                &amp;udp_receive_packets_dropped,
                                &amp;udp_checksum_errors);

/* If status is NX_SUCCESS, UDP socket information was retrieved.*/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_122">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_port_get">nx_udp_socket_port_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Pick up port number bound to UDP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_123">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_port_get(
    NX_UDP_SOCKET *socket_ptr,
    UINT *port_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_123">Description</h3>
<div class="paragraph">
<p>This service retrieves the port number associated with the socket, which is useful to find the port allocated by NetX Duo in situations where the NX_ANY_PORT was specified at the time the socket was bound.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_123">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created UDP socket instance.</p>
</li>
<li>
<p><em>port_ptr</em>: Pointer to destination for the return port number. Valid port numbers are (1- 0xFFFF).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_123">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket bind.</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) This socket is not bound to a port.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer or port return pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_123">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_123">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_122">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Get the port number of created and bound UDP socket. */
status = nx_udp_socket_port_get(&amp;udp_socket, &amp;port);

/* If status is NX_SUCCESS, the port variable contains the port this
   socket is bound to. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_123">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_receive">nx_udp_socket_receive</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Receive datagram from UDP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_124">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_receive(
    NX_UDP_SOCKET *socket_ptr,
    NX_PACKET **packet_ptr,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_124">Description</h3>
<div class="paragraph">
<p>This service receives an UDP datagram from the specified socket. If no datagram is queued on the specified socket, the caller suspends based on the supplied wait option.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<em>If NX_SUCCESS is returned, the application is responsible for releasing the received packet when it is no longer needed</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_124">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created UDP socket instance.</p>
</li>
<li>
<p><em>packet_ptr</em>: Pointer to UDP datagram packet pointer.</p>
</li>
<li>
<p><em>wait_option</em>: Defines how the service behaves if a datagram is not currently queued on this socket. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_124">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket receive.</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket was not bound to any port.</p>
</li>
<li>
<p><strong>NX_NO_PACKET</strong> (0x01) There was no UDP datagram to receive.</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket or packet return pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_124">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_124">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_123">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Receive a packet from a previously created and bound UDP socket.
   If no packets are currently available, wait for 500 timer ticks
   before giving up. */
status = nx_udp_socket_receive(&amp;udp_socket, &amp;packet_ptr, 500);

/* If status is NX_SUCCESS, the received UDP packet is pointed to by
   packet_ptr. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_124">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_receive_notify">nx_udp_socket_receive_notify</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Notify application of each received packet</p>
</div>
<div class="sect2">
<h3 id="_prototype_125">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_receive_notify(
    NX_UDP_SOCKET *socket_ptr,
    VOID (*udp_receive_notify)(NX_UDP_SOCKET *socket_ptr));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_125">Description</h3>
<div class="paragraph">
<p>This service sets the receive notify function pointer to the callback function specified by the  application. This callback function is then called whenever a packet is received on the socket. If a NX_NULL pointer is supplied, the receive notify function is disabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_125">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to the UDP socket.</p>
</li>
<li>
<p><em>udp_receive_notify</em>: Application callback function pointer that is called when a packet is received on the socket.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_125">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully set socket receive notify function.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_125">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers, and ISRs</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_125">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_124">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Setup a receive packet callback function for the "udp_socket"
   socket. */
status = nx_udp_socket_receive_notify(&amp;udp_socket,
                                      my_receive_notify);

/* If status is NX_SUCCESS, NetX Duo will call the function named
   "my_receive_notify" whenever a packet is received for
   "udp_socket". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_125">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_send">nx_udp_socket_send</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send a UDP Datagram</p>
</div>
<div class="sect2">
<h3 id="_prototype_126">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_send(
    NX_UDP_SOCKET *socket_ptr,
    NX_PACKET *packet_ptr,
    ULONG ip_address,
    UINT port);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_126">Description</h3>
<div class="paragraph">
<p>This service sends a UDP datagram through a previously created and bound UDP socket for IPv4 networks. NetX Duo finds a suitable local IP address as source address based on the destination IP address. To specify a specific interface and source IP address, the application should use the  <strong>nxd_udp_socket_source_send</strong> service.</p>
</div>
<div class="paragraph">
<p>Note that this service returns immediately regardless of whether the UDP datagram was successfully sent. The NetX Duo (IPv4/IPv6) equivalent service is <strong><em>nxd_udp_socket_send</em></strong>.</p>
</div>
<div class="paragraph">
<p>The socket must be bound to a local port.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Unless an error is returned, the application should not release the packet after this call. Doing so will cause unpredictable results because the network driver will also try to release the packet after
transmission</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_126">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created UDP socket instance</p>
</li>
<li>
<p><em>packet_ptr</em>: UDP datagram packet pointer</p>
</li>
<li>
<p><em>ip_address</em>: Destination IPv4 address</p>
</li>
<li>
<p><em>port</em>: Valid destination port number between 1 and 0xFFFF), in host byte order</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_126">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful UDP socket send</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket not bound to any port</p>
</li>
<li>
<p><strong>NX_NO_INTERFACE_ADDRESS</strong> (0x50) No suitable outgoing interface can be found.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid server IP address</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Not enough room for UDP header in the packet</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Packet append pointer is invalid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) UDP has not been enabled</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) Port number is not within a valid range</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_126">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_126">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_125">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">ULONG server_address;

/* Set the UDP Client IP address. */
server_address = IP_ADDRESS(1,2,3,5);

/* Send a packet to the UDP server at server_address on port 12. */
status = nx_udp_socket_send(&amp;client_socket, packet_ptr,
                            server_address, 12);

/* If status == NX_SUCCESS, the application successfully transmitted
   the packet out the UDP socket to its peer. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_126">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_source_send">nx_udp_socket_source_send</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send datagram through UDP socket</p>
</div>
<div class="sect2">
<h3 id="_prototype_127">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_source_send(
    NX_UDP_SOCKET *socket_ptr,
    NX_PACKET *packet_ptr,
    ULONG ip_address,
    UINT port,
    UINT address_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_127">Description</h3>
<div class="paragraph">
<p>This service sends a UDP datagram through a previously created and bound UDP socket through the network interface with the specified IP address as the source address. Note that service returns immediately, regardless of whether or not the UDP datagram was successfully sent. <strong><em>nxd_udp_socket_source_send</em></strong> works for both IPv4 and IPv6 networks.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Unless an error is returned, the application should not release the packet after this call. Doing so will cause unpredictable results because the network driver will also try to release the packet after
transmission</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_127">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Socket to transmit the packet out on.</p>
</li>
<li>
<p><em>packet_ptr</em>: Pointer to packet to transmit.</p>
</li>
<li>
<p><em>ip_address</em>: Destination IP address to send packet.</p>
</li>
<li>
<p><em>port</em>: Destination port.</p>
</li>
<li>
<p><em>address_index</em>: Index of the address associated with the interface to send packet on.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_127">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Packet successfully sent.</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket not bound to a port.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IP address.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) UDP processing not enabled.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointer.</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Invalid packet append pointer.</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Invalid packet prepend pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid address index.</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) Port number exceeds maximum port number.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_127">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_127">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_126">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define ADDRESS_INDEX 1

/* Send packet out on port 80 to the specified destination IP on the
   interface at index 1 in the IP task interface list. */
status = nx_udp_socket_source_send(socket_ptr, packet_ptr,
                                   destination_ip, 80,
                                   ADDRESS_INDEX);

/* If status is NX_SUCCESS packet was successfully transmitted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_127">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_socket_unbind">nx_udp_socket_unbind</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unbind UDP socket from UDP port</p>
</div>
<div class="sect2">
<h3 id="_prototype_128">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_socket_unbind(NX_UDP_SOCKET *socket_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_128">Description</h3>
<div class="paragraph">
<p>This service releases the binding between the UDP socket and a UDP port. Any received packets stored in the receive queue are released as part of the unbind operation.</p>
</div>
<div class="paragraph">
<p>If there are other threads waiting to bind another socket to the unbound port, the first suspended thread is then bound to the newly unbound port.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_128">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created UDP socket instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_128">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket unbind.</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket was not bound to any port.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service.</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) This component has not been enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_128">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_128">Preemption Possible</h3>
<div class="paragraph">
<p>Yes</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_127">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Unbind the previously bound UDP socket. */
status = nx_udp_socket_unbind(&amp;udp_socket);

/* If status is NX_SUCCESS, the previously bound socket is now
   unbound. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_128">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_udp_source_extract">nx_udp_source_extract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Extract IP and sending port from UDP datagram</p>
</div>
<div class="sect2">
<h3 id="_prototype_129">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_udp_source_extract(
    NX_PACKET *packet_ptr,
    ULONG *ip_address,
    UINT *port);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_129">Description</h3>
<div class="paragraph">
<p>This service extracts the sender&#8217;s IP and port number from the IP and UDP headers of the supplied UDP datagram. Note that the service <strong><em>nxd_udp_source_extract</em></strong> works with packets from either IPv4 or IPv6 network.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_129">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>packet_ptr</em>: UDP datagram packet pointer.</p>
</li>
<li>
<p><em>ip_address</em>: Valid pointer to the return IP address variable.</p>
</li>
<li>
<p><em>port</em>: Valid pointer to the return port variable.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_129">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful source IP/port extraction.</p>
</li>
<li>
<p><strong>NX_INVALID_PACKET</strong> (0x12) The supplied packet is invalid.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid packet or IP or port destination.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_129">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads, timers, ISR</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_129">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_128">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Extract the IP and port information from the sender of the UPD packet. */
status = nx_udp_source_extract(packet_ptr, &amp;sender_ip_address, &amp;sender_port);

/* If status is NX_SUCCESS, the sender IP and port information has been stored
   in sender_ip_address and sender_port respectively.*/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_129">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_icmp_enable">nxd_icmp_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable ICMPv4 and ICMPv6 Services</p>
</div>
<div class="sect2">
<h3 id="_prototype_130">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_icmp_enable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_130">Description</h3>
<div class="paragraph">
<p>This service enables both ICMPv4 and ICMPv6 services and can only be called after the IP instance has been created. The service can be enabled either before or after IPv6 is enabled (see <em>nxd_ipv6_enable</em>). ICMPv4 services include Echo Request/Reply. ICMPv6 services include Echo Request/Reply, Neighbor Discovery, Duplicate Address Detection, Router Discovery, and Stateless Address Auto-configuration. The IPv4 equivalent in NetX is <em>nx_icmp_enable</em>.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[!NOTE]
<em>If the IPv6 address is manually configured prior to enabling ICMPv6, the manually configured IPv6 is not subject to Duplicate Address Detection process</em>.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><em>nx_icmp_enable</em> starts ICMP services for IPv4 operations only. Applications using ICMPv6 services must use <em>nxd_icmp_enable</em> instead of <em>nx_icmp_enable</em>.</p>
</div>
<div class="paragraph">
<p>To utilize IPv6 router solicitation and IPv6 stateless auto-address configuration, ICMPv6 must be enabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_130">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_130">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) ICMP services are successfully enabled</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_130">Allowed From</h3>
<div class="paragraph">
<p>Initialization, Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_130">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_129">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Enable ICMP on the IP instance. */
status = nxd_icmp_enable(&amp;ip_0);

/* A status return of NX_SUCCESS indicates that the IP instance is
   enabled for ICMP services. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_130">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_icmp_enable</p>
</li>
<li>
<p>nx_icmp_info_get</p>
</li>
<li>
<p>nx_icmp_ping</p>
</li>
<li>
<p>nxd_icmp_ping</p>
</li>
<li>
<p>nxd_icmp_source_ping</p>
</li>
<li>
<p>nxd_icmpv6_ra_flag_callback_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_icmp_ping">nxd_icmp_ping</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Perform ICMPv4 or ICMPv6 Echo Requests</p>
</div>
<div class="sect2">
<h3 id="_prototype_131">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_icmp_ping(
    NX_IP *ip_ptr,
    NXD_ADDRESS *ip_address,
    CHAR *data_ptr,
    ULONG data_size,
    NX_PACKET **response_ptr,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_131">Description</h3>
<div class="paragraph">
<p>This service sends out an ICMP Echo Request packet through an appropriate physical interface and waits for an Echo Reply from the destination host. NetX Duo determines the appropriate interface, based on the destination address, to send the ping message . Applications shall use the service <strong><em>nxd_icmp_source_ping</em></strong> to specify the physical interface and precise source IP address to use for packet transmission.</p>
</div>
<div class="paragraph">
<p>The IP instance must have been created, and the ICMPv4/ICMPv6 services must be enabled (see <strong><em>nxd_icmp_enable</em></strong>).</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
If NX_SUCCESS is returned, the application is responsible for releasing the received packet after it is no longer needed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_131">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to IP instance</p>
</li>
<li>
<p><em>ip_address</em>: Destination IP address to ping, in host byte order</p>
</li>
<li>
<p><em>data_ptr</em>: Pointer to ping packet data area</p>
</li>
<li>
<p><em>data_size</em>: Number of bytes of ping data</p>
</li>
<li>
<p><em>response_ptr</em>: Pointer to response packet Pointer</p>
</li>
<li>
<p><em>wait_option</em>: Time to wait for a reply. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_131">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful sent and received ping</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 is not enabled</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Ping data exceeds packet payload</p>
</li>
<li>
<p><strong>NX_NO_RESPONSE</strong> (0x29) Destination host did not respond</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by tx_thread_wait_abort</p>
</li>
<li>
<p><strong>NX_NO_INTERFACE_ADDRESS</strong> (0x50) No suitable outgoing interface can be found.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or response pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) IP or ICMP component is not enabled</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Input IP address is invalid</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_131">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_131">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_130">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* The following two examples illustrate how to use this API to send
   ping packets to IPv6 or IPv4 destinations. */

/* The first example: Send a ping packet to an IPv6 host
   2001:1234:5678::1 */

/* Declare variable address to hold the destination address. */
NXD_ADDRESS ip_address;

char *buffer = "abcd";
UINT prefix_length = 10;

/* Set the IPv6 address. */
ip_address.nxd_ip_address_version  = NX_IP_VERSION_V6;
ip_address.nxd_ip_address.v6[0]    = 0x20011234;
ip_address.nxd_ip_address.v6[1]    = 0x56780000;
ip_address.nxd_ip_address.v6[2]    = 0;
ip_address.nxd_ip_address.v6[3]    = 1;

status = nxd_icmp_ping(&amp;ip_0, &amp;ip_address, buffer,
                       strlen(buffer),&amp;response_ptr,
                       NX_WAIT_FOREVER);

/* A return value of NX_SUCCESS indicates a ping reply has been
   received from IP address 2001:1234:5678::1 and the response
   packet is contained in the packet pointed to by response_ptr.It
   should have the same "abcd" four bytes of data. */

/* The second example: Send a ping packet to an IPv4 host 1.2.3.4 */

/* Program the IPv4 address. */
ip_address.nxd_ip_address_version  = NX_IP_VERSION_V4;
ip_address.nxd_ip_address.v4[0]    = 0x01020304;

status = nxd_icmp_ping(&amp;ip_0, &amp;ip_address, buffer,
                       strlen(buffer),&amp;response_ptr, 10);

/* A return value of NX_SUCCESS indicates a ping reply was received
   from IP address 1.2.3.4 and the response packet is contained in
   the packet pointed to by response_ptr. It should have the same
   "abcd" four bytes of data. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_131">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_icmp_enable</p>
</li>
<li>
<p>nx_icmp_info_get</p>
</li>
<li>
<p>nx_icmp_ping</p>
</li>
<li>
<p>nxd_icmp_enable</p>
</li>
<li>
<p>nxd_icmp_source_ping</p>
</li>
<li>
<p>nxd_icmpv6_ra_flag_callback_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_icmp_source_ping">nxd_icmp_source_ping</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Perform ICMPv4 or ICMPv6 Echo Requests</p>
</div>
<div class="sect2">
<h3 id="_prototype_132">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_icmp_source_ping(
    NX_IP *ip_ptr,
    NXD_ADDRESS *ip_address,
    UINT address_index,
    CHAR *data_ptr,
    ULONG data_size,
    NX_PACKET **response_ptr,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_132">Description</h3>
<div class="paragraph">
<p>This service sends out an ICMP Echo Request packet using the specified index of an IPv4 or IPv6 address, and through the network interface the source address is associated with, and waits for an Echo Reply from the destination host. This service works with both IPv4 and IPv6 addresses. The parameter <em>address_index</em> indicates the source IPv4 or IPv6 address to use. For IPv4 address, the <em>address_index</em> is the same index to the attached network interface. For IPv6, the <em>address_index</em> indicates the entry in the IPv6 address table.</p>
</div>
<div class="paragraph">
<p>The IP instance must have been created, and the ICMPv4 and ICMPv6 services must be enabled (see <em>nxd_icmp_enable</em>).</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<em>If NX_SUCCESS is returned, the application is responsible for releasing the received packet after it is no longer needed</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_132">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to IP instance</p>
</li>
<li>
<p><em>ip_address</em>: Destination IP address to ping, in host byte order</p>
</li>
<li>
<p><em>address_index</em>: Indicates the IP address to use as source address</p>
</li>
<li>
<p><em>data_ptr</em>: Pointer to ping packet data area</p>
</li>
<li>
<p><em>data_size</em>: Number of bytes of ping data</p>
</li>
<li>
<p><em>response_ptr</em>: Pointer to response packet pointer</p>
</li>
<li>
<p><em>wait_option</em>: Time to wait for a reply. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> 0xFFFFFFFF)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_132">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful sent and received ping</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 is not enabled</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Ping data exceeds packet payload</p>
</li>
<li>
<p><strong>NX_NO_RESPONSE</strong> (0x29) Destination host did not respond</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by tx_thread_wait_abort</p>
</li>
<li>
<p><strong>NX_NO_INTERFACE_ADDRESS</strong> (0x50) No suitable outgoing interface can be found</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP or response pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) IP or ICMP component is not enabled</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Input IP address is invalid</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_132">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_132">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_131">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* The following two examples illustrate how to use this API to send ping
   packets to IPv6 or IPv4 destinations. */

/* The first example: Send a ping packet to an IPv6 host
   FE80::411:7B23:40dc:f181 */

/* Declare variable address to hold the destination address. */

#define PRIMARY_INTERFACE 0
#define GLOBAL_IPv6_ADDRESS 1

NXD_ADDRESS ip_address;
char *buffer = "abcd";
UINT prefix_length = 10;

/* Set the IPv6 address. */
ip_address.nxd_ip_address_version  = NX_IP_VERSION_V6;
ip_address.nxd_ip_address.v6[0]    = 0xFE800000;
ip_address.nxd_ip_address.v6[1]    = 0x00000000;
ip_address.nxd_ip_address.v6[2]    = 0x04117B23;
ip_address.nxd_ip_address.v6[3]    = 0x40DCF181;

status = nxd_icmp_source_ping(&amp;ip_0, &amp;ip_address,
                              GLOBAL_IPv6_ADDRESS,
                              buffer,
                              strlen(buffer),
                              &amp;response_ptr,
                              NX_WAIT_FOREVER);

/* A return value of NX_SUCCESS indicates a ping reply has been received
   from IP address FE80::411:7B23:40dc:f181 and the response packet is
   contained in the packet pointed to by response_ptr. It should have the
   same "abcd" four bytes of data. */

/* The second example: Send a ping packet to an IPv4 host 1.2.3.4 */

/* Program the IPv4 address. */
ip_address.nxd_ip_address_version  = NX_IP_VERSION_V4;
ip_address.nxd_ip_address.v4       = 0x01020304;

status = nxd_icmp_source_ping(&amp;ip_0, &amp;ip_address,
                              PRIMARY_INTERFACE,
                              buffer,
                              strlen(buffer),
                              &amp;response_ptr,
                              NX_WAIT_FOREVER);

/* A return value of NX_SUCCESS indicates a ping reply was received from
   IP address 1.2.3.4 and the response packet is contained in the packet
   pointed to by response_ptr. It should have the same "abcd" four bytes
   of data. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_132">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_icmp_enable</p>
</li>
<li>
<p>nx_icmp_info_get</p>
</li>
<li>
<p>nx_icmp_ping</p>
</li>
<li>
<p>nxd_icmp_enable</p>
</li>
<li>
<p>nxd_icmp_ping</p>
</li>
<li>
<p>nxd_icmpv6_ra_flag_callback_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_icmpv6_ra_flag_callback_set">nxd_icmpv6_ra_flag_callback_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set the ICMPv6 RA flag change callback function</p>
</div>
<div class="sect2">
<h3 id="_prototype_133">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_icmpv6_ra_flag_callback_set(
    NX_IP *ip_ptr,
    VOID(*ra_callback)(NX_IP*ip_ptr, UINT ra_flag));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_133">Description</h3>
<div class="paragraph">
<p>This service sets the ICMPv6 Router Advertisement flag change callback function. The user-supplied callback function is invoked when NetX Duo receives a router advertisement message.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_133">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to IP instance</p>
</li>
<li>
<p><em>ra_callback</em>: User-supplied callback function</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_133">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful set the RA flag callback function</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 is not enabled</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_133">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_133">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_132">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">VOID icmpv6_ra_flag_callback(NX_IP *ip_ptr, UINT ra_flag)
{
   /* RA flag has changed. The updated value is passed in via the
      ra_flag parameter. */
}

/* Configure the user-defined ICMPv6 RA flag change callback
   function. */
status = nxd_icmpv6_ra_flag_callback_set(&amp;ip_0,
                                         icmpv6_ra_flag_callback);

/* A status return of NX_SUCCESS indicates the callback function has
   been successfully configured. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_133">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_icmp_enable</p>
</li>
<li>
<p>nx_icmp_info_get</p>
</li>
<li>
<p>nx_icmp_ping</p>
</li>
<li>
<p>nxd_icmp_enable</p>
</li>
<li>
<p>nxd_icmp_ping</p>
</li>
<li>
<p>nxd_icmp_source_ping</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ip_raw_packet_send">nxd_ip_raw_packet_send</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send Raw IP Packet</p>
</div>
<div class="sect2">
<h3 id="_prototype_134">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ip_raw_packet_send(
    NX_IP *ip_ptr,
    NX_PACKET *packet_ptr,
    NXD_ADDRESS *destination
    ULONG protocol,
    UINT ttl,
    ULONG tos);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_134">Description</h3>
<div class="paragraph">
<p>This service sends a raw IPv4 or IPv6 packet (no transport-layer protocol headers). On a multihome system, if the system is unable to determine an appropriate interface (for example, if the destination IP address is IPv4 broadcast, multicast or IPv6 multicast address), the primary device is selected. The service <strong><em>nxd_ip_raw_packet_source_send</em></strong> can be used to specify an outgoing interface. The NetX equivalent is <strong><em>nx_ip_raw_packet_send</em>.</strong></p>
</div>
<div class="paragraph">
<p>The IP instance must be previously created and raw IP packet handling must be enabled using the <strong><em>nx_ip_raw_packet_enable</em></strong> service.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Unless an error is returned, the application should not release the packet after this call. Doing so will cause unpredictable results because the network driver will also try to release the packet after
transmission</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_134">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to the previously created IP instance</p>
</li>
<li>
<p><em>packet_ptr</em>: Pointer to packet to transmit</p>
</li>
<li>
<p><em>destination_ip</em>: Pointer to destination address</p>
</li>
<li>
<p><em>protocol</em>: Packet protocol stored to the IP header</p>
</li>
<li>
<p><em>ttl</em>: Value for TTL or hop limit</p>
</li>
<li>
<p><em>tos</em>: Value for TOS or traffic class and flow label</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_value">Return Value</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Raw IP packet successfully sent</p>
</li>
<li>
<p><strong>NX_NO_INTERFACE_ADDRESS</strong> (0x50) No suitable outgoing interface can be found</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) Raw IP handling not enabled</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IPv4 or IPv6 address</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Not enough room for IPv4 or IPv6 header in the packet</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Packet append pointer is invalid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer or packet pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) Not valid IPv6 address input</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_134">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_134">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_133">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NXD_ADDRESS dest_address;

/* Set the destination address,in this case an IPv6 address. */
dest_address.nxd_ip_address_version  = NX_IP_VERSION_V6;
dest_address.nxd_ip_address.v6[0]    = 0x20011234;
dest_address.nxd_ip_address.v6[1]    = 0x56780000;
dest_address.nxd_ip_address.v6[2]    = 0;
dest_address.nxd_ip_address.v6[3]    = 1;

UINT ttl, tos;

ttl = 128;

tos = 0;

/* Enable RAW IP handling on the previously created IP instance.*/
status = nx_raw_ip_packet_enable(&amp;ip_0);

/* Allocate a packet pointed to by packet_ptr from the IP packet
   pool. */
/* Then transmit the packet to the destination address. */

status = nxd_ip_raw_packet_send(&amp;ip_0, packet_ptr, dest_address,
                                NX_PROTOCOL_UDP, ttl, tos);

/* A status return of NX_SUCCESS indicates the packet was
   successfully transmitted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_134">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_raw_packet_disable</p>
</li>
<li>
<p>nx_ip_raw_packet_enable</p>
</li>
<li>
<p>nx_ip_raw_packet_filter_set</p>
</li>
<li>
<p>nx_ip_raw_packet_receive</p>
</li>
<li>
<p>nx_ip_raw_packet_send</p>
</li>
<li>
<p>nx_ip_raw_packet_source_send</p>
</li>
<li>
<p>nx_ip_raw_receive_queue_max_set</p>
</li>
<li>
<p>nxd_ip_raw_packet_source_send</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ip_raw_packet_source_send">nxd_ip_raw_packet_source_send</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send raw packet using specified source address</p>
</div>
<div class="sect2">
<h3 id="_prototype_135">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ip_raw_packet_source_send(
    NX_IP *ip_ptr,
    NX_PACKET *packet_ptr,
    NXD_ADDRESS *destination_ip,
    UINT address_index,
    ULONG protocol,
    UINT ttl,
    ULONG tos);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_135">Description</h3>
<div class="paragraph">
<p>This service sends a raw IPv4 or IPv6 packet using the specified IPv4 or IPv6 address as source address. This service is typically used on a multihome system, if the system is unable to determine an appropriate interface (for example, if the destination IP address is IPv4 broadcast, multicast or IPv6 multicast address). The parameter <em>address_index</em> allows the application to specify the source address to use when sending this raw packet.</p>
</div>
<div class="paragraph">
<p>The IP instance must be previously created and raw IP packet handling must be enabled using the <strong>*nx_ip_raw_packet_enable</strong>: service.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Unless an error is returned, the application should not release the packet after this call. Doing so will cause unpredictable results because the network driver will also try to release the packet after
transmission</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_135">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP instance pointer</p>
</li>
<li>
<p><em>packet_ptr</em>: Pointer to packet to send</p>
</li>
<li>
<p><em>destination_ip</em>: Destination IP address</p>
</li>
<li>
<p><em>address_index</em>: Index to the IPv4 or IPv6 addresses to use as source address.</p>
</li>
<li>
<p><em>protocol</em>: Value for the protocol field</p>
</li>
<li>
<p><em>ttl</em>: Value for ttl or hop limit</p>
</li>
<li>
<p><em>tos</em>: Value for tos or traffic class and flow label</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_134">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Packet is sent successfully</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Not enough room for IPv4 or IPv6 header in the packet</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Packet append pointer is invalid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointer to IP control block, packet, or destination_ip</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) Raw processing not enabled</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Address error</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid interface index</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) Not valid IPv6 address input</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_135">Allowed From</h3>
<div class="paragraph">
<p>Thread</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_135">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_134">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define SOURCE_ADDRESS_INDEX 2

/* Send a raw packet from specified interface. */
status = nxd_ip_raw_packet_source_send(&amp;ip_0, packet_ptr,
                                       dest_ip,
                                       SOURCE_ADDRESS_INDEX,
                                       NX_IP_RAW,
                                       NX_IP_TIME_TO_LIVE,
                                       NX_IP_NORMAL);

/* If status == NX_SUCCESS, raw packet has been sent out on the
   specified interface. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_135">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_raw_packet_disable</p>
</li>
<li>
<p>nx_ip_raw_packet_enable</p>
</li>
<li>
<p>nx_ip_raw_packet_filter_set</p>
</li>
<li>
<p>nx_ip_raw_packet_receive</p>
</li>
<li>
<p>nx_ip_raw_packet_send</p>
</li>
<li>
<p>nx_ip_raw_packet_source_send</p>
</li>
<li>
<p>nx_ip_raw_receive_queue_max_set</p>
</li>
<li>
<p>nxd_ip_raw_packet_send</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_address_change_notify">nxd_ipv6_address_change_notify</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set ipv6 address change notify</p>
</div>
<div class="sect2">
<h3 id="_prototype_136">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_address_change_notify(
    NX_IP *ip_ptr,
    VOID (*ip_address_change_notify)(NX_IP *, UINT, UINT, UINT, ULONG *));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_136">Description</h3>
<div class="paragraph">
<p>This service registers an application callback routine that NetX Duo calls whenever the IPv6 Address is changed.</p>
</div>
<div class="paragraph">
<p>This service is available if the NetX Duo library is built is the option <strong><em>NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY</em></strong> defined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_136">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>ip_address_change_notify</em>: Application callback function</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_135">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful set</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 address change notify feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) IPv6 address change notify is not compiled</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_136">Allowed From</h3>
<div class="paragraph">
<p>Thread</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_136">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_135">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">VOID ip_address_change_notify(NX_IP *ip_ptr, UINT status,
                              UINT interface_index,
                              UINT address_index,
                              ULONG *ip_address)
{

   /* Do something when ip address changed. */
}

void ip_address_thread_entry(ULONG id)
{

   /* Set the ip address change notify of IP instance. */
   status = nxd_ipv6_address_change_notify (&amp;ip_0, ip_address_change_notify);

/* If status == NX_SUCCESS, the ip address change notify of IP
   instance was successfully set. */
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_136">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_address_delete">nxd_ipv6_address_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Delete IPv6 Address</p>
</div>
<div class="sect2">
<h3 id="_prototype_137">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_address_delete(
    NX_IP *ip_ptr,
    UINT address_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_137">Description</h3>
<div class="paragraph">
<p>This service deletes the IPv6 address at the specified index in the IPv6 address table of the specified IP instance. There is no NetX equivalent.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_137">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to the previously created IP instance</p>
</li>
<li>
<p><em>address_index</em>: Index to IP instance IPv6 address table</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_136">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Address successfully deleted</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_NO_INTERFACE_ADDRESS</strong> (0x50) No suitable outgoing interface can be found</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_137">Allowed From</h3>
<div class="paragraph">
<p>Initialization, Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_137">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_136">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NXD_ADDRESS ip_address;
UINT        address_index;

/* Delete the IPv6 address at the specified address table index. */
address_index = 1;
status = nxd_ipv6_address_delete(&amp;ip_0, address_index);

/* A status return of NX_SUCCESS indicates that the IP instance
   address is successfully deleted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_137">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_address_get">nxd_ipv6_address_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve IPv6 Address and Prefix</p>
</div>
<div class="sect2">
<h3 id="_prototype_138">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_address_get(
    NX_IP *ip_ptr,
    UINT address_index,
    NXD_ADDRESS *ip_address,
    ULONG *prefix_length,
    UINT *interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_138">Description</h3>
<div class="paragraph">
<p>This service retrieves the IPv6 address and prefix at the specified index in the address table of the specified IP instance. The index of the physical interface the IPv6 address is associated with is returned in the <em>interface_index</em> pointer. The NetX equivalent services are <strong><em>nx_ip_address_get</em></strong> and <strong><em>nx_ip_interface_address_get</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_138">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to the previously created IP instance</p>
</li>
<li>
<p><em>address_index</em>: Index to IP instance address table</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to the address to set</p>
</li>
<li>
<p><em>prefix_length</em>: Length of the address prefix (subnet mask)</p>
</li>
<li>
<p><em>interface_index</em>: Pointer to the index of the interface</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_137">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) IPv6 is successfully enabled</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library.</p>
</li>
<li>
<p><strong>NX_NO_INTERFACE_ADDRESS</strong> (0x50) No interface address, or invalid address_index</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_138">Allowed From</h3>
<div class="paragraph">
<p>Initialization, Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_138">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_137">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NXD_ADDRESS ip_address;
UINT        address_index;
ULONG       prefix_length;
UINT        interface_index;

/* Get the IPv6 address at the specified address table index. If
   found, the address network interface is returned in the
   interface_index input, as well as the address prefix in the
   prefix_length input. */

address_index = 1;
status = nxd_ipv6_address_get(&amp;ip_0, address_index, &amp;ip_address,
                              &amp;prefix_length, &amp;interface_index);

/* A status return of NX_SUCCESS indicates that the IP instance
   address is successfully retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_138">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_address_set">nxd_ipv6_address_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set IPv6 Address and Prefix</p>
</div>
<div class="sect2">
<h3 id="_prototype_139">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_address_set(
    NX_IP *ip_ptr,
    UINT interface_index,
    NXD_ADDRESS *ip_address,
    ULONG prefix_length,
    UINT *address_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_139">Description</h3>
<div class="paragraph">
<p>This service sets the supplied IPv6 address and prefix to the specified IP instance. If the <em>address_index</em> argument is not null, the index into the IPv6 address table where the address is inserted is returned. The NetX equivalent services are <strong><em>nx_ip_address_set<strong>: and </strong></em>nx_ip_interface_address_set</strong>*.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_139">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to the previously created IP instance</p>
</li>
<li>
<p><em>interface_index</em>: Index to the interface the IPv6 address is associated with</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to the address to set</p>
</li>
<li>
<p><em>prefix_length</em>: Length of the address prefix (subnet mask)</p>
</li>
<li>
<p><em>address_index</em>: Pointer to the index into the address table where the address is inserted</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_138">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) IPv6 is successfully enabled</p>
</li>
<li>
<p><strong>NX_NO_MORE_ENTRIES</strong> (0x15) IP address table is full</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library.</p>
</li>
<li>
<p><strong>NX_DUPLICATED_ENTRY</strong> (0x52) The supplied IP address is already used on this IP instance</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IPv6 address</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface points to an invalid network interface</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_139">Allowed From</h3>
<div class="paragraph">
<p>Initialization, Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_139">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_138">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NXD_ADDRESS ip_address;
UINT        address_index;
UINT        interface_index;

ip_address.nxd_ip_version = NX_IP_VERSION_V6;
ip_address.nxd_ip_address.v6[0] = 0x20010000;
ip_address.nxd_ip_address.v6[1] = 0;
ip_address.nxd_ip_address.v6[2] = 0;
ip_address.nxd_ip_address.v6[3] = 1;

/* First create an IP instance with packet pool, source address, and
   driver.*/
status = nx_ip_create(&amp;ip_0, "NetX IP Instance 0",
                     IP_ADDRESS(1,2,3,4),
                     0xFFFFFF00UL, &amp;pool_0,_nx_ram_network_driver,
                     pointer, 2048, 1);

/* Then enable IPv6 on the IP instance. */
status = nxd_ipv6_enable(&amp;ip_0);

/* Set the IPv6 address (a global address as indicated by the 64 bit
   prefix) using the IPv6 address just created on the primary device
   (index zero). The index into the address table is returned in
   address_index. */
interface_index = 0;
status = nxd_ipv6_address_set(&amp;ip_0, interface_index, &amp;ip_address,
                              64,&amp;address_index);

/* A status return of NX_SUCCESS indicates that the IPv6 address is
   successfully assigned to the primary interface (interface 0). */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_139">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_default_router_add">nxd_ipv6_default_router_add</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Add an IPv6 Router to Default Router Table</p>
</div>
<div class="sect2">
<h3 id="_prototype_140">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_default_router_add(
    NX_IP *ip_ptr,
    NXD_ADDRESS *router_address,
    ULONG router_lifetime,
    UINT index_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_140">Description</h3>
<div class="paragraph">
<p>This service adds an IPv6 default router on the specified physical interface to the default router table. The equivalent NetX IPv4 service is <strong><em>nx_ip_gateway_address_set</em></strong>.</p>
</div>
<div class="paragraph">
<p><em>router_address</em> must point to a valid IPv6 address, and the router must be directly accessible from the specified physical interface.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_140">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance</p>
</li>
<li>
<p><em>router_address</em>: Pointer to the default router address, in host byte order</p>
</li>
<li>
<p><em>router_lifetime</em>: Default router life time, in seconds. Valid values are:</p>
<div class="ulist">
<ul>
<li>
<p><strong>0xFFFF:</strong> No time out</p>
</li>
<li>
<p><strong>0-0xFFFE:</strong> Timeout value, in seconds</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>index_index</em>: Pointer to the valid memory location for the network index index through which the router can be reached</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_139">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Default router is successfully added</p>
</li>
<li>
<p><strong>NX_NO_MORE_ENTRIES</strong> (0x17) No more entries available in the default router table.</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IPv6 address</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library.</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) Not valid IPv6 address input</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance or storage space</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid router interface index</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_140">Allowed From</h3>
<div class="paragraph">
<p>Initialization, Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_140">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_139">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* This example adds a default router for the primary interface at
   fe80::1219:B9FF:FE37:ac to the default router table. */

#define PRIMARY_INTERFACE 0

NXD_ADDRESS router_address;

/* Set the router address version to IPv6 */
router_address.nxd_ip_version   = NX_IP_VERSION_V6;

/* Set the IPv6 address, in host byte order. */
router_address.nxd_ip_address[0] = 0xfe800000;
router_address.nxd_ip_address[1] = 0x0;
router_address.nxd_ip_address[2] = 0x1219B9FF;
router_address.nxd_ip_address[3] = 0xFE3700AC;

/* Set IPv6 default router. */
status = nxd_ipv6_default_router_add(ip_ptr, &amp;router_address,
                                     0xFFFF, PRIMARY_INTERFACE);

/* Unless invalid pointer input is detected by the error checking
   Service, status return is always NX_SUCCESS. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_140">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_gateway_address_clear</p>
</li>
<li>
<p>nx_ip_gateway_address_get</p>
</li>
<li>
<p>nx_ip_gateway_address_set</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_static_route_add</p>
</li>
<li>
<p>nx_ip_static_route_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_entry_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_number_of_entries_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_default_router_delete">nxd_ipv6_default_router_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Remove IPv6 Router from Default Router Table</p>
</div>
<div class="sect2">
<h3 id="_prototype_141">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_default_router_delete (
    NX_IP *ip_ptr,
    NXD_ADDRESS *router_address);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_141">Description</h3>
<div class="paragraph">
<p>This service deletes an IPv6 default router from the default router table. The equivalent NetX IPv4 service is <strong><em>nx_ip_gateway_address_clear</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_restrictions_2">Restrictions</h3>
<div class="paragraph">
<p>The IP instance has been created. <em>router_address</em> must point to valid information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_141">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to a previously created IP instance</p>
</li>
<li>
<p><em>router_address</em>: Pointer to the IPv6 default gateway address</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_140">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Router successfully deleted</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library.</p>
</li>
<li>
<p><strong>NX_NOT_FOUND</strong> (0x4E) The router entry cannot be found</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance or storage space</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x82) Invalid non pointer input</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_141">Allowed From</h3>
<div class="paragraph">
<p>Initialization, Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_141">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_140">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/*This example removes a default router:fe80::1219:B9FF:FE37:ac */

NXD_ADDRESS router_address;

/* Set the router_address version to IPv6 */
router_address.nxd_ip_version = NX_IP_VERSION_V6;

/* Program the IPv6 address, in host byte order. */
router_address.nxd_ip_address[0] = 0xfe800000;
router_address.nxd_ip_address[1] = 0x0;
router_address.nxd_ip_address[2] = 0x1219B9FF;
router_address.nxd_ip_address[3] = 0xFE3700AC;

/* Delete the IPv6 default router. */
nxd_ipv6_default_router_delete(ip_ptr, &amp;router_address);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_141">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_gateway_address_clearnx_ip_gateway_address_clear</p>
</li>
<li>
<p>nx_ip_gateway_address_get</p>
</li>
<li>
<p>nx_ip_gateway_address_set</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_static_route_add</p>
</li>
<li>
<p>nx_ip_static_route_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_add</p>
</li>
<li>
<p>nxd_ipv6_default_router_entry_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_number_of_entries_getnx_ip_gateway_address_get</p>
</li>
<li>
<p>nx_ip_gateway_address_set</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_static_route_add</p>
</li>
<li>
<p>nx_ip_static_route_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_add</p>
</li>
<li>
<p>nxd_ipv6_default_router_entry_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_number_of_entries_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_default_router_entry_get">nxd_ipv6_default_router_entry_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Get default router entry</p>
</div>
<div class="sect2">
<h3 id="_prototype_142">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_default_router_entry_get(
    NX_IP *ip_ptr,
    UINT interface_index,
    UINT entry_index,
    NXD_ADDRESS *router_addr,
    ULONG *router_lifetime,
    ULONG *prefix_length,
    ULONG *configuration_method);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_142">Description</h3>
<div class="paragraph">
<p>This service retrieves a router entry from the default IPv6 routing table that is attached to a specified network device.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_142">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface</p>
</li>
<li>
<p><em>entry_index</em>: Entry Index</p>
</li>
<li>
<p><em>router_addr</em>: Router IPv6 Address</p>
</li>
<li>
<p><em>router_lifetime</em>: Pointer to router life time</p>
</li>
<li>
<p><em>prefix_length</em>: Pointer to prefix length</p>
</li>
<li>
<p><em>configuration_method</em>: Pointer to the information on how the entry was configured</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_141">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful get</p>
</li>
<li>
<p><strong>NX_NOT_FOUND</strong> (0x4E) Router entry not found</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface index is not valid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_142">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_142">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_141">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PRIMARY_INTERFACE 0
NXD_ADDRESS            router_addr;
ULONG                  router_lifetime;
ULONG                  prefix_length;
ULONG                  configuration_method;

/* Get the router entry of specified interface. */
status = nxd_ipv6_default_router_entry_get (&amp;ip_0,
                                            PRIMARY_INTERFACE,
                                            entry_index,
                                            &amp;router_addr,
                                            &amp;router_lifetime,
                                            &amp;prefix_length,
                                            &amp;configuration_method);

/* If status == NX_SUCCESS, the router entry was successfully
   got. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_142">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_gateway_address_clear</p>
</li>
<li>
<p>nx_ip_gateway_address_get</p>
</li>
<li>
<p>nx_ip_gateway_address_set</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_static_route_add</p>
</li>
<li>
<p>nx_ip_static_route_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_add</p>
</li>
<li>
<p>nxd_ipv6_default_router_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_number_of_entries_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_default_router_get">nxd_ipv6_default_router_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve an IPv6 Router from Default Router Table</p>
</div>
<div class="sect2">
<h3 id="_prototype_143">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_default_router_get(
    NX_IP *ip_ptr,
    UINT interface_index
    NXD_ADDRESS *router_address,
    ULONG *router_lifetime,
    ULONG *prefix_length);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_143">Description</h3>
<div class="paragraph">
<p>This service retrieves an IPv6 default router address, lifetime and prefix length on the specified physical interface from the default router table. The equivalent NetX IPv4 service is <strong><em>nx_ip_gateway_address_get</em>.</strong></p>
</div>
<div class="paragraph">
<p><em>router_address</em> must point to a valid NXD_ADDRESS structure, so this service can fill in the IPv6 address of the default router.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_143">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance</p>
</li>
<li>
<p><em>interface_index</em>: The index to the network interface that the router is accessible through</p>
</li>
<li>
<p><em>router_address</em>: Pointer to the storage space for the return value of the default router address, in host byte order.</p>
</li>
<li>
<p><em>router_lifetime</em>: Pointer to the router lifetime</p>
</li>
<li>
<p><em>prefix_length</em>: Pointer to the router address prefix length</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_142">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Default router is successfully added</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library.</p>
</li>
<li>
<p><strong>NX_NOT_FOUND</strong> (0x4E) Default router not found</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid router interface index</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance or storage space</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_143">Allowed From</h3>
<div class="paragraph">
<p>Initialization, Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_143">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_142">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* This example retrieves a default router for the primary device
   from the default router table. */

#define PRIMARY_INTERFACE 0

NXD_ADDRESS router_address;
ULONG       router_lifetime;
ULONG       prefix_length;

/* Get IPv6 default router. */
status = nxd_ipv6_default_router_get(ip_ptr, PRIMARY_INTERFACE,
                                     &amp;router_address,
                                     &amp;router_lifetime,
                                     &amp;prefix_length);

/* If status returns NX_SUCCESS, the router address and related
   information is returned successfully. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_143">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_gateway_address_clear</p>
</li>
<li>
<p>nx_ip_gateway_address_get</p>
</li>
<li>
<p>nx_ip_gateway_address_set</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_static_route_add</p>
</li>
<li>
<p>nx_ip_static_route_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_add</p>
</li>
<li>
<p>nxd_ipv6_default_router_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_entry_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_number_of_entries_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_default_router_number_of_entries_get">nxd_ipv6_default_router_number_of_entries_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Get number of default IPv6 routers</p>
</div>
<div class="sect2">
<h3 id="_prototype_144">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_default_router_number_of_entries_get(
    NX_IP *ip_ptr,
    UINT interface_index,
    UINT *num_entries);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_144">Description</h3>
<div class="paragraph">
<p>This service retrieves the number of IPv6 default routers configured on a given network interface.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_144">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP control block pointer</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface</p>
</li>
<li>
<p><em>num_entries</em>: Destination for number of IPv6 routers on a specified network device</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_143">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful get</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index value is not valid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer or num_entries pointer</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_144">Allowed From</h3>
<div class="paragraph">
<p>Thread</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_144">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_143">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PRIMARY_INTERFACE 0
UINT                   num_entries;

/* Get the router entries of specified interface. */
status = nxd_ipv6_default_router_number_of_entries_get(&amp;ip_0,
                                                       PRIMARY_INTERFACE,
                                                       &amp;num_entries);

/* If status == NX_SUCCESS, the router entries was successfully
   retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_144">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_gateway_address_clear</p>
</li>
<li>
<p>nx_ip_gateway_address_get</p>
</li>
<li>
<p>nx_ip_gateway_address_set</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_static_route_add</p>
</li>
<li>
<p>nx_ip_static_route_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_add</p>
</li>
<li>
<p>nxd_ipv6_default_router_delete</p>
</li>
<li>
<p>nxd_ipv6_default_router_entry_get</p>
</li>
<li>
<p>nxd_ipv6_default_router_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_disable">nxd_ipv6_disable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Disable the IPv6 feature</p>
</div>
<div class="sect2">
<h3 id="_prototype_145">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_disable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_145">Description</h3>
<div class="paragraph">
<p>This service disables the IPv6 for the specified IP instance. It also clears the default router table, ND cache and IPv6 address table, leaves the all multicast groups, and resets the router solicitation variables. This service has no effect if IPv6 is not enabled.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_145">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP instance pointer</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_144">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful disable</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORT</strong> (0x4B) IPv6 module is not compiled</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_145">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_145">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_144">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Disable IPv6 feature on this IP instance. */
status = nxd_ipv6_disable(&amp;ip_0);

/* If status == NX_SUCCESS, disables IPv6 feature on IP instance.*/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_145">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_enable">nxd_ipv6_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable IPv6 Services</p>
</div>
<div class="sect2">
<h3 id="_prototype_146">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_enable(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_146">Description</h3>
<div class="paragraph">
<p>This service enables IPv6 services. When the IPv6 services are enabled, the IP instance joins the all-node multicast group (FF02::1). This service does not set the link local address or global address. Applications should use <em>nxd_ipv6_address_set</em> to configure the device network addresses. There is no NetX equivalent.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_146">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to the previously created IP instance</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_145">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) IPv6 is successfully enabled</p>
</li>
<li>
<p><strong>NX_ALREADY_ENABLED</strong> (0x15) IPv6 is already enabled</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_146">Allowed From</h3>
<div class="paragraph">
<p>Initialization, Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_146">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_145">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* First create an IP instance with packet pool, source address, and
   driver.*/
status = nx_ip_create(&amp;ip_0, "NetX IP Instance 0",
                      IP_ADDRESS(1,2,3,4),
                      0xFFFFFF00UL, &amp;pool_0,_nx_ram_network_driver,
                      pointer, 2048, 1);

/* Then enable IPv6 on the IP instance. */
status = nxd_ipv6_enable(&amp;ip_0);

/* A status return of NX_SUCCESS indicates that the IP instance is
   enabled for IPv6 services. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_146">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_multicast_interface_join">nxd_ipv6_multicast_interface_join</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Join an IPv6 multicast group</p>
</div>
<div class="sect2">
<h3 id="_prototype_147">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_multicast_interface_join(
    NX_IP *ip_ptr,
    NXD_ADDRESS *group_address,
    UINT interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_147">Description</h3>
<div class="paragraph">
<p>This service allows an application to join a specific IPv6 multicast address on a specific network interface. The link driver is notified to add the multicast address. This service is available if the NetX Duo library is built with the option <strong><em>NX_ENABLE_IPV6_MULTICAST</em></strong> defined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_147">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP instance pointer</p>
</li>
<li>
<p><em>group_address</em>: IPv6 multicast address</p>
</li>
<li>
<p><em>interface_index</em>: The index to the network interface associated with the multicast group</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_146">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully enables receiving on IPv6 multicast address</p>
</li>
<li>
<p><strong>NX_NO_MORE_ENTRIES</strong> (0x17) No more entries in the IPv6 multicast table.</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) No more group addresses available in the device driver</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature or IPv6 multicast feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IPv6 address</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface index is not valid</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_147">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_147">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_146">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PRIMARY_INTERFACE 0

/* Join multicast group on this IP instance. */
status = nxd_ipv6_multicast_interface_join(&amp;ip_0,
                                           &amp;group_address,
                                           PRIMARY_INTERFACE);

/* If status == NX_SUCCESS, interface of index on IP instance
   has joined the multicast group. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_147">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_igmp_enable</p>
</li>
<li>
<p>nx_igmp_info_getnx_igmp_loopback_disable</p>
</li>
<li>
<p>nx_igmp_loopback_enable</p>
</li>
<li>
<p>nx_igmp_multicast_interface_join</p>
</li>
<li>
<p>nx_igmp_multicast_join</p>
</li>
<li>
<p>nx_igmp_multicast_interface_leave</p>
</li>
<li>
<p>nx_igmp_multicast_leave</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_join</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_leave</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_leave</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_multicast_interface_leave">nxd_ipv6_multicast_interface_leave</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Leave an IPv6 multicast group</p>
</div>
<div class="sect2">
<h3 id="_prototype_148">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_multicast_interface_leave(
    NX_IP *ip_ptr,
    NXD_ADDRESS *group_address,
    UINT interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_148">Description</h3>
<div class="paragraph">
<p>This service removes the
specific IPv6 multicast address from the specific network device. The link driver is also notified of the removal of the IPv6 multicast address.This service is available if the NetX Duo library is built with the option <strong>NX_ENABLE_IPV6_MULTICAST</strong> defined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_148">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP instance pointer</p>
</li>
<li>
<p><em>group_address</em>: IPv6 multicast address</p>
</li>
<li>
<p><em>interface_index</em>: The index to the network interface associated with group</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_147">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful multicast leave</p>
</li>
<li>
<p><strong>NX_ENTRY_NOT_FOUND</strong> (0x16) Entry not found</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature or IPv6 multicast feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid IPv6 address</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface index is not valid</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_148">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_148">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_147">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PRIMARY_INTERFACE 0

/* Leave multicast address on this IP instance. */
status = nxd_ipv6_multicast_interface_leave(&amp;ip_0,
                                            &amp;group_address,
                                            primary_interface);

/* If status == NX_SUCCESS, interface of index on IP instance
   has left the multicast group. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_148">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_igmp_enable</p>
</li>
<li>
<p>nx_igmp_info_get</p>
</li>
<li>
<p>nx_igmp_loopback_disable</p>
</li>
<li>
<p>nx_igmp_loopback_enable</p>
</li>
<li>
<p>nx_igmp_multicast_interface_join</p>
</li>
<li>
<p>nx_igmp_multicast_join</p>
</li>
<li>
<p>nx_igmp_multicast_interface_leave</p>
</li>
<li>
<p>nx_igmp_multicast_leave</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_join</p>
</li>
<li>
<p>nx_ipv4_multicast_interface_leave</p>
</li>
<li>
<p>nxd_ipv6_multicast_interface_join</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_stateless_address_autoconfig_disable">nxd_ipv6_stateless_address_autoconfig_disable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Disable stateless address autoconfiguration</p>
</div>
<div class="sect2">
<h3 id="_prototype_149">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_stateless_address_autoconfig_disable(
    NX_IP *ip_ptr,
    UINT interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_149">Description</h3>
<div class="paragraph">
<p>This service disables the IPv6 stateless address auto configuration feature on a specified network device. It has no effect if the IPv6 address has been configured.</p>
</div>
<div class="paragraph">
<p>This service is available if the NetX Duo library is built with the option <strong>NX_IPV6_STATELESS_AUTOCONFIG_CONTROL</strong> defined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_149">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP instance pointer</p>
</li>
<li>
<p><em>interface_index</em>: The index to the network interface that the IPv6 stateless address autoconfiguration should be disabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_148">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully disables stateless address autoconfigure feature.</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature or IPv6 stateless address autoconfig control feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface index is not valid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_149">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_149">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_148">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PRIMARY_INTERFACE 0

/* Disable stateless address auto configuration on this IP instance. */
status = nxd_ipv6_stateless_address_autoconfig_disable(&amp;ip_0,
                                                       PRIMARY_INTERFACE);

/* If status == NX_SUCCESS, disables stateless address auto
   configuration on IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_149">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_enable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_ipv6_stateless_address_autoconfig_enable">nxd_ipv6_stateless_address_autoconfig_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enable stateless address autoconfiguration</p>
</div>
<div class="sect2">
<h3 id="_prototype_150">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_ipv6_stateless_address_autoconfig_enable(
    NX_IP *ip_ptr,
    UINT interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_150">Description</h3>
<div class="paragraph">
<p>This service enables the IPv6 stateless address auto configuration feature on a specified network device.</p>
</div>
<div class="paragraph">
<p>This service is available if the NetX Duo library is built with the option <strong>NX_IPV6_STATELESS_AUTOCONFIG_CONTROL</strong> defined.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_150">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: IP instance pointer</p>
</li>
<li>
<p><em>interface_index</em>: The index to the network interface that the IPv6 stateless address autoconfiguration should be enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_149">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully enables stateless address autoconfig feature.</p>
</li>
<li>
<p><strong>NX_ALREADY_ENABLED</strong> (0x15) Already enabled</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature or IPv6 stateless address autoconfig control feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Interface index is not valid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP control block pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_150">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_150">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_149">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PRIMARY_INTERFACE

/* Enable stateless address auto configuration on this
   IP instance. */
status = nxd_ipv6_stateless_address_autoconfig_enable(&amp;ip_0,
                                                      PRIMARY_INTERFACE);

/* If status == NX_SUCCESS, enables stateless address auto
   configuration on IP instance. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_150">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_ip_auxiliary_packet_pool_set</p>
</li>
<li>
<p>nx_ip_address_change_notify</p>
</li>
<li>
<p>nx_ip_address_get</p>
</li>
<li>
<p>nx_ip_address_set</p>
</li>
<li>
<p>nx_ip_create</p>
</li>
<li>
<p>nx_ip_delete</p>
</li>
<li>
<p>nx_ip_driver_direct_command</p>
</li>
<li>
<p>nx_ip_driver_interface_direct_command</p>
</li>
<li>
<p>nx_ip_forwarding_disable</p>
</li>
<li>
<p>nx_ip_forwarding_enable</p>
</li>
<li>
<p>nx_ip_fragment_disable</p>
</li>
<li>
<p>nx_ip_fragment_enable</p>
</li>
<li>
<p>nx_ip_info_get</p>
</li>
<li>
<p>nx_ip_max_payload_size_find</p>
</li>
<li>
<p>nx_ip_status_check</p>
</li>
<li>
<p>nx_system_initialize</p>
</li>
<li>
<p>nxd_ipv6_address_change_notify</p>
</li>
<li>
<p>nxd_ipv6_address_delete</p>
</li>
<li>
<p>nxd_ipv6_address_get</p>
</li>
<li>
<p>nxd_ipv6_address_set</p>
</li>
<li>
<p>nxd_ipv6_disable</p>
</li>
<li>
<p>nxd_ipv6_enable</p>
</li>
<li>
<p>nxd_ipv6_stateless_address_autoconfig_disable</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_nd_cache_entry_delete">nxd_nd_cache_entry_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Delete IPv6 Address entry in the Neighbor Cache</p>
</div>
<div class="sect2">
<h3 id="_prototype_151">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_nd_cache_entry_delete(
    NX_IP *ip_ptr,
    ULONG *ip_address);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_151">Description</h3>
<div class="paragraph">
<p>This service deletes an IPv6 neighbor discovery cache entry for the supplied IP address. The equivalent NetX IPv4 function is <strong><em>nx_arp_static_entry_delete</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_151">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to IPv6 address to delete, in host byte order</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_150">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully deleted the address</p>
</li>
<li>
<p><strong>NX_ENTRY_NOT_FOUND</strong> (0x16) Address not found in the IPv6 neighbor cache</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance or storage space</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_151">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_151">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_150">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* This example deletes an entry from the neighbor cache table. */

NXD_ADDRESS ip_address;

ip_address.nxd_ip_address_version = NX_IP_VERSION_V6;
ip_address.nxd_ip_address.v6[0]   = 0x20011234;
ip_address.nxd_ip_address.v6[1]   = 0x56780000;
ip_address.nxd_ip_address.v6[2]   = 0;
ip_address.nxd_ip_address.v6[3]   = 1;

/* Delete an entry in the neighbor cache table with the specified IPv6
   address and hardware address. */
status = nxd_nd_cache_entry_delete(&amp;ip_0,
                                   &amp;ip_address.nxd_ip_address.v6[0]);

/* If status == NX_SUCCESS, the entry was deleted from the neighbor cache
   table. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_151">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_nd_cache_entry_set">nxd_nd_cache_entry_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Add an IPv6 Address/MAC Mapping to Neighbor Cache</p>
</div>
<div class="sect2">
<h3 id="_prototype_152">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_nd_cache_entry_set(
    NX_IP *ip_ptr,
    NXD_ADDRESS *dest_ip,
    UINT interface_index,
    char *mac);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_152">Description</h3>
<div class="paragraph">
<p>This service adds an entry to the neighbor discovery cache for the specified IP address <em>ip_address</em> mapped to the hardware MAC address on the specified network interface index (interface_index). The equivalent NetX IPv4 service is <strong><em>nx_arp_static_entry_create</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_152">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance</p>
</li>
<li>
<p><em>dest_ip</em>: Pointer to IPv6 address instance</p>
</li>
<li>
<p><em>interface_index</em>: Index specifying physical network interface where the destination IPv6 address can be reached</p>
</li>
<li>
<p><em>mac</em>: Pointer to hardware address.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_151">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Entry successfully added</p>
</li>
<li>
<p><strong>NX_NOT_SUCCESSFUL</strong> (0x43) Invalid cache or no neighbor cache entries available</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance or storage space</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid interface index value.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_152">Allowed From</h3>
<div class="paragraph">
<p>Initialization, Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_152">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_151">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* This example adds an entry on the primary network interface to
   the neighbor cache table. */

#define PRIMARY_INTEFACE 0

NXD_ADDRESS ip_address;
UCHAR hw_address[6] = {0x0, 0xcf,0x01,0x02, 0x03, 0x04};
CHAR  *mac;

mac = (CHAR *)&amp;hw_address[0];

ip_address.nxd_ip_address_version = NX_IP_VERSION_V6;
ip_address.nxd_ip_address.v6[0]   = 0x20011234;
ip_address.nxd_ip_address.v6[1]   = 0x56780000;
ip_address.nxd_ip_address.v6[2]   = 0;
ip_address.nxd_ip_address.v6[3]   = 1;

/* Create an entry in the neighbor cache table with the specified
   IPv6 address and hardware address. */
status = nxd_nd_cache_entry_set(&amp;ip_0,
                                &amp;ip_address.nxd_ip_address.v6[0],
                                PRIMARY_INTERFACE, mac);

/* If status == NX_SUCCESS, the entry was added to the neighbor
   cache table. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_152">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_nd_cache_hardware_address_find">nxd_nd_cache_hardware_address_find</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Locate Hardware Address for an IPv6 Address</p>
</div>
<div class="sect2">
<h3 id="_prototype_153">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_nd_cache_hardware_address_find(
    NX_IP *ip_ptr,
    NXD_ADDRESS *ip_address,
    ULONG *physical_msw,
    ULONG *physical_lsw
    UINT *interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_153">Description</h3>
<div class="paragraph">
<p>This service attempts to find a physical hardware address in the IPv6 neighbor discovery cache that is associated with the supplied IPv6 address. The index of the network interface through which the neighbor can be reached is also returned in the parameter <em>interface_index.</em> The equivalent NetX IPv4 service is <strong><em>nx_arp_hardware_address_find</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_153">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to IP address to find, host byte order</p>
</li>
<li>
<p><em>physical_msw</em>: Pointer to the top 16 bits (47-32) of the physical address, in host byte order</p>
</li>
<li>
<p><em>physical_lsw</em>: Pointer to the lower 32 bits (31-0) of the physical address in host byte order</p>
</li>
<li>
<p><em>interface_index</em>: Pointer to the valid memory location for the interface index specifying the network device on which the IPv6 address can be reached.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_152">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully found the address</p>
</li>
<li>
<p><strong>NX_ENTRY_NOT_FOUND</strong> (0x16) Mapping not in the neighbor cache</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) The supplied IP address is not version 6.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance or storage space</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_153">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_153">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_152">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* This example inputs an IP address on the primary network in order
   to obtain the hardware address it is mapped to in the neighbor
   cache able. */

NXD_ADDRESS  ip_address;
ULONG physical_msw, physical_lsw;
UINT  interface_index;

ip_address.nxd_ip_address_version = NX_IP_VERSION_V6;
ip_address.nxd_ip_address.v6[0]   = 0x20011234;
ip_address.nxd_ip_address.v6[1]   = 0x56780000;
ip_address.nxd_ip_address.v6[2]   = 0;
ip_address.nxd_ip_address.v6[3]   = 1;

/* Obtain the hardware address mapped to the supplied global IPv6
   address. */
status = nxd_nd_cache_hardware_address_find(&amp;ip_0, &amp;ip_address,
                                            &amp;physical_msw,
                                            &amp;physical_lsw
                                            &amp;interface_index);

/* If status == NX_SUCCESS, a matching entry was found in the
   neighbor cache table and the hardware address returned in
   variables physical_msw and physical_lsw, the index of the network
   interface through which the neighbor can be reached is stored in
   interface_index. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_153">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_nd_cache_invalidate">nxd_nd_cache_invalidate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Invalidate the Neighbor Discovery Cache</p>
</div>
<div class="sect2">
<h3 id="_prototype_154">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_nd_cache_invalidate(NX_IP *ip_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_154">Description</h3>
<div class="paragraph">
<p>This service invalidates the entire IPv6 neighbor discovery cache. This service can be invoked either before or after ICMPv6 has been enabled. This service is not applicable to IPv4 connectivity, so there
is no NetX equivalent service.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_154">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to IP instance</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_153">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Cache successfully invalidated</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_154">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_154">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_153">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* This example invalidates the host neighbor cache table. */

/* Invalidate the cache table bound to the IP instance. */
status = nxd_nd_cache_invalidate (&amp;ip_0);

/* If status == NX_SUCCESS, all entries in the neighbor cache table
   are invalidated. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_154">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_ip_address_find</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_nd_cache_ip_address_find">nxd_nd_cache_ip_address_find</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve IPv6 Address for a Physical Address</p>
</div>
<div class="sect2">
<h3 id="_prototype_155">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_nd_cache_ip_address_find(
    NX_IP *ip_ptr,
    NXD_ADDRESS *ip_address,
    ULONG physical_msw,
    ULONG physical_lsw,
    UINT *interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_155">Description</h3>
<div class="paragraph">
<p>This service attempts to find an IPv6 address in the IPv6 neighbor discovery cache that is associated with the supplied physical address. The index of the network interface through which the neighbor can be reached is also returned. The equivalent NetX IPv4 service is <strong><em>nx_arp_ip_address_find</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_155">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to valid NXD_ADDRESS structure</p>
</li>
<li>
<p><em>physical_msw</em>: Top 16 bits (47-32) of the physical address to find, host byte order</p>
</li>
<li>
<p><em>physical_lsw</em>: Lower 32 bits (31-0) of the physical address to find, host byte order</p>
</li>
<li>
<p><em>interface_index</em>: Pointer to the network device index through which the IPv6 address can be reached</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_154">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successfully found the address</p>
</li>
<li>
<p><strong>NX_ENTRY_NOT_FOUND</strong> (0x16) Physical address not found in the neighbor cache</p>
</li>
<li>
<p><strong>NX_NOT_SUPPORTED</strong> (0x4B) IPv6 feature is not built into the NetX Duo library</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance or storage space</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) MAC address is zero.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_155">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_155">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_154">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* This example inputs a hardware address to search on for the
   matching IPv6 global address in the neighbor cache table. */

NXD_ADDRESS ip_address;
ULONG physical_msw = 0xcf;
ULONG physical_lsw = 0x01020304;
UINT  interface_index;

/* Obtain the IPv6 address mapped to the supplied hardware
   Address on the primary device. */
status = nxd_nd_cache_ip_address_find(&amp;ip_0, &amp;ip_address,
                                      physical_msw, physical_lsw,
                                      &amp;interface_index);

/* If status == NX_SUCCESS, a matching entry was found in the
   neighbor cache table and the global IPv6 address returned in
   variable ip_address. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_155">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_arp_dynamic_entries_invalidate</p>
</li>
<li>
<p>nx_arp_dynamic_entry_set</p>
</li>
<li>
<p>nx_arp_enable</p>
</li>
<li>
<p>nx_arp_entry_delete</p>
</li>
<li>
<p>nx_arp_gratuitous_send</p>
</li>
<li>
<p>nx_arp_hardware_address_find</p>
</li>
<li>
<p>nx_arp_info_get</p>
</li>
<li>
<p>nx_arp_ip_address_find</p>
</li>
<li>
<p>nx_arp_static_entries_delete</p>
</li>
<li>
<p>nx_arp_static_entry_create</p>
</li>
<li>
<p>nx_arp_static_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_delete</p>
</li>
<li>
<p>nxd_nd_cache_entry_set</p>
</li>
<li>
<p>nxd_nd_cache_hardware_address_find</p>
</li>
<li>
<p>nxd_nd_cache_invalidate</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_tcp_client_socket_connect">nxd_tcp_client_socket_connect</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Make a TCP Connection</p>
</div>
<div class="sect2">
<h3 id="_prototype_156">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_tcp_client_socket_connect(
    NX_TCP_SOCKET *socket_ptr
    NXD_ADDRESSS *server_ip,
    UINT server_port,
    ULONG wait_option);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_156">Description</h3>
<div class="paragraph">
<p>This service makes TCP connection using a previously created TCP client socket to the specified server&#8217;s port. This service works on either IPv4 or IPv6 networks. Valid TCP server ports range from 0 through 0xFFFF. NetX Duo determines the appropriate physical interface based on the server IP address. The NetX IPv4 equivalent is <strong><em>nx_tcp_client_socket_connect</em></strong>.</p>
</div>
<div class="paragraph">
<p>The socket must have been bound to a local port.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_156">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created TCP socket</p>
</li>
<li>
<p><em>server_ip</em>: Pointer to IPv4 or IPv6 destination address, in host byte order</p>
</li>
<li>
<p><em>server_port</em>: Server port number to connect to (1 through 0xFFFF), in host byte order</p>
</li>
<li>
<p><em>wait_option</em>: Wait option while the connection is being established. The wait options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>NX_NO_WAIT</strong> (0x00000000)</p>
</li>
<li>
<p><strong>NX_WAIT_FOREVER</strong> (0xFFFFFFFF)</p>
</li>
<li>
<p><strong>timeout value in ticks</strong> (0x00000001 through 0xFFFFFFFE)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_155">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket connect</p>
</li>
<li>
<p><strong>NX_WAIT_ABORTED</strong> (0x1A) Requested suspension was aborted by a call to tx_thread_wait_abort</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid server IPv4 or IPv6 address</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket is not bound</p>
</li>
<li>
<p><strong>NX_NOT_CLOSED</strong> (0x35) Socket is not in a closed state</p>
</li>
<li>
<p><strong>NX_IN_PROGRESS</strong> (0x37) No wait was specified, connection attempt is in progress</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid interface index.</p>
</li>
<li>
<p><strong>NX_NO_INTERFACE_ADDRESS</strong> (0x50) The network interface does not have valid IPv6 address</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP not enabled</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) Invalid port</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_NOT_CONNECTED</strong> (0x38) Connection fails.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_156">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_156">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_155">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NXD_ADDRESS peer_ip_address;
ULONG       peer_port;

/* Set Peer IPv6 address */
peer_ip_address.nxd_ip_version = NX_IP_VERSION_V6;
peer_ip_address.nxd_ip_address.v6[0] = 0x20010000;
peer_ip_address.nxd_ip_address.v6[1] = 0;
peer_ip_address.nxd_ip_address.v6[2] = 0;
peer_ip_address.nxd_ip_address.v6[3] = 0x101;

/* Set peer port number */
peer_port = 2563;

/* Connect to the peer */
status = nxd_tcp_client_socket_connect(socket_ptr,
                                       &amp;peer_ip_address,
                                       peer_port, NX_WAIT_FOREVER);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_156">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_socket_peer_info_get</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_tcp_socket_peer_info_get">nxd_tcp_socket_peer_info_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieves Peer TCP Socket IP Address and Port Number</p>
</div>
<div class="sect2">
<h3 id="_prototype_157">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_tcp_socket_peer_info_get
    (NX_TCP_SOCKET *socket_ptr,
    NXD_ADDRESS *peer_ip_address,
    ULONG *peer_port);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_157">Description</h3>
<div class="paragraph">
<p>This service retrieves peer IP address and port information for the connected TCP socket over either IPv4 or IPv6 network. The equivalent NetX IPv4 service is <strong><em>nx_tcp_socket_peer_info_get</em></strong>.</p>
</div>
<div class="paragraph">
<p>Note that <em>socket_ptr</em> must point to a TCP socket that is already in the connected state.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_157">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to TCP socket connected to peer host</p>
</li>
<li>
<p><em>peer_ip_address</em>: Pointer to IPv4 or IPv6 peer address. The returned IP address is in host byte order.</p>
</li>
<li>
<p><em>peer_port</em>: Pointer to peer port number. The returned port number is in host byte order.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_156">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Socket information successfully retrieved</p>
</li>
<li>
<p><strong>NX_NOT_CONNECTED</strong> (0x38) Socket not connected to peer</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) TCP not enabled</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointer input</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_157">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_157">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_156">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NXD_ADDRESS  peer_ip_address;
ULONG        peer_port;

/* Get TCP socket information. */
status = nxd_tcp_socket_peer_info_get(socket_ptr, &amp;peer_ip_address,
                                      &amp;peer_port);

/* If status == NX_SUCCESS, the service returns valid peer info: */
if(peer_ip_address.nxd_ip_version == NX_IP_VERSION_V4)
    /* Peer IP address is stored in
       peer_ip_address.nxd_ip_address.v4 */

if(peer_ip_address.nxd_ip_version == NX_IP_VERSION_V6)
    /* Peer IP address is stored in
       peer_ip_address.nxd_ip_address.v6 */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_157">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_tcp_client_socket_bind</p>
</li>
<li>
<p>nx_tcp_client_socket_connect</p>
</li>
<li>
<p>nx_tcp_client_socket_port_get</p>
</li>
<li>
<p>nx_tcp_client_socket_unbind</p>
</li>
<li>
<p>nx_tcp_enable</p>
</li>
<li>
<p>nx_tcp_free_port_find</p>
</li>
<li>
<p>nx_tcp_info_get</p>
</li>
<li>
<p>nx_tcp_server_socket_accept</p>
</li>
<li>
<p>nx_tcp_server_socket_listen</p>
</li>
<li>
<p>nx_tcp_server_socket_relisten</p>
</li>
<li>
<p>nx_tcp_server_socket_unaccept</p>
</li>
<li>
<p>nx_tcp_server_socket_unlisten</p>
</li>
<li>
<p>nx_tcp_socket_bytes_available</p>
</li>
<li>
<p>nx_tcp_socket_create</p>
</li>
<li>
<p>nx_tcp_socket_delete</p>
</li>
<li>
<p>nx_tcp_socket_disconnect</p>
</li>
<li>
<p>nx_tcp_socket_info_get</p>
</li>
<li>
<p>nx_tcp_socket_receive</p>
</li>
<li>
<p>nx_tcp_socket_receive_queue_max_set</p>
</li>
<li>
<p>nx_tcp_socket_send</p>
</li>
<li>
<p>nx_tcp_socket_state_wait</p>
</li>
<li>
<p>nxd_tcp_client_socket_connect</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_udp_packet_info_extract">nxd_udp_packet_info_extract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Extract network parameters from UDP packet</p>
</div>
<div class="sect2">
<h3 id="_prototype_158">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_udp_packet_info_extract(
    NX_PACKET *packet_ptr,
    NXD_ADDRESS *ip_address,
    UINT *protocol,
    UINT *port,
    UINT *interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_158">Description</h3>
<div class="paragraph">
<p>This service extracts network parameters from a packet received on either IPv4 or IPv6 UDP networks. The NetX equivalent service is <strong><em>nx_udp_packet_info_extract.</em></strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_158">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>packet_ptr</em>: Pointer to packet.</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to sender IP address.</p>
</li>
<li>
<p><em>protocol</em>: Pointer to protocol to be returned.</p>
</li>
<li>
<p><em>port</em>: Pointer to sender&#8217;s port number.</p>
</li>
<li>
<p><em>interface_index</em>: Pointer to the index of the network interface from which this packet is received</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_157">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Packet interface data successfully extracted.</p>
</li>
<li>
<p><strong>NX_INVALID_PACKET</strong> (0x12) Packet is neither IPv4 or IPv6.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid pointer input</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_158">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_158">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_157">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Extract network data from UDP packet interface.*/
status = nxd_udp_packet_info_extract(packet_ptr, &amp;ip_address,
                                    &amp;protocol, &amp;port,
                                    &amp;interface_index);

/* If status is NX_SUCCESS packet data was successfully retrieved.*/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_158">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_udp_socket_send">nxd_udp_socket_send</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send a UDP Datagram</p>
</div>
<div class="sect2">
<h3 id="_prototype_159">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_udp_socket_send(
    NX_UDP_SOCKET *socket_ptr,
    NX_PACKET *packet_ptr,
    NXD_ADDRESS *ip_address,
    UINT port);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_159">Description</h3>
<div class="paragraph">
<p>This service sends a UDP datagram through a previously created and bound UDP socket for either IPv4 or IPv6 networks. NetX Duo finds a suitable local IP address as source address based on the destination IP address. To specify a specific interface and source IP address, the application should use the <strong>nxd_udp_socket_source_send</strong> service.</p>
</div>
<div class="paragraph">
<p>Note that this service returns immediately regardless of whether the UDP datagram was successfully sent. The NetX (IPv4) equivalent service is <strong><em>nx_udp_socket_send</em></strong>.</p>
</div>
<div class="paragraph">
<p>The socket must be bound to a local port.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Unless an error is returned, the application should not release the packet after this call. Doing so will cause unpredictable results because the network driver will also try to release the packet after
transmission</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_159">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created UDP socket instance</p>
</li>
<li>
<p><em>packet_ptr</em>: UDP datagram packet pointer</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to destination IPv4 or IPv6 address</p>
</li>
<li>
<p><em>port</em>: Valid destination port number between 1 and 0xFFFF), in host byte order</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_158">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful UDP socket send</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid server IPv4 or IPv6 address</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket not bound to any port</p>
</li>
<li>
<p><strong>NX_NO_INTERFACE_ADDRESS</strong> (0x50) No suitable outgoing interface can be found.</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Not enough room for UDP header in the packet</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Packet append pointer is invalid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer, address pointer, or packet pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) UDP has not been enabled</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) Port number is not within a valid range</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_159">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_159">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_158">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NXD_ADDRESS ip_address, server_address;

/* Set the UDP Client IPv6 address. */
ip_address.nxd_ip_version = NX_IP_VERSION_V6;
ip_address.nxd_ip_address.v6[0] = 0x20010000;
ip_address.nxd_ip_address.v6[1] = 0;
ip_address.nxd_ip_address.v6[2] = 0;
ip_address.nxd_ip_address.v6[3] = 1;

/* Set the UDP server IPv6 address to send to. */
server_address.nxd_ip_version = NX_IP_VERSION_V6;
server_address.nxd_ip_address.v6[0] = 0x20010000;
server_address.nxd_ip_address.v6[1] = 0;
server_address.nxd_ip_address.v6[2] = 0;
server_address.nxd_ip_address.v6[3] = 2;

/* Set the global address (indicated by the 64 bit prefix) using the
   IPv6 address just created on the primary device (index 0). We
   don't need the index into the address table, so the last argument
   is set to null. */

interface_index = 0;
status = nxd_ipv6_address_set(&amp;client_ip, interface_index,
                              &amp;ip_address, 64, NX_NULL);

/* Create the UDP socket client_socket with the ip_address and
   allocate a packet pointed to by packet_ptr (not shown). */

/* Send a packet to the UDP server at server_address on port 12. */
status = nxd_udp_socket_send(&amp;client_socket, packet_ptr,
                             &amp;server_address, 12);

/* If status == NX_SUCCESS, the UDP host successfully transmitted
   the packet out the UDP socket to the server. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_159">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_udp_socket_source_send">nxd_udp_socket_source_send</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send a UDP Datagram</p>
</div>
<div class="sect2">
<h3 id="_prototype_160">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_udp_socket_source_send(
    NX_UDP_SOCKET *socket_ptr,
    NX_PACKET *packet_ptr,
    NXD_ADDRESS *ip_address,
    UINT port,
    UINT address_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_160">Description</h3>
<div class="paragraph">
<p>This service sends a UDP datagram through a previously created and bound UDP socket for either IPv4 or IPv6 networks. The parameter <em>address_index</em> specifies the source IP address to use for the outgoing packet. Note that the function returns immediately regardless of whether the UDP datagram was successfully sent.</p>
</div>
<div class="paragraph">
<p>The socket must be bound to a local port.</p>
</div>
<div class="paragraph">
<p>The NetX (IPv4) equivalent service is <strong><em>nx_udp_socket_source_send</em></strong>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Unless an error is returned, the application should not release the packet after this call. Doing so will cause unpredictable results because the network driver will also try to release the packet after
transmission</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_160">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>socket_ptr</em>: Pointer to previously created UDP socket instance</p>
</li>
<li>
<p><em>packet_ptr</em>: UDP datagram packet pointer</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to destination IPv4 or IPv6 address port Valid destination port number between 1 and 0xFFFF), in host byte order</p>
</li>
<li>
<p><em>address_index</em>: Index specifying the source address to use for the packet</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_159">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful UDP socket send</p>
</li>
<li>
<p><strong>NX_IP_ADDRESS_ERROR</strong> (0x21) Invalid server IPv4 or IPv6 address</p>
</li>
<li>
<p><strong>NX_NOT_BOUND</strong> (0x24) Socket not bound to any port</p>
</li>
<li>
<p><strong>NX_NO_INTERFACE_ADDRESS</strong> (0x50) No suitable outgoing interface can be found.</p>
</li>
<li>
<p><strong>NX_NOT_FOUND</strong> (0x4E) No suitable interface can be found</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer, address, or packet pointer.</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
<li>
<p><strong>NX_NOT_ENABLED</strong> (0x14) UDP has not been enabled</p>
</li>
<li>
<p><strong>NX_INVALID_PORT</strong> (0x46) Port number is not within valid range.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Specified network interface is valid</p>
</li>
<li>
<p><strong>NX_UNDERFLOW</strong> (0x02) Not enough room for UDP header in the packet</p>
</li>
<li>
<p><strong>NX_OVERFLOW</strong> (0x03) Packet append pointer is invalid</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_160">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_160">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_159">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NXD_ADDRESS ip_address, server_address;
UINT address_index;

/* Set the UDP Client IPv6 address. */
ip_address.nxd_ip_version = NX_IP_VERSION_V6;
ip_address.nxd_ip_address.v6[0] = 0x20010000;
ip_address.nxd_ip_address.v6[1] = 0;
ip_address.nxd_ip_address.v6[2] = 0;
ip_address.nxd_ip_address.v6[3] = 1;

/* Set the UDP server IPv6 address to send to. */
server_address.nxd_ip_version = NX_IP_VERSION_V6;
server_address.nxd_ip_address.v6[0] = 0x20010000;
server_address.nxd_ip_address.v6[1] = 0;
server_address.nxd_ip_address.v6[2] = 0;
server_address.nxd_ip_address.v6[3] = 2;

/* Set the global address (indicated by the 64 bit prefix) using the IPv6
   address just created on the primary device (index 0). The address index
   is needed for nxd_udp_socket_source_send. */

status = nxd_ipv6_address_set(&amp;client_ip, 0,
                              &amp;ip_address, 64, &amp;address_index);

/* Create the UDP socket client_socket with the ip_address and
   allocate a packet pointed to by packet_ptr (not shown). */

/* Send a packet to the UDP server at server_address on port 12. */
status = nxd_udp_socket_source_send(&amp;client_socket, packet_ptr,
                                    &amp;server_address, 12, address_index);

/* If status == NX_SUCCESS, the UDP host successfully transmitted the
   packet out the UDP socket to the server. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_160">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_source_extract</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nxd_udp_source_extract">nxd_udp_source_extract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Retrieve UPD Packet Source Information</p>
</div>
<div class="sect2">
<h3 id="_prototype_161">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nxd_udp_source_extract(
    NX_PACKET *packet_ptr,
    NXD_ADDRESS *ip_address,
    UINT *port);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_161">Description</h3>
<div class="paragraph">
<p>This service extracts the source IP address and port number from a UDP packet received through the host UDP socket. The NetX (IPv4) equivalent is <strong><em>nx_udp_source_extract</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_161">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>packet_ptr</em>: Pointer to received UDP packet</p>
</li>
<li>
<p><em>ip_address</em>: Pointer to NXD_ADDRESS structure to store packet source IP address</p>
</li>
<li>
<p><em>port</em>: Pointer to UDP socket port number</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_160">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful source extract</p>
</li>
<li>
<p><strong>NX_INVALID_PACKET</strong> (0x12) Packet is not valid</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid socket pointer</p>
</li>
<li>
<p><strong>NX_CALLER_ERROR</strong> (0x11) Invalid caller of this service</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_161">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_161">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_160">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NXD_ADDRESS ip_address;
UINT         port;

/* Create the UDP socket client_socket and
   allocate the packet pointed to by packet_ptr (not shown). */

/* Extract the IP address and port of the packet received on the UDP
   socket specified in the packet interface. */
status = nxd_udp_source_extract(&amp;packet_ptr, &amp;ip_address, &amp;port);

/* If status == NX_SUCCESS, the source IP address and port of the
   packet received on the UDP socket was successfully extracted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_161">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_udp_enable</p>
</li>
<li>
<p>nx_udp_free_port_find</p>
</li>
<li>
<p>nx_udp_info_get</p>
</li>
<li>
<p>nx_udp_packet_info_extract</p>
</li>
<li>
<p>nx_udp_socket_bind</p>
</li>
<li>
<p>nx_udp_socket_bytes_available</p>
</li>
<li>
<p>nx_udp_socket_checksum_disable</p>
</li>
<li>
<p>nx_udp_socket_checksum_enable</p>
</li>
<li>
<p>nx_udp_socket_create</p>
</li>
<li>
<p>nx_udp_socket_delete</p>
</li>
<li>
<p>nx_udp_socket_info_get</p>
</li>
<li>
<p>nx_udp_socket_port_get</p>
</li>
<li>
<p>nx_udp_socket_receive</p>
</li>
<li>
<p>nx_udp_socket_receive_notify</p>
</li>
<li>
<p>nx_udp_socket_send</p>
</li>
<li>
<p>nx_udp_socket_source_send</p>
</li>
<li>
<p>nx_udp_socket_unbind</p>
</li>
<li>
<p>nx_udp_source_extract</p>
</li>
<li>
<p>nxd_udp_packet_info_extract</p>
</li>
<li>
<p>nxd_udp_socket_send</p>
</li>
<li>
<p>nxd_udp_socket_source_send</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_link_vlan_set">nx_link_vlan_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sets VLAN tag to interface.</p>
</div>
<div class="sect2">
<h3 id="_prototype_162">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_link_vlan_set(NX_IP *ip_ptr, UINT interface_index, UINT vlan_tag)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_162">Description</h3>
<div class="paragraph">
<p>This function sets VLAN tag to interface. VLAN tag is comprised the PCP and VLAN ID, encoded in host byte order. The PCP is the 3 most significant bits and the VLAN ID is the 12 least significant bits. The PCP is used to prioritize the packet and the VLAN ID is used to identify the VLAN.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_162">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface to set the VLAN tag.</p>
</li>
<li>
<p><em>vlan_tag</em>: VLAN tag to set to the interface.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_161">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket checksum disable.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid interface index.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_162">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_161">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT vlan_tag = 0x810;
UINT interface_index = 0;

/* Set VLAN tag to interface. */
status = nx_link_vlan_set(&amp;ip_0, interface_index, vlan_tag);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_162">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_link_vlan_get</p>
</li>
<li>
<p>nx_link_vlan_clear</p>
</li>
<li>
<p>nx_link_multicast_join</p>
</li>
<li>
<p>nx_link_multicast_leave</p>
</li>
<li>
<p>nx_link_ethernet_packet_send</p>
</li>
<li>
<p>nx_link_raw_packet_send</p>
</li>
<li>
<p>nx_link_packet_receive_callback_add</p>
</li>
<li>
<p>nx_link_packet_receive_callback_remove</p>
</li>
<li>
<p>nx_link_ethernet_header_parse</p>
</li>
<li>
<p>nx_link_vlan_interface_create</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_link_vlan_get">nx_link_vlan_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Get VLAN tag from interface.</p>
</div>
<div class="sect2">
<h3 id="_prototype_163">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_link_vlan_get(NX_IP *ip_ptr, UINT interface_index, UINT *vlan_tag)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_163">Description</h3>
<div class="paragraph">
<p>This function gets VLAN tag from interface, VLAN tag is comprised the PCP and VLAN ID, encoded in host byte order. The PCP is the 3 most significant bits and the VLAN ID is the 12 least significant bits. The PCP is used to prioritize the packet and the VLAN ID is used to identify the VLAN.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_163">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface to get the VLAN tag.</p>
</li>
<li>
<p><em>vlan_tag</em>: Pointer to store the VLAN tag.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_162">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket checksum disable.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid interface index.</p>
</li>
<li>
<p><strong>NX_NOT_FOUND</strong> (0x4E) VLAN tag not found.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_163">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_162">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT vlan_tag;
UINT interface_index = 0;

/* Get VLAN tag from interface. */
status = nx_link_vlan_get(&amp;ip_0, interface_index, &amp;vlan_tag);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_163">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_link_vlan_set</p>
</li>
<li>
<p>nx_link_vlan_clear</p>
</li>
<li>
<p>nx_link_multicast_join</p>
</li>
<li>
<p>nx_link_multicast_leave</p>
</li>
<li>
<p>nx_link_ethernet_packet_send</p>
</li>
<li>
<p>nx_link_raw_packet_send</p>
</li>
<li>
<p>nx_link_packet_receive_callback_add</p>
</li>
<li>
<p>nx_link_packet_receive_callback_remove</p>
</li>
<li>
<p>nx_link_ethernet_header_parse</p>
</li>
<li>
<p>nx_link_vlan_interface_create</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_link_vlan_clear">nx_link_vlan_clear</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clears VLAN tag from interface.</p>
</div>
<div class="sect2">
<h3 id="_prototype_164">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_link_vlan_clear(NX_IP *ip_ptr, UINT interface_index)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_164">Description</h3>
<div class="paragraph">
<p>This function clears VLAN tag from interface.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_164">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface to clear the VLAN tag.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_163">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful socket checksum disable.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP instance.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid interface index.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_164">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_163">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT interface_index = 0;

/* Clear VLAN tag from interface. */
status = nx_link_vlan_clear(&amp;ip_0, interface_index);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_164">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_link_vlan_set</p>
</li>
<li>
<p>nx_link_vlan_get</p>
</li>
<li>
<p>nx_link_multicast_join</p>
</li>
<li>
<p>nx_link_multicast_leave</p>
</li>
<li>
<p>nx_link_ethernet_packet_send</p>
</li>
<li>
<p>nx_link_raw_packet_send</p>
</li>
<li>
<p>nx_link_packet_receive_callback_add</p>
</li>
<li>
<p>nx_link_packet_receive_callback_remove</p>
</li>
<li>
<p>nx_link_ethernet_header_parse</p>
</li>
<li>
<p>nx_link_vlan_interface_create</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_link_multicast_join">nx_link_multicast_join</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Join a multicast group.</p>
</div>
<div class="sect2">
<h3 id="_prototype_165">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_link_multicast_join(NX_IP *ip_ptr, UINT interface_index,
                            ULONG physical_address_msw, ULONG physical_address_lsw)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_165">Description</h3>
<div class="paragraph">
<p>This function handles the request to join the specified multicast group on a specified network device.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_165">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface to join the multicast group.</p>
</li>
<li>
<p><em>physical_address_msw</em>: Top 16 bits (47-32) of the multicast address to join.</p>
</li>
<li>
<p><em>physical_address_lsw</em>: Lower 32 bits (31-0) of the multicast address to join.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_164">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful multicast group join.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index points to an invalid network interface.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_165">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_164">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT interface_index = 0;
ULONG physical_address_msw = 0x011b;
ULONG physical_address_lsw = 0x19000000;

/* Join a multicast group. */
status = nx_link_multicast_join(&amp;ip_0, interface_index,
                                physical_address_msw, physical_address_lsw);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_165">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_link_vlan_set</p>
</li>
<li>
<p>nx_link_vlan_get</p>
</li>
<li>
<p>nx_link_vlan_clear</p>
</li>
<li>
<p>nx_link_multicast_leave</p>
</li>
<li>
<p>nx_link_ethernet_packet_send</p>
</li>
<li>
<p>nx_link_raw_packet_send</p>
</li>
<li>
<p>nx_link_packet_receive_callback_add</p>
</li>
<li>
<p>nx_link_packet_receive_callback_remove</p>
</li>
<li>
<p>nx_link_ethernet_header_parse</p>
</li>
<li>
<p>nx_link_vlan_interface_create</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_link_multicast_leave">nx_link_multicast_leave</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Leave a multicast group.</p>
</div>
<div class="sect2">
<h3 id="_prototype_166">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_link_multicast_leave(NX_IP *ip_ptr, UINT interface_index,
                             ULONG physical_address_msw, ULONG physical_address_lsw)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_166">Description</h3>
<div class="paragraph">
<p>This function handles the request to leave the specified multicast group on a specified network device.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_166">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface to leave the multicast group.</p>
</li>
<li>
<p><em>physical_address_msw</em>: Top 16 bits (47-32) of the multicast address to leave.</p>
</li>
<li>
<p><em>physical_address_lsw</em>: Lower 32 bits (31-0) of the multicast address to leave.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_165">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful multicast group leave.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index points to an invalid network interface.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_166">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_165">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT interface_index = 0;
ULONG physical_address_msw = 0x011b;
ULONG physical_address_lsw = 0x19000000;

/* Leave a multicast group. */
status = nx_link_multicast_leave(&amp;ip_0, interface_index,
                                 physical_address_msw, physical_address_lsw);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_166">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_link_vlan_set</p>
</li>
<li>
<p>nx_link_vlan_get</p>
</li>
<li>
<p>nx_link_vlan_clear</p>
</li>
<li>
<p>nx_link_multicast_join</p>
</li>
<li>
<p>nx_link_ethernet_packet_send</p>
</li>
<li>
<p>nx_link_raw_packet_send</p>
</li>
<li>
<p>nx_link_packet_receive_callback_add</p>
</li>
<li>
<p>nx_link_packet_receive_callback_remove</p>
</li>
<li>
<p>nx_link_ethernet_header_parse</p>
</li>
<li>
<p>nx_link_vlan_interface_create</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_link_ethernet_packet_send">nx_link_ethernet_packet_send</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send an Ethernet packet.</p>
</div>
<div class="sect2">
<h3 id="_prototype_167">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_link_ethernet_packet_send(NX_IP *ip_ptr, UINT interface_index, NX_PACKET *packet_ptr,
                                  ULONG physical_address_msw, ULONG physical_address_lsw, UINT packet_type)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_167">Description</h3>
<div class="paragraph">
<p>This function sends out a link packet with layer 3 header already constructed or raw packet. Ethernet header will be added in this function.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_167">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface to send the packet.</p>
</li>
<li>
<p><em>packet_ptr</em>: Pointer to the packet to send.</p>
</li>
<li>
<p><em>physical_address_msw</em>: Top 16 bits (47-32) of the destination MAC address.</p>
</li>
<li>
<p><em>physical_address_lsw</em>: Lower 32 bits (31-0) of the destination MAC address.</p>
</li>
<li>
<p><em>packet_type</em>: Type of the packet to send.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_166">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet send.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index points to an invalid network interface.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_167">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_166">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT interface_index = 0;
ULONG physical_address_msw = 0x011b;
ULONG physical_address_lsw = 0x19000000;
UINT packet_type = NX_PTP_ETHERNET_TYPE;

/* Send an Ethernet packet. */
status = nx_link_ethernet_packet_send(&amp;ip_0, interface_index, packet_ptr,
                                      physical_address_msw, physical_address_lsw, packet_type);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_167">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_link_vlan_set</p>
</li>
<li>
<p>nx_link_vlan_get</p>
</li>
<li>
<p>nx_link_vlan_clear</p>
</li>
<li>
<p>nx_link_multicast_join</p>
</li>
<li>
<p>nx_link_multicast_leave</p>
</li>
<li>
<p>nx_link_raw_packet_send</p>
</li>
<li>
<p>nx_link_packet_receive_callback_add</p>
</li>
<li>
<p>nx_link_packet_receive_callback_remove</p>
</li>
<li>
<p>nx_link_ethernet_header_parse</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_link_raw_packet_send">nx_link_raw_packet_send</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Send a raw packet.</p>
</div>
<div class="sect2">
<h3 id="_prototype_168">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_link_raw_packet_send(NX_IP *ip_ptr, UINT interface_index, NX_PACKET *packet_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_168">Description</h3>
<div class="paragraph">
<p>This function sends out a link packet with layer 2 header already constructed or raw packet.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_168">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface to send the packet.</p>
</li>
<li>
<p><em>packet_ptr</em>: Pointer to the packet to send.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_167">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet send.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index points to an invalid network interface.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_168">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_167">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT interface_index = 0;

/* Send a raw packet. */
status = nx_link_raw_packet_send(&amp;ip_0, interface_index, packet_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_168">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_link_vlan_set</p>
</li>
<li>
<p>nx_link_vlan_get</p>
</li>
<li>
<p>nx_link_vlan_clear</p>
</li>
<li>
<p>nx_link_multicast_join</p>
</li>
<li>
<p>nx_link_multicast_leave</p>
</li>
<li>
<p>nx_link_ethernet_packet_send</p>
</li>
<li>
<p>nx_link_packet_receive_callback_add</p>
</li>
<li>
<p>nx_link_packet_receive_callback_remove</p>
</li>
<li>
<p>nx_link_ethernet_header_parse</p>
</li>
<li>
<p>nx_link_vlan_interface_create</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_link_packet_receive_callback_add">nx_link_packet_receive_callback_add</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Add a packet receive callback.</p>
</div>
<div class="sect2">
<h3 id="_prototype_169">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_link_packet_receive_callback_add(NX_IP *ip_ptr, UINT interface_index, NX_LINK_RECEIVE_QUEUE *queue_ptr,
                                         UINT packet_type, nx_link_packet_receive_callback *callback_ptr, VOID *context)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_169">Description</h3>
<div class="paragraph">
<p>This function adds a receive callback function to specified interface. Multiple callbacks callback functions can be added to each interface. They will be invoked one by one until the packet is consumed. Only packet matching registered packet_type will be passed to callback function. NX_LINK_PACKET_TYPE_ALL can be used to handle all types except TCP/IP ones.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_169">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface to add the callback.</p>
</li>
<li>
<p><em>queue_ptr</em>: Pointer to the receive queue.</p>
</li>
<li>
<p><em>packet_type</em>: Type of the packet to receive.</p>
</li>
<li>
<p><em>callback_ptr</em>: Pointer to the callback function.</p>
</li>
<li>
<p><em>context</em>: Pointer to the context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_168">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet send.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index points to an invalid network interface.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_169">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_168">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT interface_index = 0;
NX_LINK_RECEIVE_QUEUE queue;
UINT packet_type = NX_PTP_ETHERNET_TYPE;
nx_link_packet_receive_callback callback;

/* Add a packet receive callback. */
status = nx_link_packet_receive_callback_add(&amp;ip_0, interface_index, &amp;queue,
                                             packet_type, callback, NX_NULL);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_169">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_link_vlan_set</p>
</li>
<li>
<p>nx_link_vlan_get</p>
</li>
<li>
<p>nx_link_vlan_clear</p>
</li>
<li>
<p>nx_link_multicast_join</p>
</li>
<li>
<p>nx_link_multicast_leave</p>
</li>
<li>
<p>nx_link_ethernet_packet_send</p>
</li>
<li>
<p>nx_link_raw_packet_send</p>
</li>
<li>
<p>nx_link_packet_receive_callback_remove</p>
</li>
<li>
<p>nx_link_ethernet_header_parse</p>
</li>
<li>
<p>nx_link_vlan_interface_create</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_link_packet_receive_callback_remove">nx_link_packet_receive_callback_remove</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Remove a packet receive callback.</p>
</div>
<div class="sect2">
<h3 id="_prototype_170">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_link_packet_receive_callback_remove(NX_IP *ip_ptr, UINT interface_index, NX_LINK_RECEIVE_QUEUE *queue_ptr)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_170">Description</h3>
<div class="paragraph">
<p>This function removes a receive callback function to specified interface.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_170">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_index</em>: Index of the network interface to remove the callback.</p>
</li>
<li>
<p><em>queue_ptr</em>: Pointer to the receive queue.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_169">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet send.</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer.</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Device index points to an invalid network interface.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_170">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_169">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT interface_index = 0;
NX_LINK_RECEIVE_QUEUE queue;

/* Remove a packet receive callback. */
status = nx_link_packet_receive_callback_remove(&amp;ip_0, interface_index, &amp;queue);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_170">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_link_vlan_set</p>
</li>
<li>
<p>nx_link_vlan_get</p>
</li>
<li>
<p>nx_link_vlan_clear</p>
</li>
<li>
<p>nx_link_multicast_join</p>
</li>
<li>
<p>nx_link_multicast_leave</p>
</li>
<li>
<p>nx_link_ethernet_packet_send</p>
</li>
<li>
<p>nx_link_raw_packet_send</p>
</li>
<li>
<p>nx_link_packet_receive_callback_add</p>
</li>
<li>
<p>nx_link_ethernet_header_parse</p>
</li>
<li>
<p>nx_link_vlan_interface_create</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_link_ethernet_header_parse">nx_link_ethernet_header_parse</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parse an Ethernet header.</p>
</div>
<div class="sect2">
<h3 id="_prototype_171">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_link_ethernet_header_parse(NX_PACKET *packet_ptr, ULONG *destination_msb, ULONG *destination_lsb,
                                   ULONG *source_msb, ULONG *source_lsb, USHORT *ether_type, USHORT *vlan_tag,
                                   UCHAR *vlan_tag_valid, UINT *header_size)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_171">Description</h3>
<div class="paragraph">
<p>This function parses Ethernet packet and return each file of header.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_171">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>packet_ptr</em>: Pointer to the packet to parse.</p>
</li>
<li>
<p><em>destination_msb</em>: Pointer to store the destination MAC address MSB.</p>
</li>
<li>
<p><em>destination_lsb</em>: Pointer to store the destination MAC address LSB.</p>
</li>
<li>
<p><em>source_msb</em>: Pointer to store the source MAC address MSB.</p>
</li>
<li>
<p><em>source_lsb</em>: Pointer to store the source MAC address LSB.</p>
</li>
<li>
<p><em>ether_type</em>: Pointer to store the Ethernet type.</p>
</li>
<li>
<p><em>vlan_tag</em>: Pointer to store the VLAN tag.</p>
</li>
<li>
<p><em>vlan_tag_valid</em>: Pointer to store the VLAN tag valid.</p>
</li>
<li>
<p><em>header_size</em>: Pointer to store the header size.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_170">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet send.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_171">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_170">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">ULONG destination_msb, destination_lsb, source_msb, source_lsb;
USHORT ether_type, vlan_tag;
UCHAR vlan_tag_valid;
UINT header_size;

/* Parse an Ethernet header. */
nx_link_ethernet_header_parse(packet_ptr, &amp;destination_msb, &amp;destination_lsb,
                              &amp;source_msb, &amp;source_lsb, &amp;ether_type, &amp;vlan_tag,
                              &amp;vlan_tag_valid, &amp;header_size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_171">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_link_vlan_set</p>
</li>
<li>
<p>nx_link_vlan_get</p>
</li>
<li>
<p>nx_link_vlan_clear</p>
</li>
<li>
<p>nx_link_multicast_join</p>
</li>
<li>
<p>nx_link_multicast_leave</p>
</li>
<li>
<p>nx_link_ethernet_packet_send</p>
</li>
<li>
<p>nx_link_raw_packet_send</p>
</li>
<li>
<p>nx_link_packet_receive_callback_add</p>
</li>
<li>
<p>nx_link_packet_receive_callback_remove</p>
</li>
<li>
<p>nx_link_vlan_interface_create</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_link_vlan_interface_create">nx_link_vlan_interface_create</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create a VLAN interface.</p>
</div>
<div class="sect2">
<h3 id="_prototype_172">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_link_vlan_interface_create(NX_IP *ip_ptr, CHAR *interface_name, ULONG ip_address, ULONG network_mask,
                                   UINT vlan_tag, UINT parent_interface_index, UINT *interface_index_ptr)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_172">Description</h3>
<div class="paragraph">
<p>This function creates a VLAN interface and bind to parent interface. Any packet received from parent interface will be dispatched to right interface according to the match of VLAN ID.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_172">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>ip_ptr</em>: Pointer to previously created IP instance.</p>
</li>
<li>
<p><em>interface_name</em>: Name of the interface.</p>
</li>
<li>
<p><em>ip_address</em>: IP address of the interface.</p>
</li>
<li>
<p><em>network_mask</em>: Network mask of the interface.</p>
</li>
<li>
<p><em>vlan_tag</em>: VLAN tag of the interface.</p>
</li>
<li>
<p><em>parent_interface_index</em>: Index of the parent interface.</p>
</li>
<li>
<p><em>interface_index_ptr</em>: Pointer to store the index of the interface.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_171">Return Values</h3>
<div class="paragraph">
<p><strong>NX_SUCCESS</strong> (0x00) Successful packet send.
<strong>NX_DUPLICATED_ENTRY</strong> (0x4D) Interface is duplicated.
<strong>NX_NO_MORE_ENTRIES</strong> (0x4F) No more entries.
<strong>NX_INVALID_PARAMETERS</strong> (0x47) Invalid parameters.</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_172">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_171">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">status = nx_link_vlan_interface_create(&amp;ip_0, "NetX IP Interface 0:2", IP_ADDRESS(0, 0, 0, 0), 0xFFFFFFFFUL, VLAN_ID, 0, &amp;interface_0);
if (status)
{
   error_counter++;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_172">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_link_vlan_set</p>
</li>
<li>
<p>nx_link_vlan_get</p>
</li>
<li>
<p>nx_link_vlan_clear</p>
</li>
<li>
<p>nx_link_multicast_join</p>
</li>
<li>
<p>nx_link_multicast_leave</p>
</li>
<li>
<p>nx_link_ethernet_packet_send</p>
</li>
<li>
<p>nx_link_raw_packet_send</p>
</li>
<li>
<p>nx_link_packet_receive_callback_add</p>
</li>
<li>
<p>nx_link_packet_receive_callback_remove</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_shaper_create">nx_shaper_create</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create a shaper.</p>
</div>
<div class="sect2">
<h3 id="_prototype_173">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_shaper_create(NX_INTERFACE *interface_ptr, NX_SHAPER_CONTAINER *shaper_container, NX_SHAPER *shaper, UCHAR shaper_type, NX_SHAPER_DRIVER shaper_driver);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_173">Description</h3>
<div class="paragraph">
<p>This function creates shaper in shaper container, and connects the shaper container with interface instance.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_173">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>interface_ptr</em>: Pointer to the interface instance.</p>
</li>
<li>
<p><em>shaper_container</em>: Pointer to the shaper container.</p>
</li>
<li>
<p><em>shaper</em>: Pointer to the shaper.</p>
</li>
<li>
<p>shaper_type: Type of the shaper.</p>
</li>
<li>
<p>shaper_driver: Pointer to the shaper driver.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_172">Return Values</h3>
<div class="paragraph">
<p><strong>NX_SUCCESS</strong> (0x00) Successful shaper create.
<strong>NX_INVALID_PARAMETERS</strong> (0x47) Invalid parameters.
<strong>NX_NO_MORE_ENTRIES</strong> (0x4F) No more entries.</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_173">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_172">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT shaper_init(NX_INTERFACE *interface_ptr)
{
UINT status;
UCHAR pcp_list[8];
UCHAR queue_id_list[8];

    status = nx_shaper_create(interface_ptr, &amp;shaper_container, &amp;cbs_shaper, NX_SHAPER_TYPE_CBS, nx_driver_shaper_cbs_entry);
    if (status != NX_SUCCESS)
    {
        return NX_FALSE;
    }

    status = nx_shaper_default_mapping_get(interface_ptr, pcp_list, queue_id_list, 8);
    if (status != NX_SUCCESS)
    {
        return NX_FALSE;
    }

    status = nx_shaper_mapping_set(interface_ptr, pcp_list, queue_id_list, 8);

    return status;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_173">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_shaper_delete</p>
</li>
<li>
<p>nx_shaper_current_mapping_get</p>
</li>
<li>
<p>nx_shaper_default_mapping_get</p>
</li>
<li>
<p>nx_shaper_mapping_set</p>
</li>
<li>
<p>nx_shaper_cbs_parameter_set</p>
</li>
<li>
<p>nx_shaper_fp_parameter_set</p>
</li>
<li>
<p>nx_shaper_tas_parameter_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_shaper_delete">nx_shaper_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Delete a shaper.</p>
</div>
<div class="sect2">
<h3 id="_prototype_174">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_shaper_delete(NX_INTERFACE *interface_ptr, NX_SHAPER *shaper)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_174">Description</h3>
<div class="paragraph">
<p>This function deletes a shaper from interface instance, unlink the shaper container with IP interface when there is no shaper exists.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_174">Parameters</h3>
<div class="paragraph">
<p><em>interface_ptr</em>: Pointer to the interface instance.
<em>shaper</em>: Pointer to the shaper.</p>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_173">Return Values</h3>
<div class="paragraph">
<p><strong>NX_SUCCESS</strong> (0x00) Successful shaper delete.
<strong>NX_INVALID_PARAMETERS</strong> (0x47) Invalid parameters.
<strong>NX_ENTRY_NOT_FOUND</strong> (0x4A) Entry not found.</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_174">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_173">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">status = nx_shaper_delete(&amp;ip_0, &amp;cbs_shaper);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_174">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_shaper_create</p>
</li>
<li>
<p>nx_shaper_current_mapping_get</p>
</li>
<li>
<p>nx_shaper_default_mapping_get</p>
</li>
<li>
<p>nx_shaper_mapping_set</p>
</li>
<li>
<p>nx_shaper_cbs_parameter_set</p>
</li>
<li>
<p>nx_shaper_fp_parameter_set</p>
</li>
<li>
<p>nx_shaper_tas_parameter_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_shaper_current_mapping_get">nx_shaper_current_mapping_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Get current mapping of shaper.</p>
</div>
<div class="sect2">
<h3 id="_prototype_175">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_shaper_current_mapping_get(NX_INTERFACE *interface_ptr, UCHAR *pcp_list, UCHAR *queue_id_list, UCHAR list_size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_175">Description</h3>
<div class="paragraph">
<p>This function gets the current pcp to HW queue mapping config.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_175">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>interface_ptr</em>: Pointer to the interface instance.</p>
</li>
<li>
<p><em>pcp_list</em>: Pointer to the pcp list.</p>
</li>
<li>
<p><em>queue_id_list</em>: Pointer to the queue id list.</p>
</li>
<li>
<p><em>list_size</em>: Size of the list.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_174">Return Values</h3>
<div class="paragraph">
<p><strong>NX_SUCCESS</strong> (0x00) Successfully get mapping.
<strong>NX_INVALID_PARAMETERS</strong> (0x47) Invalid parameters.
<strong>NX_NOT_SUPPORTED</strong> (0x4B) Not supported.
<strong>NX_NOT_SUCCESSFUL</strong> (0x51) Not successful.</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_175">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_174">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">status = nx_shaper_current_mapping_get(&amp;ip_0, pcp_list, queue_id_list, 8);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_175">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_shaper_create</p>
</li>
<li>
<p>nx_shaper_delete</p>
</li>
<li>
<p>nx_shaper_default_mapping_get</p>
</li>
<li>
<p>nx_shaper_mapping_set</p>
</li>
<li>
<p>nx_shaper_cbs_parameter_set</p>
</li>
<li>
<p>nx_shaper_fp_parameter_set</p>
</li>
<li>
<p>nx_shaper_tas_parameter_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_shaper_default_mapping_get">nx_shaper_default_mapping_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Get default mapping of shaper.</p>
</div>
<div class="sect2">
<h3 id="_prototype_176">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_shaper_default_mapping_get(NX_INTERFACE *interface_ptr, UCHAR *pcp_list, UCHAR *queue_id_list, UCHAR list_size)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_176">Description</h3>
<div class="paragraph">
<p>This function gets the default pcp to HW queue mapping config.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_176">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>interface_ptr</em>: Pointer to the interface instance.</p>
</li>
<li>
<p><em>pcp_list</em>: Pointer to the pcp list.</p>
</li>
<li>
<p><em>queue_id_list</em>: Pointer to the queue id list.</p>
</li>
<li>
<p><em>list_size</em>: Size of the list.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_175">Return Values</h3>
<div class="paragraph">
<p><strong>NX_SUCCESS</strong> Successfully get mapping.
<strong>NX_INVALID_PARAMETERS</strong> (0x47) Invalid parameters.
<strong>NX_NOT_SUPPORTED</strong> (0x4B) Not supported.</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_176">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_175">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT shaper_init(NX_INTERFACE *interface_ptr)
{
UINT status;
UCHAR pcp_list[8];
UCHAR queue_id_list[8];

    status = nx_shaper_create(interface_ptr, &amp;shaper_container, &amp;cbs_shaper, NX_SHAPER_TYPE_CBS, nx_driver_shaper_cbs_entry);
    if (status != NX_SUCCESS)
    {
        return NX_FALSE;
    }

    status = nx_shaper_default_mapping_get(interface_ptr, pcp_list, queue_id_list, 8);
    if (status != NX_SUCCESS)
    {
        return NX_FALSE;
    }

    status = nx_shaper_mapping_set(interface_ptr, pcp_list, queue_id_list, 8);

    return status;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_176">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_shaper_create</p>
</li>
<li>
<p>nx_shaper_delete</p>
</li>
<li>
<p>nx_shaper_current_mapping_get</p>
</li>
<li>
<p>nx_shaper_mapping_set</p>
</li>
<li>
<p>nx_shaper_cbs_parameter_set</p>
</li>
<li>
<p>nx_shaper_fp_parameter_set</p>
</li>
<li>
<p>nx_shaper_tas_parameter_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_shaper_mapping_set">nx_shaper_mapping_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set mapping of shaper.</p>
</div>
<div class="sect2">
<h3 id="_prototype_177">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_shaper_mapping_set(NX_INTERFACE *interface_ptr, UCHAR *pcp_list, UCHAR *queue_id_list, UCHAR list_size)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_177">Description</h3>
<div class="paragraph">
<p>This function sets the pcp to HW queue mapping config.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_177">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>interface_ptr</em>: Pointer to the interface instance.</p>
</li>
<li>
<p><em>pcp_list</em>: Pointer to the pcp list.</p>
</li>
<li>
<p><em>queue_id_list</em>: Pointer to the queue id list.</p>
</li>
<li>
<p><em>list_size</em>: Size of the list.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_176">Return Values</h3>
<div class="paragraph">
<p><strong>NX_SUCCESS</strong> Successfully set mapping.
<strong>NX_INVALID_PARAMETERS</strong> (0x47) Invalid parameters.
<strong>NX_NOT_SUPPORTED</strong> (0x4B) Not supported.</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_177">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_176">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT shaper_init(NX_INTERFACE *interface_ptr)
{
UINT status;
UCHAR pcp_list[8];
UCHAR queue_id_list[8];

    status = nx_shaper_create(interface_ptr, &amp;shaper_container, &amp;cbs_shaper, NX_SHAPER_TYPE_CBS, nx_driver_shaper_cbs_entry);
    if (status != NX_SUCCESS)
    {
        return NX_FALSE;
    }

    status = nx_shaper_default_mapping_get(interface_ptr, pcp_list, queue_id_list, 8);
    if (status != NX_SUCCESS)
    {
        return NX_FALSE;
    }

    status = nx_shaper_mapping_set(interface_ptr, pcp_list, queue_id_list, 8);

    return status;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_177">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_shaper_create</p>
</li>
<li>
<p>nx_shaper_delete</p>
</li>
<li>
<p>nx_shaper_current_mapping_get</p>
</li>
<li>
<p>nx_shaper_default_mapping_get</p>
</li>
<li>
<p>nx_shaper_cbs_parameter_set</p>
</li>
<li>
<p>nx_shaper_fp_parameter_set</p>
</li>
<li>
<p>nx_shaper_tas_parameter_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_shaper_cbs_parameter_set">nx_shaper_cbs_parameter_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set CBS parameter of shaper.</p>
</div>
<div class="sect2">
<h3 id="_prototype_178">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_shaper_cbs_parameter_set(NX_INTERFACE *interface_ptr, NX_SHAPER_CBS_PARAMETER *cbs_parameter, UCHAR pcp)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_178">Description</h3>
<div class="paragraph">
<p>This function configures the hardware parameters for CBS shaper.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_178">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>interface_ptr</em>: Pointer to the interface instance.</p>
</li>
<li>
<p><em>cbs_parameter</em>: Pointer to the CBS parameter.</p>
</li>
<li>
<p><em>pcp</em>: PCP value.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_177">Return Values</h3>
<div class="paragraph">
<p><strong>NX_SUCCESS</strong> Successfully set CBS parameter.
<strong>NX_NOT_SUPPORTED</strong> (0x4B) Not supported.
<strong>NX_NOT_FOUND</strong> (0x4E) Not found.
<strong>NX_NOT_SUPPORTED</strong> (0x4B) Not supported.</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_178">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_177">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">    status = nx_srp_cbs_config_get(srp_ptr -&gt; talker[index].class_id,
                                   (INT)port_rate,
                                   srp_ptr -&gt; talker[index].interval,
                                   srp_ptr -&gt; talker[index].max_interval_frames,
                                   srp_ptr -&gt; talker[index].max_frame_size,
                                   interface_ptr -&gt; nx_interface_ip_mtu_size,
                                   idle_slope_a,
                                   max_frame_size_a,
                                   &amp;(srp_ptr -&gt; talker[index].cbs_parameters));
    if(status)
        return status;

    printf("cbs parameters: idle slope: %d, send slope: %d, hi credit: %d, low credit: %d\r\n",
                srp_ptr -&gt; talker[index].cbs_parameters.idle_slope,
                srp_ptr -&gt; talker[index].cbs_parameters.send_slope,
                srp_ptr -&gt; talker[index].cbs_parameters.hi_credit,
                srp_ptr -&gt; talker[index].cbs_parameters.low_credit);
    if(srp_ptr -&gt; talker[index].class_id == NX_SRP_SR_CLASS_A)
        status = nx_shaper_cbs_parameter_set(interface_ptr, &amp;(srp_ptr -&gt; talker[index].cbs_parameters), NX_SHAPER_CLASS_A_PCP);
    else
        status = nx_shaper_cbs_parameter_set(interface_ptr, &amp;(srp_ptr -&gt; talker[index].cbs_parameters), NX_SHAPER_CLASS_B_PCP);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_178">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_shaper_create</p>
</li>
<li>
<p>nx_shaper_delete</p>
</li>
<li>
<p>nx_shaper_current_mapping_get</p>
</li>
<li>
<p>nx_shaper_default_mapping_get</p>
</li>
<li>
<p>nx_shaper_mapping_set</p>
</li>
<li>
<p>nx_shaper_fp_parameter_set</p>
</li>
<li>
<p>nx_shaper_tas_parameter_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_shaper_fp_parameter_set">nx_shaper_fp_parameter_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set FP parameter of shaper.</p>
</div>
<div class="sect2">
<h3 id="_prototype_179">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_shaper_fp_parameter_set(NX_INTERFACE *interface_ptr, NX_SHAPER_FP_PARAMETER *fp_parameter);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_179">Description</h3>
<div class="paragraph">
<p>This function sets the frame preemption parameter, when used with other shapers, FP parameter should be set before other shapers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_179">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>interface_ptr</em>: Pointer to the interface instance.</p>
</li>
<li>
<p><em>fp_parameter</em>: Pointer to the FP parameter.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_178">Return Values</h3>
<div class="paragraph">
<p><strong>NX_SUCCESS</strong> Successfully set FP parameter.
<strong>NX_NOT_SUCCESSFUL</strong> (0x51) Not successful.</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_179">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_178">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#ifdef FP_ENABLED
    //fp_config
    memset(&amp;fp_config, 0, sizeof(NX_SHAPER_FP_PARAMETER));
    fp_config.verification_enable = 1;
    fp_config.express_guardband_enable = NX_TRUE;
    fp_config.ha = 0;
    fp_config.ra = 0;
    fp_config.express_queue_bitmap = (1 &lt;&lt; 3) | (1 &lt;&lt; 2);

    status = nx_shaper_fp_parameter_set(interface_ptr, &amp;fp_config);

    if (status != NX_SUCCESS)
    {
        return NX_FALSE;
    }
#endif</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_179">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_shaper_create</p>
</li>
<li>
<p>nx_shaper_delete</p>
</li>
<li>
<p>nx_shaper_current_mapping_get</p>
</li>
<li>
<p>nx_shaper_default_mapping_get</p>
</li>
<li>
<p>nx_shaper_mapping_set</p>
</li>
<li>
<p>nx_shaper_cbs_parameter_set</p>
</li>
<li>
<p>nx_shaper_tas_parameter_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_shaper_tas_parameter_set">nx_shaper_tas_parameter_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Set TAS parameter of shaper.</p>
</div>
<div class="sect2">
<h3 id="_prototype_180">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_shaper_tas_parameter_set(NX_INTERFACE *interface_ptr, NX_SHAPER_TAS_CONFIG *tas_config);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_180">Description</h3>
<div class="paragraph">
<p>This function configures the hardware parameters for TAS shaper.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_180">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>interface_ptr</em>: Pointer to the interface instance.</p>
</li>
<li>
<p><em>tas_config</em>: Pointer to the TAS config.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_179">Return Values</h3>
<div class="paragraph">
<p><strong>NX_SUCCESS</strong> Successfully set TAS parameter.
<strong>NX_NOT_FOUND</strong> (0x4E) Not found.</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_180">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_179">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">    tas_config.base_time = (ULONG64)100 &lt;&lt; 32; //100seconds
    tas_config.auto_fill_status = NX_SHAPER_TAS_IDLE_CYCLE_AUTO_FILL_DISABLED;
    tas_config.cycle_time = 1000000;
    tas_config.traffic_count = 2;

    tas_config.traffic[0].pcp = 2;
    tas_config.traffic[0].time_offset = 0;
    tas_config.traffic[0].duration = 500000;
    tas_config.traffic[0].traffic_control = NX_SHAPER_TRAFFIC_OPEN;

    tas_config.traffic[1].pcp = 0;
    tas_config.traffic[1].time_offset = 500000;
    tas_config.traffic[1].duration = 500000;
    tas_config.traffic[1].traffic_control = NX_SHAPER_TRAFFIC_OPEN;


    status = nx_shaper_tas_parameter_set(interface_ptr, &amp;tas_config);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_180">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_shaper_create</p>
</li>
<li>
<p>nx_shaper_delete</p>
</li>
<li>
<p>nx_shaper_current_mapping_get</p>
</li>
<li>
<p>nx_shaper_default_mapping_get</p>
</li>
<li>
<p>nx_shaper_mapping_set</p>
</li>
<li>
<p>nx_shaper_cbs_parameter_set</p>
</li>
<li>
<p>nx_shaper_fp_parameter_set</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_srp_init">nx_srp_init</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Initialization of SRP.</p>
</div>
<div class="sect2">
<h3 id="_prototype_181">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_srp_init(NX_SRP *srp_ptr, NX_IP *ip_ptr, UINT interface_index, NX_PACKET_POOL *pkt_pool_ptr,
                 VOID *stack_ptr, ULONG stack_size, UINT priority);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_181">Description</h3>
<div class="paragraph">
<p>This function initialize SRP, it initializes MRP, MSRP, MVRP sequencly, and create a thread in MRP initializaton.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_181">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>srp_ptr</em>:                             Pointer to SRP instance.</p>
</li>
<li>
<p><em>ip_ptr</em>:                              Pointer to IP instance.</p>
</li>
<li>
<p><em>interface_index</em>:                     Index of the network interface to use SRP.</p>
</li>
<li>
<p><em>pkt_pool_ptr</em>:                        pointer to Packet pool.</p>
</li>
<li>
<p><em>stack_ptr</em>:                           pointer to SRP thread Stack.</p>
</li>
<li>
<p><em>stack_size</em>:                          SRP thread Stack size .</p>
</li>
<li>
<p><em>priority</em>:                            SRP thread priority.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_180">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful init</p>
</li>
<li>
<p><strong>NX_INVALID_INTERFACE</strong> (0x4C) Invalid interface index</p>
</li>
<li>
<p><strong>NX_PTR_ERROR</strong> (0x07) Invalid IP pointer</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_162">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_181">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_180">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define SRP_THREAD_PRIORITY 5
#define SRP_INTERFACE 0
NX_SRP nx_srp;
NX_IP ip_0;
NX_PACKET_POOL pool_0;
ULONG            srp_stack[2048 *2 / sizeof(ULONG)];

/* Create the SRP client instance */
nx_srp_init(&amp;nx_srp, &amp;ip_0, SRP_INTERFACE, &amp;pool_0,
                     (UCHAR *)srp_stack, sizeof(srp_stack), SRP_THREAD_PRIORITY);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_181">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_srp_talker_start</p>
</li>
<li>
<p>nx_srp_talker_stop</p>
</li>
<li>
<p>nx_srp_listener_start</p>
</li>
<li>
<p>nx_srp_listener_stop</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_srp_talker_start">nx_srp_talker_start</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Start SRP talker.</p>
</div>
<div class="sect2">
<h3 id="_prototype_182">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_srp_talker_start(NX_SRP *srp_ptr, NX_MSRP_DOMAIN *srp_domain, UCHAR *stream_id, UCHAR *dest_addr,
                         UINT max_frame_size, UINT max_interval_frames, NX_MRP_EVENT_CALLBACK event_callback);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_182">Description</h3>
<div class="paragraph">
<p>This function start SRP talker, it sets event callback functions and register domain, Vlan, stream request.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_182">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>srp_ptr</em>:                       Pointer to SRP instance.</p>
</li>
<li>
<p><em>event_callback</em>:                callback invoked by application to monitor the SRP process.</p>
</li>
<li>
<p><em>stream_id</em>:                     stream id of talker advertised.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_181">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful start</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) Invalid parameter</p>
</li>
<li>
<p><strong>NX_MSRP_EVENT_NOT_SUPPORTED</strong> (0x06) unsupported event</p>
</li>
<li>
<p><strong>NX_MSRP_ATTRIBUTE_FIND_ERROR</strong> (0x09) not found attribute</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_163">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_182">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_181">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define SRP_THREAD_PRIORITY 5
#define SRP_INTERFACE 0
NX_SRP nx_srp;
UINT MaxFrameSize = 1300;
UINT MaxIntervalFrames = 1;
UCHAR dest_addr[6] ={0X91,0XE0,0XF0,0X00,0X0E,0X80};
UCHAR stream_id[8] = {0X00,0X11,0X22,0X33,0X44,0X56,0,1};
NX_MSRP_DOMAIN srp_domain = {5,2,2};
UINT srp_event_callback(NX_MRP_PARTICIPANT* participant, NX_MRP_ATTRIBUTE* attribute, UCHAR event,VOID *callback_data);

    /* start the SRP client */
    status = nx_srp_talker_start(&amp;nx_srp, &amp;srp_domain, stream_id,  dest_addr,
                             MaxFrameSize, MaxIntervalFrames, srp_event_callback);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_182">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_srp_init</p>
</li>
<li>
<p>nx_srp_talker_stop</p>
</li>
<li>
<p>nx_srp_listener_start</p>
</li>
<li>
<p>nx_srp_listener_stop</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_srp_talker_stop">nx_srp_talker_stop</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Stop SRP talker.</p>
</div>
<div class="sect2">
<h3 id="_prototype_183">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_srp_talker_stop(NX_SRP *srp_ptr, UCHAR *stream_id, NX_MSRP_DOMAIN *domain)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_183">Description</h3>
<div class="paragraph">
<p>This function stop SRP talker. It withdraw the domain,Vlan,stream request.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_183">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>srp_ptr</em>:                    Pointer to SRP instance.</p>
</li>
<li>
<p><em>stream_id</em>:                  stream id of talker advertised.</p>
</li>
<li>
<p><em>domain</em>:                     domain of SRP talker.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_182">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful stop</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) Invalid parameter</p>
</li>
<li>
<p><strong>NX_MSRP_EVENT_NOT_SUPPORTED</strong> (0x06) unsupported event</p>
</li>
<li>
<p><strong>NX_MSRP_ATTRIBUTE_FIND_ERROR</strong> (0x09) not found attribute</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_164">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_183">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_182">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NX_SRP nx_srp;
UCHAR stream_id[8] = {0X00,0X11,0X22,0X33,0X44,0X56,0,1};
NX_MSRP_DOMAIN srp_domain = {5,2,2};

nx_srp_talker_stop(&amp;nx_srp,stream_id, &amp;srp_domain );</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_183">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_srp_init</p>
</li>
<li>
<p>nx_srp_talker_start</p>
</li>
<li>
<p>nx_srp_listener_start</p>
</li>
<li>
<p>nx_srp_listener_stop</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_srp_listener_start">nx_srp_listener_start</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Start SRP listener.</p>
</div>
<div class="sect2">
<h3 id="_prototype_184">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_srp_listener_start(NX_SRP *srp_ptr, NX_MRP_EVENT_CALLBACK event_callback, UCHAR *stream_id)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_184">Description</h3>
<div class="paragraph">
<p>This function start SRP listener. It enables listener and set user date and callback function.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_184">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>srp_ptr</em>:                       Pointer to SRP instance.</p>
</li>
<li>
<p><em>event_callback</em>:                callback invoked by application to monitor the SRP process.</p>
</li>
<li>
<p><em>stream_id</em>:                     stream id of listener attached.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_183">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_MSRP_SUCCESS</strong> (0x00) Successful listener start</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_165">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_184">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_183">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NX_SRP nx_srp;
UCHAR stream_id[8] = {0X00,0X11,0X22,0X33,0X44,0X56,0,1};
UINT srp_event_callback(NX_MRP_PARTICIPANT* participant, NX_MRP_ATTRIBUTE* attribute, UCHAR event,VOID *callback_data);

   nx_srp_listener_start(&amp;nx_srp, srp_event_callback, stream_id)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_184">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_srp_init</p>
</li>
<li>
<p>nx_srp_talker_start</p>
</li>
<li>
<p>nx_srp_talker_stop</p>
</li>
<li>
<p>nx_srp_listener_stop</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_srp_listener_stop">nx_srp_listener_stop</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Stop SRP listener.</p>
</div>
<div class="sect2">
<h3 id="_prototype_185">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT nx_srp_listener_stop(NX_SRP *srp_ptr, UCHAR *stream_id, NX_MSRP_DOMAIN *domain)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_185">Description</h3>
<div class="paragraph">
<p>This function stop SRP listener. It unregister the domain,Vlan stream attached to talker.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters_185">Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>srp_ptr</em>:                       Pointer to SRP instance.</p>
</li>
<li>
<p><em>stream_id</em>:                     Stream id of listener attached to.</p>
</li>
<li>
<p><em>domain</em>:                        Domain of listener attached to.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_184">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>NX_SUCCESS</strong> (0x00) Successful stop</p>
</li>
<li>
<p><strong>NX_INVALID_PARAMETERS</strong> (0x4D) Invalid parameter</p>
</li>
<li>
<p><strong>NX_MSRP_EVENT_NOT_SUPPORTED</strong> (0x06) unsupported event</p>
</li>
<li>
<p><strong>NX_MSRP_ATTRIBUTE_FIND_ERROR</strong> (0x09) not found attribute</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_166">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_preemption_possible_185">Preemption Possible</h3>
<div class="paragraph">
<p>No</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_184">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NX_SRP nx_srp;
UCHAR stream_id[8] = {0X00,0X11,0X22,0X33,0X44,0X56,0,1};
NX_MSRP_DOMAIN srp_domain = {5,2,2};

nx_srp_listener_stop(&amp;nx_srp,stream_id, &amp;srp_domain );</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_185">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>nx_srp_init</p>
</li>
<li>
<p>nx_srp_talker_start</p>
</li>
<li>
<p>nx_srp_talker_stop</p>
</li>
<li>
<p>nx_srp_listener_start</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-02-07 07:51:22 UTC
</div>
</div>
</body>
</html>