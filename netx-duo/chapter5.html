<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="description" content="This chapter contains a description of network drivers for NetX Duo.">
<title>Chapter 5 - NetX Duo Network Drivers</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Chapter 5 - NetX Duo Network Drivers</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This chapter contains a description of network drivers for NetX Duo. The information presented is designed to help developers write application-specific network drivers for NetX Duo.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_driver_introduction">Driver Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The NX_IP structure contains everything to manage a single IP instance. This includes general TCP/IP protocol information as well as the application-specific physical network driver&#8217;s entry routine. The driver&#8217;s entry routine is defined during the <strong><em>nx_ip_create</em></strong> service. Additional devices may be added to the IP instance via the <strong><em>nx_ip_interface_attach</em></strong> service.</p>
</div>
<div class="paragraph">
<p>Communication between NetX Duo and the application&#8217;s network driver is accomplished through the <strong>NX_IP_DRIVER</strong> request structure. This structure is most often defined locally on the caller&#8217;s stack and is therefore released after the driver and calling function return. The structure is defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">typedef struct NX_IP_DRIVER_STRUCT
{
      UINT           nx_ip_driver_command;
      UINT           nx_ip_driver_status;
      ULONG          nx_ip_driver_physical_address_msw;
      ULONG          nx_ip_driver_physical_address_lsw;
      NX_PACKET      *nx_ip_driver_packet;
      ULONG          *nx_ip_driver_return_ptr;
      NX_IP          *nx_ip_driver_ptr;
      NX_INTERFACE   *nx_ip_driver_interface;01
} NX_IP_DRIVER;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_driver_entry">Driver Entry</h2>
<div class="sectionbody">
<div class="paragraph">
<p>NetX Duo invokes the network driver entry function for driver initialization and for sending packets and for various control and status operations, including initializing and enabling the network device. NetX Duo issues commands to the network driver by setting the <strong><em>nx_ip_driver_command</em></strong> field in the <strong>NX_IP_DRIVER</strong> request structure. The driver entry function has the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">VOID my_driver_entry(NX_IP_DRIVER *request);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_driver_requests">Driver Requests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>NetX Duo creates the driver request with a specific command and invokes the driver entry function to execute the command. Because each network driver has a single entry function, NetX Duo makes all requests through the driver request data structure. The <strong><em>nx_ip_driver_command</em></strong> member of the driver request data structure (<strong>NX_IP_DRIVER</strong>) defines the request. Status information is reported back to the caller in the member <strong><em>nx_ip_driver_status</em></strong>. If this field is <strong>NX_SUCCESS</strong>, the driver request was completed successfully.</p>
</div>
<div class="paragraph">
<p>NetX Duo serializes all access to the driver. Therefore, the driver does not need to handle multiple threads asynchronously calling the entry function. Note that the device driver function executes with the IP mutex locked. Therefore the device driver internal function shall not block itself.</p>
</div>
<div class="paragraph">
<p>Typically the device driver also handles interrupts. Therefore, all driver functions need to be interrupt-safe.</p>
</div>
<div class="sect2">
<h3 id="_driver_initialization">Driver Initialization</h3>
<div class="paragraph">
<p>Although the actual driver initialization processing is application specific, it usually consists of data structure and physical hardware initialization. The information required from NetX Duo for driver initialization is the IP Maximum Transmission Unit (MTU), which is the number of bytes available to the IP-layer payload, including IPv4 or IPv6 header) and if the physical interface needs logical-to-physical mapping. The driver configures the interface MTU value by calling <strong><em>nx_ip_interface_mtu_set</em></strong>.</p>
</div>
<div class="paragraph">
<p>The device driver needs to call <strong><em>nx_ip_interface_address_mapping_configure</em></strong> to inform NetX Duo whether or not interface address mapping is required. If address mapping is needed, the driver is responsible for configuring the interface with valid MAC address, and supply the MAC address to NetX via <strong><em>nx_ip_interface_physical_address_set</em></strong>.</p>
</div>
<div class="paragraph">
<p>When the network driver receives the NX_LINK INITIALIZE request from NetX Duo, it receives a pointer to the IP control block as part of the NX_IP_DRIVER request control block shown above.</p>
</div>
<div class="paragraph">
<p>After the application calls <strong><em>nx_ip_create</em></strong>, the IP helper thread sends a driver request with the command set to NX_LINK_INITIALIZE to the driver to initialize its physical network interface. The following NX_IP_DRIVER members are used for the initialize request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_INITIALIZE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the IP instance. This value should be saved by the driver so that the driver function can find the IP instance to operate on.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the network interface structure within the IP instance. This information should be saved by the driver. On receiving packets, the driver shall use the interface structure information when sending the packet up the stack. The interface index (device index) can be obtained by reading the member nx_interface_index inside this data structure.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to initialize the specified interface to the IP instance, it will return a nonzero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>The driver is actually called from the IP helper thread that was created for the IP instance. Therefore the driver routine should avoid performing blocking operations, or the IP helper thread could stall, causing unbounded delays to applications that rely on the IP thread</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_enable_link">Enable Link</h3>
<div class="paragraph">
<p>Next, the IP helper thread enables the physical network by setting the driver command to NX_LINK_ENABLE in the driver request and sending the request to the network driver. This happens shortly after the IP helper thread completes the initialization request. Enabling the link may be as simple as setting the <em>nx_interface_link_up</em> field in the interface instance. But it may also involve manipulation of the physical hardware. The following NX_IP_DRIVER members are used for the enable link request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_ENABLE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to enable the specified interface, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_disable_link">Disable Link</h3>
<div class="paragraph">
<p>This request is made by NetX Duo during the deletion of an IP instance by the <strong><em>nx_ip_delete</em></strong> service. Or an application may issue this command in order to temporarily disable the link in order to save power. This service disables the physical network interface on the IP instance. The processing to disable the link may be as simple as clearing the <em>nx_interface_link_up</em> flag in the interface instance. But it may also involve manipulation of the physical hardware. Typically it is a reverse operation of the <strong><em>Enable Link</em></strong> operation. After the link is disabled, the application request <strong><em>Enable Link</em></strong> operation to enable the interface.</p>
</div>
<div class="paragraph">
<p>The following NX_IP_DRIVER members are used for the disable link request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_DISABLE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to disable the specified interface in the IP instance, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_uninitialize_link">Uninitialize Link</h3>
<div class="paragraph">
<p>This request is made by NetX Duo during the deletion of an IP instance by the <strong><em>nx_ip_delete</em></strong> service. This request uninitialized the interface, and release any resources created during initialization phase. Typically it is a reverse operation of the <strong><em>Initialize Link</em></strong> operation. After the interface is uninitialized, the device cannot be used until the interface is initialized again.</p>
</div>
<div class="paragraph">
<p>The following NX_IP_DRIVER members are used for the disable link request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_UNINITIALIZE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to uninitialize the specified interface to the IP instance, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_packet_send">Packet Send</h3>
<div class="paragraph">
<p>This request is made during internal IPv4 or IPv6 send processing, which all NetX Duo protocols use to transmit packets (except for ARP, RARP). On receiving the packet send command, the <em>nx_packet_prepend_ptr</em> points to the beginning of the packet to be sent, which is the beginning of the IPv4 or IPv6 header. <em>nx_packet_length</em> indicates the total size (in bytes) of the data being transmitted. If <em>nx_packet_next</em> is valid, the outgoing IP datagram is stored in multiple packets, the driver is required to follow the chained packet and transmit the entire frame. Note that valid data area in each chained packet is stored between <em>nx_packet_prepend_ptr</em> and <em>nx_packet_append_ptr</em>.</p>
</div>
<div class="paragraph">
<p>The driver is responsible for constructing physical header. If physical address to IP address mapping is required (such as Ethernet), the IP layer already resolved the MAC address. The destination MAC address is passed from the IP instance, stored in <em>nx_ip_driver_physical_address_msw and nx_ip_driver_physical_address_lsw</em>.</p>
</div>
<div class="paragraph">
<p>After adding the physical header, the packet send processing then calls the driver&#8217;s output function to transmit the packet.</p>
</div>
<div class="paragraph">
<p>The following NX_IP_DRIVER members are used for the packet send request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_PACKET_SEND</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_packet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the packet to send</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_msw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Most significant 32-bits of physical address (only if physical mapping needed)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_lsw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Least significant 32-bits of physical address (only if physical mapping needed)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to send the packet, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_packet_broadcastipv4_packets_only">Packet Broadcast(IPv4 packets only)</h3>
<div class="paragraph">
<p>This request is almost identical to the send packet request. The only difference is that the destination physical address fields are set to the Ethernet broadcast MAC address. The following NX_IP_DRIVER members are used for the packet broadcast request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_PACKET_BROADCAST</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_packet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the packet to send</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_ms w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x0000FFFF (broadcast)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_lsw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFFFFFFFF (broadcast)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to send the packet, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_arp_send">ARP Send</h3>
<div class="paragraph">
<p>This request is also similar to the IP packet send request. The only difference is that the Ethernet header specifies an ARP packet instead of an IP packet, and destination physical address fields are set to MAC broadcast address. The following NX_IP_DRIVER members are used for the ARP send request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_ARP_SEND</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_packet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the packet to send</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_ms w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x0000FFFF (broadcast)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_lsw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFFFFFFFF (broadcast)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to send the ARP packet, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If physical mapping is not needed, implementation of this request is not required</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>Although ARP has been replaced with the Neighbor Discovery Protocol and the Router Discovery Protocol in IPv6, Ethernet network drivers must still be compatible with IPv4 peers and routers. Therefore, drivers must still handle ARP packets</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arp_response_send">ARP Response Send</h3>
<div class="paragraph">
<p>This request is almost identical to the ARP send packet request. The only difference is the destination physical address fields are passed from the IP instance. The following NX_IP_DRIVER members are used for the ARP response send request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_ARP_RESPONSE_SEND</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_packet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the packet to send</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_msw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Most significant 32-bits of physical address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_lsw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Least significant 32-bits of physical address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to send the ARP packet, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If physical mapping is not needed, implementation of this request is not required</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_rarp_send">RARP Send</h3>
<div class="paragraph">
<p>This request is almost identical to the ARP send packet request. The only differences are the type of packet header and the physical address fields are not required because the physical destination is always a broadcast address.</p>
</div>
<div class="paragraph">
<p>The following NX_IP_DRIVER members are used for the RARP send request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_RARP_SEND</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_packet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the packet to send</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_ms w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x0000FFFF (broadcast)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_lsw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFFFFFFFF (broadcast)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to send the RARP packet, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>Applications that require RARP service must implement this command</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_multicast_group_join">Multicast Group Join</h3>
<div class="paragraph">
<p>This request is made with the <strong><em>nx_igmp_multicast_interface join</em></strong> and <strong><em>nx_ipv4_multicast_interface_join</em></strong> service in IPv4, <strong><em>nxd_ipv6_multicast_interface_join</em></strong> service in IPv6, and various operation required by IPv6. The network driver takes the supplied multicast group address and sets up the physical media to accept incoming packets from that multicast group address. Note that for drivers that don&#8217;t support multicast filter, the driver receive logic may have to be in promiscuous mode. In this case, the driver may need to filter incoming frames based on destination MAC address, thus reducing the amount of traffic passed into the IP instance. The following NX_IP_DRIVER members are used for the multicast group join request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_MULTICAST_JOIN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_msw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Most significant 32-bits of physical multicast address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_lsw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Least significant 32-bits of physical multicast address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to join the multicast group, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>IPv6 applications will require multicast to be implemented in the driver for ICMPv6 based protocols such as address configuration. However, for IPv4 applications, implementation of this request is not necessary if multicast capabilities are not required</em>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If IPv6 is not enabled, and multicast capabilities are not required by IPv4, implementation of this request is not required</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_multicast_group_leave">Multicast Group Leave</h3>
<div class="paragraph">
<p>This request is invoked by explicitly calling the <strong><em>nx_igmp_multicast_interface_leave</em></strong> or <strong><em>nx_ipv4_multicast_interface_leave</em></strong> services in IPv4, <strong><em>nxd_ipv6_multicast_interface_leave</em></strong> service in IPv6, or by various internal NetX Duo operations required for IPv6. The driver removes the supplied Ethernet multicast address from the multicast list. After a host has left a multicast group, packets on the network with this Ethernet multicast address are no longer received by this IP instance. The following NX_IP_DRIVER members are used for the multicast group leave request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_MULTICAST_LEAVE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_msw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Most significant 32 bits of physical multicast address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_address_lsw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Least significant 32 bits of physical multicast address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to leave the multicast group, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If multicast capabilities are not required by either IPv4 or IPv6, implementation of this request is not required</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_attach_interface">Attach Interface</h3>
<div class="paragraph">
<p>This request is invoked from the NetX Duo to the device driver, allowing the driver to associate the driver instance with the corresponding IP instance and the physical interface instance within the IP. The following NX_IP_DRIVER members are used for the attach interface request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_INTERFACE_ATTACH</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to detach the specified interface to the IP instance, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_detach_interface">Detach Interface</h3>
<div class="paragraph">
<p>This request is invoked by NetX Duo to the device driver, allowing the driver to disassociate the driver instance with the corresponding IP instance and the physical interface instance within the IP. The following NX_IP_DRIVER members are used for the attach interface request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_INTERFACE_DETACH</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to attach the specified interface to the IP instance, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_get_link_status">Get Link Status</h3>
<div class="paragraph">
<p>The application can query the network interface link status using the NetX Duo service <strong><em>nx_ip_interface_status_check</em></strong> service for any interface on the host. See Chapter 4, "Description of NetX Duo Services" on page 149, for more details on these services.</p>
</div>
<div class="paragraph">
<p>The link status is contained in the <em>nx_interface_link_up</em> field in the NX_INTERFACE structure pointed to by <em>nx_ip_driver_interface</em> pointer. The following NX_IP_DRIVER members are used for the link status request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_GET_STATUS</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_return_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the destination to place the status.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to get specific status, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<strong><em>nx_ip_status_check</em></strong> is still available for checking the status of the primary interface. However, application developers are encouraged to use the interface specific service: <strong><em>nx_ip_interface_status_check.</em></strong>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_get_link_speed">Get Link Speed</h3>
<div class="paragraph">
<p>This request is made from within the <strong><em>nx_ip_driver_direct_command</em></strong> service. The driver stores the link&#8217;s line speed in the supplied destination. The following NX_IP_DRIVER members are used for the link line speed request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_GET_SPEED</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_return_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the destination to place the line speed</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to get speed information, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This request is not used internally by NetX Duo so its implementation is optional</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_get_duplex_type">Get Duplex Type</h3>
<div class="paragraph">
<p>This request is made from within the <strong><em>nx_ip_driver_direct_command</em></strong> service. The driver stores the link&#8217;s duplex type in the supplied destination. The following NX_IP_DRIVER members are used for the duplex type request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_GET_DUPLEX_TYPE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_return_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the destination to place the duplex type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to get duplex information, it will return a nonzero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This request is not used internally by NetX Duo so its implementation is optional</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_get_error_count">Get Error Count</h3>
<div class="paragraph">
<p>This request is made from within the <strong><em>nx_ip_driver_direct_command</em></strong> service. The driver stores the link&#8217;s error count in the supplied destination. To support this feature, the driver needs to track operation errors. The following NX_IP_DRIVER members are used for the link error count request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_GET_ERROR_COUNT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_return_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the destination to place the error count</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to get error count, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This request is not used internally by NetX Duo so its implementation is optional</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_get_receive_packet_count">Get Receive Packet Count</h3>
<div class="paragraph">
<p>This request is made from within the <strong><em>nx_ip_driver_direct_command</em></strong> service. The driver stores the link&#8217;s receive packet count in the supplied destination. To support this feature, the driver needs to keep track of the number of packets received. The following NX_IP_DRIVER members are used for the link receive packet count request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_GET_RX_COUNT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_return_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the destination to place the receive packet count</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the physical network interface</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to get receive count, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This request is not used internally by NetX Duo so its implementation is optional</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_get_transmit_packet_count">Get Transmit Packet Count</h3>
<div class="paragraph">
<p>This request is made from within the <strong><em>nx_ip_driver_direct_command</em></strong> service. The driver stores the link&#8217;s transmit packet count in the supplied destination. To support this feature, the driver needs to keep track of each packet it transmits on each interface. The following  NX_IP_DRIVER members are used for the link transmit packet count request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_GET_TX_COUNT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_return_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the destination to place the transmit packet count</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to get transmit count, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This request is not used internally by NetX Duo so its implementation is optional</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_get_allocation_errors">Get Allocation Errors</h3>
<div class="paragraph">
<p>This request is made from within the <strong><em>nx_ip_driver_direct_command</em></strong> service. The driver stores the link&#8217;s packet pool allocation error count in the supplied destination. The following NX_IP_DRIVER members are used for the link allocation error count request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_GET_ALLOC_ERRORS</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_return_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the destination to place the allocation error count</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to get allocation errors, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This request is not used internally by NetX Duo so its implementation is optional</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_driver_deferred_processing">Driver Deferred Processing</h3>
<div class="paragraph">
<p>This request is made from the IP helper thread in response to the driver calling the <em><strong>_nx_ip_driver_deferred_processing</em></strong> routine from a transmit or receive ISR. This allows the driver ISR to defer the packet receive and transmit processing to the IP helper thread and thus reduce the amount to process in the ISR. The <em>nx_interface_additional_link_info</em> field in the NX_INTERFACE structure pointed to by <em>nx_ip_driver_interface</em> may be used by the driver to store information about the deferred processing event from the IP helper thread context. The following  NX_IP_DRIVER members are used for the deferred processing event.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_DEFERRED_PROCESSING</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_set_physical_address">Set Physical Address</h3>
<div class="paragraph">
<p>This request is made from within the <strong><em>nx_ip_interface_physical_address_set</em></strong> service. This service allows an application to change the interface physical address at run time. On receiving this command, the driver is required to re-configure the hardware address of the network interface to the supplied physical address. Since the IP instance already has the new address, there is no need to call the <strong><em>nx_ip_interface_address_set</em></strong> service from this command.</p>
</div>
<div class="paragraph">
<p>The following NX_IP_DRIVER members are used for the user command request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_SET_PHYSICAL_ADDRESS</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_ad dress_msw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Most significant 32-bits of the new physical address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_physical_ad dress_lsw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Least significant 32-bits of the new physical address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to reconfigure the physical address, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_user_commands">User Commands</h3>
<div class="paragraph">
<p>This request is made from within the <strong><em>nx_ip_driver_direct_command</em></strong> service. The driver processes the application specific user commands. The following NX_IP_DRIVER members are used for the user command request.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">NX_IP_DRIVER&nbsp;member</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_LINK_USER_COMMAND</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_return_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">User defined</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_interface</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the interface instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nx_ip_driver_status</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completion status. If the driver is not able to execute user commands, it will return a non-zero error status.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This request is not used internally by NetX Duo so its implementation is optional</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_unimplemented_commands">Unimplemented Commands</h3>
<div class="paragraph">
<p>Commands unimplemented by the network driver must have the return status field set to NX_UNHANDLED_COMMAND.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_driver_capability">Driver Capability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some network interfaces offer checksum offload features. Device drivers may take advantage of the hardware accelerations to free up CPU time from running various checksum computations.</p>
</div>
<div class="paragraph">
<p>Depending the level of hardware checksum support from the hardware, the device driver needs to inform the IP instance which hardware feature is enabled. This way, the IP instance is aware of the hardware feature, and offload as much computation to the hardware as possible. The driver should use the API <strong><em>nx_ip_interface_capability_set</em></strong> to set all the features the physical interface is able to handle.</p>
</div>
<div class="paragraph">
<p>The following features can be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NX_INTERFACE_CAPABILITY_IPV4_TX_CHECKSUM</p>
</li>
<li>
<p>NX_INTERFACE_CAPABILITY_IPV4_RX_CHECKSUM</p>
</li>
<li>
<p>NX_INTERFACE_CAPABILITY_TCP_TX_CHECKSUM</p>
</li>
<li>
<p>NX_INTERFACE_CAPABILITY_TCP_RX_CHECKSUM</p>
</li>
<li>
<p>NX_INTERFACE_CAPABILITY_UDP_TX_CHECKSUM</p>
</li>
<li>
<p>NX_INTERFACE_CAPABILITY_UDP_RX_CHECKSUM</p>
</li>
<li>
<p>NX_INTERFACE_CAPABILITY_ICMPV4_TX_CHECKSUM</p>
</li>
<li>
<p>NX_INTERFACE_CAPABILITY_ICMPV4_RX_CHECKSUM</p>
</li>
<li>
<p>NX_INTERFACE_CAPABILITY_ICMPV6_TX_CHECKSUM</p>
</li>
<li>
<p>NX_INTERFACE_CAPABILITY_ICMPV6_RX_CHECKSUM</p>
</li>
<li>
<p>NX_INTERFACE_CAPABILITY_IGMP_TX_CHECKSUM</p>
</li>
<li>
<p>NX_INTERFACE_CAPABILITY_IGMP_RX_CHECKSUM</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a checksum computation that can be performed in hardware, the driver must set up the hardware or the buffer descriptors correctly so the checksum for an out-going packet can be generated and inserted into the header by the hardware. On receiving a packet, the hardware checksum logic should be able to verify the checksum value. If the checksum value is incorrect, the received frame should be discarded.</p>
</div>
<div class="paragraph">
<p>Even with the capability of performing checksum computation in hardware, the IP instance still maintains the checksum capability. In certain scenarios, for example a UDP datagram going through IPsec protection, the UDP checksum must be computed in software before passing the UDP frame down the stack. Most hardware checksum feature does not support checksum computation for a segment of data protected by IPsec. For a UDP or ICMP frame that needs to be fragmented, the UDP or ICMP checksum needs to be computed in software. Most hardware checksum logic does not handle the case where the data is split into multiple frames.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_driver_output">Driver Output</h2>
<div class="sectionbody">
<div class="paragraph">
<p>All previously mentioned packet transmit requests require an output function implemented in the driver. Specific transmit logic is hardware specific, but it usually consists of checking for hardware capacity to send the packet immediately. If possible, the packet payload (and additional payloads in the packet  chain) are loaded into one or more of the hardware transmit buffers and a transmit operation is initiated. If the packet won&#8217;t fit in the available transmit buffers, the packet should be queued, and be transmitted when the transmission buffers become available.</p>
</div>
<div class="paragraph">
<p>The recommended transmit queue is a singly linked list, having both head and tail pointers. New packets are added to the end of the queue, keeping the oldest packet at the front. The <em>nx_packet_queue_next</em> field is used as the packet&#8217;s next link in the queue. The driver defines the head and tail pointers of the transmit queue.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<em>Because this queue is accessed from thread and interrupt portions of the driver, interrupt protection must be placed around the queue manipulations</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Most physical hardware implementations generate an interrupt upon packet transmit completion. When the driver receives such an interrupt, it typically releases the resources associated with the packet just being transmitted. In case the transmit logic reads data directly from the NX_PACKET buffer, the driver should use the <strong><em>nx_packet_transmit_release</em></strong> service to release the packet associated with the transmit complete interrupt back to the available packet pool. Next, the driver examines the transmit queue for additional packets waiting to be sent. As many of the queued transmit packets that fit into the hardware transmit buffer(s) are de-queued and loaded into the buffers. This is followed by initiation of another send operation.</p>
</div>
<div class="paragraph">
<p>As soon as the data in the NX_PACKET has been moved into the transmitter FIFO (or in case a driver supports zero-copy operation, the data in NX_PACKET has been transmitted), the driver must move the <em>nx_packet_prepend_ptr</em> to the beginning of the IP header before calling <strong><em>nx_packet_transmit_release.</em></strong> Remember to adjust <em>nx_packet_length</em> field accordingly. If an IP frame is made up of multiple packets, only the head of the packet chain needs to be released.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_driver_input">Driver Input</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Upon reception of a received packet interrupt, the network driver retrieves the packet from the physical hardware receive buffers and builds a valid NetX Duo packet. Building a valid NetX Duo packet involves setting up the appropriate length field and chaining together multiple packets if the incoming packet&#8217;s size is greater than a single packet payload. Once properly built, the <em>prepend_ptr</em> is moved after the physical layer header and the receive packet is dispatched to NetX Duo.</p>
</div>
<div class="paragraph">
<p>NetX Duo assumes that the IP (IPv4 and IPv6) and ARP headers are aligned on a <strong>ULONG</strong> boundary. The NetX Duo driver must, therefore, ensure this alignment. In Ethernet environments this is done by starting the Ethernet header two bytes from the beginning of the packet. When the <em>nx_packet_prepend_ptr</em> is moved beyond the Ethernet header, the underlying IP (IPv4 and IPv6) or ARP header is 4-byte aligned.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>See the section "Ethernet Headers" below for important differences between IPv6 and IPv6 Ethernet headers</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are several receive packet functions available in NetX Duo. If the received packet is an ARP packet, <em><strong>_nx_arp_packet_deferred_receive</em></strong> is called. If the received packet is an RARP packet, <em><strong>_nx_rarp_packet_deferred_receive</em></strong> is called. There are several options for handling incoming IP packets. For the fastest handling of IP packets, <em><strong>_nx_ip_packet_receive</em></strong> is called. This approach has the least overhead, but requires more processing in the driver&#8217;s receive interrupt service handler (ISR). For minimal ISR processing <em><strong>_nx_ip_packet_deferred_receive</em></strong> is called.</p>
</div>
<div class="paragraph">
<p>After the new receive packet is properly built, the physical hardware&#8217;s receive buffers are setup to receive more data. This might require allocating NetX Duo packets and placing the payload address in the hardware receive buffer or it may simply amount to changing a setting in the hardware receive buffer. To minimize overrun possibilities, it is important that the hardware&#8217;s receive buffers have available buffers as soon as possible after a packet is received.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>The initial receive buffers are setup during driver initialization</em>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_deferred_receive_packet_handling">Deferred Receive Packet Handling</h3>
<div class="paragraph">
<p>The driver may defer receive packet processing to the NetX Duo IP helper thread. For some applications this may be necessary to minimize ISR processing as well as dropped packets.</p>
</div>
<div class="paragraph">
<p>To use deferred packet handling, the NetX Duo library must first be compiled with <strong><em>NX_DRIVER_DEFERRED_PROCESSING</em></strong> defined. This adds the deferred packet logic to the NetX Duo IP helper thread. Next, on receiving a data packet, the driver must call <em>_nx_ip_packet_deferred_receive():</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">_nx_ip_packet_deferred_receive(ip_ptr, packet_ptr);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The deferred receive function places the receive packet represented by <em>packet_ptr</em> on a FIFO (linked list) and notifies the IP helper thread. After executing, the IP helper repetitively calls the deferred handling function to process each deferred packet. The deferred handler processing typically includes removing the packet&#8217;s physical layer header (usually Ethernet) and dispatching it to one of these NetX Duo receive functions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><em>_nx_ip_packet_receive</em></strong></p>
</li>
<li>
<p><strong><em>_nx_arp_packet_deferred_receive</em></strong></p>
</li>
<li>
<p><strong><em>_nx_rarp_packet_deferred_receive</em></strong></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ethernet_headers">Ethernet Headers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the most significant differences between IPv6 and IPv4 for Ethernet Headers is the frame type setting. When sending out packets, the Ethernet driver is responsible for setting the Ethernet frame type in outgoing packets. For IPv6 packets, the frame type should be 0x86DD; for IPv4 packets, the frame type should be 0x0800.</p>
</div>
<div class="paragraph">
<p>The following code segment illustrates this process:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NX_PACKET *packet_ptr;
packet_ptr = driver_req_ptr -&gt; nx_ip_driver_packet;
if (packet_ptr -&gt; nx_packet_ip_version == NX_IP_VERSION_V4)
{

   /* Set Ethernet frame type to IPv4 /*
   ethernet_frame_ptr -&gt; frame_type = 0x0800;

   /* Swap endian-ness for little endian targets.*/
   NX_CHANGE_USHORT_ENDIAN(ethernet_frame_ptr -&gt; frame_type);
}
else if (packet_ptr -&gt; nx_packet_ip_version == NX_IP_VERSION_V6)
{

   /* Set Ethernet frame type to IPv6. /*
   ethernet_frame_ptr -&gt; frame_type = 0x86DD;

   /* Swap endian-ness for little endian targets.*/
   NX_CHANGE_USHORT_ENDIAN(ethernet_frame_ptr -&gt; frame_type);
}
else
{

   /* Unknown IP version. Free the packet we will not send. */
   nx_packet_transmit_release(packet_ptr);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, for incoming packets, the Ethernet driver should determine the packet type from the Ethernet frame type. It should be implemented to accept IPv6 (0x86DD), IPv4 (0x0800), ARP (0x0806), and RARP (0x8035) frame types.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_example_ram_ethernet_network_driver">Example RAM Ethernet Network Driver</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The NetX Duo demonstration system is delivered with a small RAM-based network driver, defined in the file <strong><em>nx_ram_network_driver.c.</em></strong> This driver assumes the IP instances are all on the same network and simply assigns virtual hardware addresses (MAC addresses) to each device instance as they are created. This file provides a good example of the basic structure of NetX Duo physical network drivers. Users may develop their own network drivers using the driver framework presented in this example.</p>
</div>
<div class="paragraph">
<p>The entry function of the network driver is <strong><em>_nx_ram_network_driver(),</em></strong> which is passed to the IP instance create call. Entry functions for additional network interfaces can be passed into the <em>nx_ip_interface_attach()</em> service. After the IP instance starts to run, the driver entry function is invoked to initialize and enable the device (refer to the case <strong>NX_LINK_INITIALIZE</strong> and <strong>NX_LINK_ENABLE</strong>). After the <strong>NX_LINK_ENABLE</strong> command is issued, the device should be ready to transmit and receive packets.</p>
</div>
<div class="paragraph">
<p>The IP instance transmits network packets via one of these commands:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Command</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_LINK_PACKET_SEND</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An IPv4 or IPv6 packet is being transmitted,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_LINK_ARP_SEND</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An ARP request or ARP response packet is being transmitted,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_LINK_ARP_RARP_SEND</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A Reverse ARP request or response packet is being transmitted,</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>On processing these commands, the network driver needs to prepend the appropriate Ethernet frame header, and then send it to the underlying hardware for transmission. During the transmission process, the network driver has the exclusive ownership of the packet buffer area. Therefore once the data is being transmitted (or once the data has been copied into the driver internal transfer buffer), the network driver is responsible for releasing the packet buffer by first moving the prepend pointer past the Ethernet header to the IP header (and adjust packet length accordingly), and then by calling the <strong><em>nx_packet_transmit_release()</em></strong> service to release the packet. Not releasing the packet after data transmission will cause packets to leak.</p>
</div>
<div class="paragraph">
<p>The network device driver is also responsible for handling incoming data packets. In the RAM driver example, the received packet is processed by the function <strong><em>_nx_ram_network_driver_receive()</em></strong>. Once the device receives an Ethernet frame, the driver is responsible for storing the data in  NX_PACKET structure. Note that NetX Duo assumes the IP header starts from 4-byte aligned address. Since the length of Ethernet header is 14byte, the driver needs to store the starting of the Ethernet header at 2-byte aligned address to guarantee that the IP header starts at 4-byte aligned address.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tcpip_offload_driver_guidance">TCP/IP Offload Driver Guidance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For TCP/IP offload feature, a driver function is needed for each IP interface. Here is a list of additional tasks for network driver.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For command <code>NX_LINK_INITIALIZE</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Create a driver thread to handle TCP/IP offload receive events.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For command <code>NX_LINK_INTERFACE_ATTACH</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Set the capability of to driver interface. See sample code below.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">driver_req_ptr -&gt; nx_ip_driver_interface -&gt; nx_interface_capability_flag = NX_INTERFACE_CAPABILITY_TCPIP_OFFLOAD;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>For command <code>NX_LINK_ENABLE</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Start the driver thread.</p>
</li>
<li>
<p>Set TCP/IP callback function to driver interface. See sample code below.</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">driver_req_ptr -&gt; nx_ip_driver_interface -&gt; nx_interface_tcpip_offload_handler = _nx_driver_tcpip_handler;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>For command <code>NX_LINK_DISABLE</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Stop the driver thread</p>
</li>
<li>
<p>Clear TCP/IP callback function of driver interface.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For command <code>NX_LINK_UNINITIALIZE</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Delete the driver thread</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_tcpip_offload_driver_thread">TCP/IP Offload Driver Thread</h3>
<div class="paragraph">
<p>The purpose of driver thread is to receive incoming TCP or UDP packets. In driver thread, there is typically a while loop to check whether there is incoming TCP or UDP packet available or connection established. When data are available, pass the TCP or UDP packet to NetX Duo. The room between <code>nx_packet_data_start</code> and <code>nx_packet_prepend_ptr</code> must be sufficient to insert TCP/IP header. For TCP socket, allocate packet with type <code>NX_TCP_PACKET</code>. For UDP socket, allocate packet with type <code>NX_UDP_PACKET</code>. Fill in incoming data from <code>nx_packet_append_ptr</code> to <code>nx_packet_data_end</code>. The data in <code>nx_packet_append_ptr</code> must contain TCP or UDP payload only. TCP/IP header <strong>MUST</strong> not be filled in packet. Adjust the packet length and set receive interface, then call <code>_nx_tcp_socket_driver_packet_receive</code> for TCP packet and <code>_nx_udp_socket_driver_packet_receive</code> for UDP packet. If a TCP connection is shutdown, call <code>_nx_tcp_socket_driver_packet_receive</code> with packet set to NULL. When connection is established, call <code>_nx_tcp_socket_driver_establish</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcpip_offload_driver_handler">TCP/IP Offload Driver Handler</h3>
<div class="paragraph">
<p>The following driver commands are required for network interfaces with TCP/IP services.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For operation <code>NX_TCPIP_OFFLOAD_TCP_CLIENT_SOCKET_CONNECT</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Allocate resource if needed.</p>
</li>
<li>
<p>Bind to local TCP port and connect to server.</p>
</li>
<li>
<p>Return success on connection established. When the connection is in progress, return <code>NX_IN_PROGRESS</code>. Or else, return failure.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For operation <code>NX_TCPIP_OFFLOAD_TCP_SERVER_SOCKET_LISTEN</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Check for duplicate listen first. It can be called multiple time on same port. First time from <code>nx_tcp_server_socket_listen</code> and then <code>nx_tcp_server_socket_relisten</code>.</p>
</li>
<li>
<p>Allocate resource if needed.</p>
</li>
<li>
<p>Listen to local TCP port.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For operation <code>NX_TCPIP_OFFLOAD_TCP_SERVER_SOCKET_ACCEPT</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Allocate resource if needed.</p>
</li>
<li>
<p>Accept connection.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For operation <code>NX_TCPIP_OFFLOAD_TCP_SERVER_SOCKET_UNLISTEN</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Find TCP socket listening on local port.</p>
</li>
<li>
<p>Close the listening socket if found.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For operation <code>NX_TCPIP_OFFLOAD_TCP_SOCKET_DISCONNECT</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Close the TCP/IP offload connection.</p>
</li>
<li>
<p>Unbind local TCP port.</p>
</li>
<li>
<p>Cleanup resources created during connect.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For operation <code>NX_TCPIP_OFFLOAD_TCP_SOCKET_SEND</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Send data through TCP/IP offload. Be prepare to handle packet length larger than MSS or packet chain situation.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For operation <code>NX_TCPIP_OFFLOAD_UDP_SOCKET_BIND</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Allocate resource if needed.</p>
</li>
<li>
<p>Bind to local UDP port.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For operation <code>NX_TCPIP_OFFLOAD_UDP_SOCKET_UNBIND</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Unbind local UDP port.</p>
</li>
<li>
<p>Cleanup resources created during bind.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For operation <code>NX_TCPIP_OFFLOAD_UDP_SOCKET_SEND</code>,</p>
<div class="ulist">
<ul>
<li>
<p>Send data through TCP/IP offload. Be prepare to handle packet length larger than MTU or packet chain situation.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tsn_driver_support">TSN driver support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TSN shapers are a series of hardware features that can be added to an Ethernet card equipped with TSN capabilities. We will discuss implementation of the PTP driver and the three types of shapers: CBS (Credit-Based Shaper), EST (Enhanced Scheduled Traffic), and FPE (Frame Preemption).</p>
</div>
<div class="sect2">
<h3 id="_ptp_initialize_and_callback_function">PTP initialize and callback function</h3>
<div class="paragraph">
<p>PTP is utilized in various scenarios within the TSN system, particularly when the TAS shaper is enabled. Given the high requirements for the PTP clock, it is recommended to initialize PTP in Fine mode. Additionally, it is necessary to implement the PTP driver callbacks, which are invoked to get, set, and adjust the PTP clock.</p>
</div>
<div class="paragraph">
<p>the driver interface which is used to sychnorize ptp clock in the network.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">UINT nx_driver_ptp_clock_callback(NX_PTP_CLIENT *client_ptr, UINT operation,
                                             NX_PTP_TIME *time_ptr, NX_PACKET *packet_ptr,
                                             VOID *callback_data)</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">operation</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_PTP_CLIENT_CLOCK_INIT</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A driver PTP pointer is initialized,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_PTP_CLIENT_CLOCK_SET</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set PTP clock when syncorize PTP in the network</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_PTP_CLIENT_CLOCK_PACKET_TS_EXTRACT</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Get timestamp from packet,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_PTP_CLIENT_CLOCK_GET</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Get timestamp from PTP clock,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_PTP_CLIENT_CLOCK_ADJUST</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adjust PTP clock by PTP offset when syncorize PTP in the network,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_PTP_CLIENT_CLOCK_PACKET_TS_PREPARE</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add NX_INTERFACE_CAPABILITY_PTP_TIMESTAMP support in interface,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_PTP_CLIENT_CLOCK_SOFT_TIMER_UPDATE</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">update soft timer, Reserved for hardware driver,</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_credit_based_shaper_cbs_ieee_802_1qav_forwarding_and_queuing_enhancements_for_time_sensitive_stream">Credit-based shaper (CBS) - IEEE 802.1Qav Forwarding and Queuing Enhancements for Time-Sensitive Stream</h3>
<div class="paragraph">
<p>In general, a CBS works by assigning "credits" to each data packet. The number of credits a packet has determines when it can be transmitted. Packets with more credits are transmitted before packets with fewer credits. This allows the CBS to prioritize certain data streams over others, ensuring that high-priority data is transmitted first.
The CBS driver needs to be implemented to support the CBS feature. The driver entry will be invoked from the application, passing application data to configure the CBS driver.</p>
</div>
<div class="paragraph">
<p>the driver entry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">UINT nx_driver_shaper_cbs_entry(NX_SHAPER_DRIVER_PARAMETER *parameter)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Data structure of driver entry parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">typedef struct NX_SHAPER_DRIVER_PARAMETER_STRUCT
{
    UINT          nx_shaper_driver_command;
    UCHAR         shaper_type;
    UCHAR         reserved[3];
    void         *shaper_parameter;
    NX_INTERFACE *nx_ip_driver_interface;
} NX_SHAPER_DRIVER_PARAMETER;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Data stucture of CBS parameter which define the necessary parameters that CBS driver needs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">typedef struct NX_SHAPER_CBS_PARAMETER_STRUCT
{
    INT   idle_slope;   /* Mbps */
    INT   send_slope;   /* Mbps */
    INT   hi_credit;
    INT   low_credit;
    UCHAR hw_queue_id;
    UCHAR reserved[3];
} NX_SHAPER_CBS_PARAMETER;</code></pre>
</div>
</div>
<div class="paragraph">
<p>the driver entry parameter:
| parameter -&gt; nx_shaper_driver_command       |  Description                                                     |
| ----------------------------- | --------------------------------------------|
| <strong><em>NX_SHAPER_COMMAND_INIT</em></strong>                | initialization of enabling CBS,                                  |
| <strong><em>NX_SHAPER_COMMAND_CONFIG</em></strong>              | set hardware queue priority and capability of CBS,                |
| <strong><em>NX_SHAPER_COMMAND_PARAMETER_SET</em></strong>       | set parameter passed from application to driver,                 |</p>
</div>
</div>
<div class="sect2">
<h3 id="_time_aware_shaper_tas_ieee_802_1qbv_enhancements_to_traffic_scheduling">Time-Aware Shaper (TAS) - IEEE 802.1Qbv Enhancements to Traffic Scheduling</h3>
<div class="paragraph">
<p>A Time-Aware Shaper (TAS) is a mechanism used in Time-Sensitive Networking (TSN) systems to control the transmission of Ethernet frames based on the time. It&#8217;s part of the IEEE 802.1Qbv standard.
The TAS works by dividing time into repeating cycles, and each cycle is further divided into time intervals, or "gates". Each gate is either open or closed, and frames can only be transmitted when the gate is open.
The TAS driver needs to be implemented to support the TAS feature. The driver entry will be invoked from the application, passing application data to configure the TAS driver.</p>
</div>
<div class="paragraph">
<p>the driver entry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">UINT nx_driver_shaper_tas_entry(NX_SHAPER_DRIVER_PARAMETER *parameter)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Data stucture of TAS parameter which define the necessary parameters that TAS driver needs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">typedef struct NX_SHAPER_TAS_PARAMETER_STRUCT
{
    ULONG64           base_time;
    UINT              cycle_time;
    UINT              cycle_time_extension;
    UINT              gcl_length;
    NX_SHAPER_TAS_GCL gcl[NX_SHAPER_GCL_LENGTH_MAX];
    void             *fp_parameter; /* Configured by shaper */
} NX_SHAPER_TAS_PARAMETER;</code></pre>
</div>
</div>
<div class="paragraph">
<p>the driver entry parameter:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">parameter -&gt; nx_shaper_driver_command</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_SHAPER_COMMAND_INIT</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">initialization of enabling TAS,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_SHAPER_COMMAND_CONFIG</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set hardware queue priority and capability of TAS,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_SHAPER_COMMAND_PARAMETER_SET</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set parameter passed from application to driver,</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_frame_preemption_fpe_802_1qbu">Frame preemption (FPE) - 802.1Qbu</h3>
<div class="paragraph">
<p>In traditional Ethernet networks, once a frame starts transmitting, it must be completely sent before another frame can begin. This can cause delays for time-sensitive data if it has to wait for a large, non-time-sensitive frame to finish transmitting.
Frame Preemption addresses this issue by allowing a high-priority, time-sensitive frame to interrupt the transmission of a low-priority frame. The low-priority frame is then resumed after the high-priority frame has been sent. This ensures that time-sensitive data can be transmitted with minimal delay, even in a busy network
The FPE driver needs to be implemented to support the FPE feature. The driver entry will be invoked from the application, passing application data to configure the FPE driver.
the driver entry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">UINT nx_driver_shaper_fpe_entry(NX_SHAPER_DRIVER_PARAMETER *parameter)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Data structure of TAS parameter which define the necessary parameters that TAS driver needs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">typedef struct NX_SHAPER_FP_PARAMETER_STRUCT
{
    UCHAR verification_enable;          /* Enable/Disable fp verification (Application/Driver) */
    UCHAR express_queue_bitmap;         /* Bitmap of express queues */
    UCHAR express_guardband_enable;     /* Enable/Disable guard band on express queue */
    UCHAR reserved;
    UINT  ha;                           /* Hold advance time */
    UINT  ra;                           /* Release advance time */
} NX_SHAPER_FP_PARAMETER;</code></pre>
</div>
</div>
<div class="paragraph">
<p>the driver entry parameter:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">parameter -&gt; nx_shaper_driver_command</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_SHAPER_COMMAND_INIT</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">initialization of enabling FPE,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_SHAPER_COMMAND_CONFIG</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set hardware queue priority and capability of FPE,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>NX_SHAPER_COMMAND_PARAMETER_SET</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set parameter passed from application to driver,</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-02-07 07:46:26 UTC
</div>
</div>
</body>
</html>