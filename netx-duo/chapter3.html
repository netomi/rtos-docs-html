<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<meta name="description" content="This chapter contains a description of the high- performance NetX Duo TCP/IP stack from a functional perspective.">
<title>Chapter 3 - Functional Components of NetX Duo</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;-webkit-tap-highlight-color:transparent}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Chapter 3 - Functional Components of NetX Duo</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This chapter contains a description of the high- performance NetX Duo TCP/IP stack from a functional perspective.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_execution_overview">Execution Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are five types of program execution within a NetX Duo application: initialization, application interface calls, internal IP thread, IP periodic timers, and the network driver.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>NetX Duo assumes the existence of ThreadX and depends on its thread execution, suspension, periodic timers, and mutual exclusion facilities.</em>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_initialization">Initialization</h3>
<div class="paragraph">
<p>The service <strong><em>nx_system_initialize</em></strong> must be called before any other NetX Duo service is called. System initialization can be called either from the ThreadX <strong><em>tx_application_define</em></strong> function or from application threads.</p>
</div>
<div class="paragraph">
<p>After <strong><em>nx_system_initialize</em></strong> returns, the system is ready to create packet pools and IP instances. Because creating an IP instance requires a default packet pool, at least one NetX Duo packet pool must exist prior to creating an IP instance. Creating packet pools and IP instances are allowed from the ThreadX initialization function <strong><em>tx_application_define</em></strong> and from application threads.</p>
</div>
<div class="paragraph">
<p>Internally, creating an IP instance is accomplished in two parts: The first part is done within the context of the caller, either from <strong><em>tx_application_define</em></strong> or from an application thread&#8217;s context. This includes setting up the IP data structure and creating various IP resources, including the internal IP thread. The second part is performed during the initial execution from the internal IP thread. This is where the network driver, supplied during the first part of IP creation, is first called. Calling the network driver from the internal IP thread enables the driver to perform I/O and suspend during its initialization processing.</p>
</div>
<div class="paragraph">
<p>When the network driver returns from its initialization processing, the IP creation is complete.</p>
</div>
<div class="paragraph">
<p>Initialization of IPv6 in NetX Duo requires a few additional NetX Duo services. These are described in greater detail in the section <a href="#ipv6-in-netx-duo">IPv6 in NetX Duo</a> later in this chapter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>The NetX Duo service <strong>nx_ip_status_check</strong> is available to obtain information on the IP instance and its primary interface status. Such status information includes whether or not the link is initialized, enabled and IP address is resolved. This information is used to synchronize application threads needing to use a newly created IP instance. For multihome systems, see <a href="#multihome-support">Multihome Support</a>. <strong>nx_ip_interface_status_check</strong> is available to obtain 3information on the specified interface.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_application_interface_calls">Application Interface Calls</h3>
<div class="paragraph">
<p>Calls from the application are largely made from application threads running under the ThreadX RTOS. However, some initialization, create, and enable services may be called from <strong><em>tx_application_define</em></strong>. The "Allowed From" sections in <a href="chapter4.html">Chapter 4 - Description of NetX Duo Services</a> indicate from which each NetX Duo service can be called.</p>
</div>
<div class="paragraph">
<p>For the most part, processing intensive activities such as computing checksums is done within the calling thread&#8217;s context&#8212;&#8203;without blocking access of other threads to the IP instance. For example, on transmission, the UDP checksum calculation is performed inside the <strong><em>nx_udp_socket_send</em></strong> service, prior to calling the underlying IP send function. On a received packet, the UDP checksum is calculated in the <strong><em>nx_udp_socket_receive</em></strong> service, executed in the  of the application thread. This helps prevent stalling network requests of higher-priority threads because of processing intensive checksum computation in lower-priority threads.</p>
</div>
<div class="paragraph">
<p>Values, such as IP addresses and port numbers, are passed to APIs in host byte order. Internally these values are stored in host byte order as well. This allows developers to easily view the values via a debugger. When these values are programmed into a frame for transmission, they are converted to network byte order.</p>
</div>
</div>
<div class="sect2">
<h3 id="_internal_ip_thread">Internal IP Thread</h3>
<div class="paragraph">
<p>As mentioned, each IP instance in NetX Duo has its own thread. The priority and stack size of the internal IP thread is defined in the <strong><em>nx_ip_create</em></strong> service. The internal IP thread is created in a ready-to-execute mode. If the IP thread has a higher priority than the calling thread, preemption may occur inside the IP create call.</p>
</div>
<div class="paragraph">
<p>The entry point of the internal IP thread is at the internal function <em><strong>_nx_ip_thread_entry</em></strong>. When started, the internal IP thread first completes network driver initialization, which consists of making three calls to the application-specific network driver. The first call is to attach the network driver to the IP instance, followed by an initialization call, which allows the network driver to go through the initialization process. After the network driver returns from initialization (it may suspend while waiting for the hardware to be properly set up), the internal IP thread calls the network driver again to enable the link. After the network driver returns from the link enable call, the internal IP thread enters a forever loop checking for various events that need processing for this IP instance. Events processed in this loop include deferred IP packet reception, IP packet fragment assembly, ICMP ping processing, IGMP processing, TCP packet queue processing, TCP periodic processing, IP fragment assembly timeouts, and IGMP periodic processing. Events also include address resolution activities; ARP packet processing and ARP periodic processing in IPv4, Duplicate Address Detection, Router Solicitation, and Neighbor Discovery in IPv6.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<em>The NetX Duo callback functions, including listen and disconnect callbacks, are called from the internal IP thread&#8212;&#8203;not the original calling thread. The application must take care not to suspend inside any NetX Duo callback function.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_ip_periodic_timers">IP Periodic Timers</h3>
<div class="paragraph">
<p>There are two ThreadX periodic timers used for each IP instance. The first one is a one-second timer for ARP, IGMP, TCP timeout, and it also drives IP fragment reassemble processing. The second timer is a 100ms timer to drive the TCP retransmission timeout and IPv6-related operations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_network_driver">Network Driver</h3>
<div class="paragraph">
<p>Each IP instance in NetX Duo has a primary interface, which is identified by its device driver specified in the <strong><em>nx_ip_create</em></strong> service. The network driver is responsible for handling various NetX Duo requests, including packet transmission, packet reception, and requests for status and control.</p>
</div>
<div class="paragraph">
<p>For a multi-home system, the IP instance has multiple interfaces, each with an associated network driver that performs these tasks for the respective interface.</p>
</div>
<div class="paragraph">
<p>The network driver must also handle asynchronous events occurring on the media. Asynchronous events from the media include packet reception, packet transmission completion, and status changes. NetX Duo provides the network driver with several access functions to handle various events. These functions are designed to be called from the  interrupt service routine portion of the network driver. For IPv4 networks, the network driver should forward all ARP packets received to the <strong><em>nx_arp_packet_deferred_receive_</strong> internal function. All RARP packets should be forwarded to
<strong></em>nx_rarp_packet_deferred_receive_</strong> internal function. There are two options for IP packets. If fast dispatch of IP packets is required, incoming IP packets should be forwarded to <strong><em>nx_ip_packet_receive_</strong> for immediate processing. This greatly improves NetX Duo performance in handling IP packets. Otherwise, forwarding IP packets to <strong></em>nx_ip_packet_deferred_receive_</strong> should be done. This service places the IP packet in the deferred processing queue where it is then
handled by the internal IP thread, which results in the least amount of ISR processing time.</p>
</div>
<div class="paragraph">
<p>The network driver can also defer interrupt processing to run out of the context of the IP thread. In this mode, the ISR shall save the necessary information, call the internal function <strong><em>_nx_ip_driver_deferred_processing</em></strong>, and acknowledge the interrupt controller. This service notifies IP thread to schedule a callback to the device driver to complete the process of the event that causes the interrupt.</p>
</div>
<div class="paragraph">
<p>Some network controllers are capable of performing TCP/IP header checksum computation and validation in hardware, without taking up valuable CPU resources. To take advantage of the hardware capability feature, NetX Duo provides options to enable or disable various software checksum computation at compilation time, as well as turning on or off checksum computation at run time, if the device driver is able to communicate with the IP layer about is hardware capabilities. See <a href="chapter5.html">Chapter 5 - NetX Duo Network Drivers</a> for more detailed information on writing NetX Duo network drivers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multihome_support">Multihome Support</h3>
<div class="paragraph">
<p>NetX Duo supports systems connected to multiple physical devices using a single IP instance. Each physical interface is assigned to an interface control block in the IP instance. Applications wishing to use a multihome system must define the value for <strong><em>NX_MAX_PHYSICAL_INTERFACES</em></strong> to the number of physical devices attached to the system, and rebuild NetX Duo library. By default <strong><em>NX_MAX_PHYSICAL_INTERFACES</em></strong> is set to one, creating one interface control block in the IP instance.</p>
</div>
<div class="paragraph">
<p>The NetX Duo application creates a single IP instance for the primary device using the <strong><em>nx_ip_create</em></strong> service. For each additional network devices, the application attaches the device to the IP instance using the <strong><em>nx_ip_interface_attach</em></strong> service.</p>
</div>
<div class="paragraph">
<p>Each network interface structure contains a subset of network information about the network interface that is contained in the IP control block, including interface IPv4 address, subnet mask, IP MTU size, and MAC-layer address information.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>NetX Duo with multihome support is backward compatible with earlier versions of NetX Duo. Services that do not take explicit interface information default to the primary network device.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The primary interface has index zero in the IP instance list. Each subsequent device attached to the IP instance is assigned the next index.</p>
</div>
<div class="paragraph">
<p>All upper layer protocol services for which the IP instance is enabled, including TCP, UDP, ICMP, and IGMP, are available to all the attached devices.</p>
</div>
<div class="paragraph">
<p>In most cases, NetX Duo can determine the best source address to use when transmitting a packet. The source address selection is based on the destination address. NetX Duo services are added to allow applications to specify a specific source address to use, in cases where the most suitable one cannot be determined by the destination
address. An example would be in a multihome system, an application needs to send a packet to an IPv4 broadcast or multicast destination addresses.</p>
</div>
<div class="paragraph">
<p>Services specifically for developing multihome applications include the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>nx_igmp_multicast_interface_join</em></p>
</li>
<li>
<p><em>nx_igmp_multicast_interface_leave</em></p>
</li>
<li>
<p><em>nx_ip_driver_interface_direct_command</em></p>
</li>
<li>
<p><em>nx_ip_interface_address_get</em></p>
</li>
<li>
<p><em>nx_ip_interface_address_mapping_configure</em></p>
</li>
<li>
<p><em>nx_ip_interface_address_set</em></p>
</li>
<li>
<p><em>nx_ip_interface_attach</em></p>
</li>
<li>
<p><em>nx_ip_interface_capability_get</em></p>
</li>
<li>
<p><em>nx_ip_interface_capability_set</em></p>
</li>
<li>
<p><em>nx_ip_interface_detach</em></p>
</li>
<li>
<p><em>nx_ip_interface_info_get</em></p>
</li>
<li>
<p><em>nx_ip_interface_mtu_set</em></p>
</li>
<li>
<p><em>nx_ip_interface_physical_address_get</em></p>
</li>
<li>
<p><em>nx_ip_interface_physical_address_set</em></p>
</li>
<li>
<p><em>nx_ip_interface_status_check</em></p>
</li>
<li>
<p><em>nx_ip_raw_packet_source_send</em></p>
</li>
<li>
<p><em>nx_ipv4_multicast_interface_join</em></p>
</li>
<li>
<p><em>nx_ipv4_multicast_interface_leave</em></p>
</li>
<li>
<p><em>nx_udp_socket_source_send</em></p>
</li>
<li>
<p><em>nxd_ipv6_multicast_interface_join</em></p>
</li>
<li>
<p><em>nxd_ipv6_multicast_interface_leave</em></p>
</li>
<li>
<p><em>nxd_udp_socket_source_send</em></p>
</li>
<li>
<p><em>nxd_icmp_source_ping</em></p>
</li>
<li>
<p><em>nxd_ip_raw_packet_source_send</em></p>
</li>
<li>
<p><em>nxd_udp_socket_source_send</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These services are explained in greater detail in <a href="chapter4.html">Description of NetX Duo Services</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_loopback_interface">Loopback Interface</h3>
<div class="paragraph">
<p>The loopback interface is a special network interface without an physical link attached to. The loopback interface allows applications to communicate using the IPv4 loopback address 127.0.0.1 To utilize a logical loopback interface, ensure the configurable option <strong><em>NX_DISABLE_LOOPBACK_INTERFACE</em></strong> is not set.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interface_control_blocks">Interface Control Blocks</h3>
<div class="paragraph">
<p>The number of interface control blocks in the IP instance is the number of physical interfaces (defined by <strong><em>NX_MAX_PHYSICAL_INTERFACES</em></strong>) plus the loopback interface if it is enabled. The total number of interfaces is defined in <strong><em>NX_MAX_IP_INTERFACES</em></strong>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_protocol_layering">Protocol Layering</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The TCP/IP implemented by NetX Duo is a layered protocol, which means more complex protocols are built on top of simpler underlying protocols. In TCP/IP, the lowest layer protocol is at the <em>link level</em> and is handled by the network driver. This level is typically targeted towards Ethernet, but it could also be fiber, serial, or virtually any physical media.</p>
</div>
<div class="paragraph">
<p>On top of the link layer is the <em>network layer</em>. In TCP/IP, this is the IP, which is basically responsible for sending and receiving simple packets&#8212;&#8203;in a best-effort manner&#8212;&#8203;across the network.
Management-type protocols like ICMP and IGMP are typically also categorized as network layers, even though they rely on IP for sending and receiving.</p>
</div>
<div class="paragraph">
<p>The <em>transport layer</em> rests on top of the network layer. This layer is responsible for managing the flow of data between hosts on the network. There are two types of transport services supported by NetX
Duo: UDP and TCP. UDP services provide best-effort sending and receiving of data between two hosts in a connectionless manner, while TCP provides reliable connection-oriented service between two host entities.</p>
</div>
<div class="paragraph">
<p>This layering is reflected in the actual network data packets. Each layer in TCP/IP contains a block of information called a header. This technique of surrounding data (and possibly protocol information) with
a header is typically called data encapsulation. Figure 1 shows an example of NetX Duo layering and Figure 2 shows the resulting data encapsulation for UDP data being sent.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/image12.jpg" alt="Protocol Layering">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 1. Protocol Layering</strong></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_packet_pools">Packet Pools</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Allocating packets in a fast and deterministic manner is always a challenge in real-time networking applications. With this in mind, NetX Duo provides the ability to create and manage multiple pools of
fixed-size network packets.</p>
</div>
<div class="paragraph">
<p>Because NetX Duo packet pools consist of fixed-size memory blocks, there are never any internal fragmentation problems. Of course, fragmentation causes behavior that is inherently nondeterministic. In addition, the time required to allocate and free a NetX Duo packet amounts to simple linked-list manipulation. Furthermore, packet allocation and deallocation is done at the head of the available list. This provides the fastest possible linked list processing.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/image13.png" alt="UDP Data Encapsulation">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 2. UDP Data Encapsulation</strong></p>
</div>
<div class="paragraph">
<p>Lack of flexibility is typically the main drawback of fixed-size packet pools. Determining the optimal packet payload size that also handles the worst-case incoming packet is a difficult task. NetX Duo packets address this problem with an optional feature called packet chaining. An actual network packet can be made of one or more NetX Duo packets linked together. In addition, the packet header maintains a pointer to the top of the packet. As additional protocols are added, this pointer is simply moved backwards and the new header is written directly in front of the data. Without the flexible packet technology, the stack would have to allocate another buffer and copy the data into a new buffer with the new header, which is processing intensive.</p>
</div>
<div class="paragraph">
<p>Since each packet payload size is fixed for a given packet pool, application data larger than the payload size would require multiple packets chained together. When filling a packet with user data, the
application shall use the service <strong><em>nx_packet_data_append</em></strong>. This service moves application data into a packet. In situations where a packet is not enough to hold user data, additional packets are
allocated to store user data. To use packet chaining, the driver must be able to receive into or transmit from chained packets.</p>
</div>
<div class="paragraph">
<p>For embedded systems that do not need to use the packet chaining feature, the NetX Duo library can
be built with <strong><em>NX_DISABLE_PACKET_CHAIN</em></strong> to remove the packet chaining logic. Note that the IP fragmentation and reassembly feature may need to utilize the chained packet feature. Therefore defining <strong><em>NX_DISABLE_PACKET_CHAIN</em></strong> requires <strong><em>NX_DISABLE_FRAGMENTATION</em></strong> also be defined.</p>
</div>
<div class="paragraph">
<p>Each NetX Duo packet memory pool is a public resource. NetX Duo places no constraints on how packet pools are used.</p>
</div>
<div class="sect2">
<h3 id="_packet_pool_memory_area">Packet Pool Memory Area</h3>
<div class="paragraph">
<p>The memory area for the packet pool is specified during creation. Like other memory areas for ThreadX and NetX Duo objects, it can be located anywhere in the target&#8217;s address space.</p>
</div>
<div class="paragraph">
<p>This is an important feature because of the considerable flexibility it gives the application. For example, suppose that a communication product has a high-speed memory area for network buffers. This memory area is easily utilized by making it into a NetX Duo packet memory pool.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_packet_pools">Creating Packet Pools</h3>
<div class="paragraph">
<p>Packet pools are created either during initialization or during runtime by  application threads. There are no limits on the number of packet memory pools in a NetX Duo application.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dual_packet_pool">Dual Packet Pool</h3>
<div class="paragraph">
<p>Typically the payload size of the default IP packet pool is large enough to accommodate frame size up to the network interface MTU. During normal operation, the IP thread needs to send messages such as ARP, TCP control messages, IGMP messages, ICMPv6 messages. These messages use the packets allocated from the default packet pool in the IP instance. On a memory-constrained system where the amount of memory available for packet pool is limited, using a single packet pool (with the large payload size to match MTU size) may not be an optimal solution. NetX Duo allows application to install an auxiliary packet pool, where the payload size is smaller. Once the auxiliary packet pool is installed, the IP helper thread would allocate packets from either the default packet pool or the auxiliary pool, depending on the size of the message it transmits. For an auxiliary packet pool, a payload size of 200 bytes would work with most of the messages the IP helper thread transmits.</p>
</div>
<div class="paragraph">
<p>By default NetX Duo library is built without enabling dual packet pool. To enable the feature, build the library with <strong><em>NX_DUAL_PACKET_POOL_ENABLE</em></strong> defined. Then the auxiliary packet pool can be set by calling <strong><em>nx_ip_auxiliary_packet_pool_set</em></strong>.</p>
</div>
<div class="paragraph">
<p>There is also the option of creating more than one packet pool. For example a transmit packet pool is created with optimal payload size for expected message sizes. A receive packet pool is created in the
driver with a payload size set to the driver MTU, since one cannot predict the size of received packets.</p>
</div>
</div>
<div class="sect2">
<h3 id="_packet_header_nx_packet">Packet Header NX_PACKET</h3>
<div class="paragraph">
<p>By default, NetX Duo places the packet header immediately before the packet payload area. The packet memory pool is basically a series of packets-- headers followed immediately by the
packet payload. The packet header (<strong><em>NX_PACKET</em></strong>) and the layout of the packet pool are pictured in Figure 3.</p>
</div>
<div class="paragraph">
<p>For network devices driver that are able to perform zero copy operations, typically the starting address of the packet payload area is programmed into the DMA logic. Certain DMA engines have alignment
requirement on the payload area. To make the starting address of the payload area align properly for the DMA engine, or the cache operation, the user can define the symbol <strong><em>NX_PACKET_ALIGNMENT</em></strong>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>It is important for the network driver to use the <strong>nx_packet_transmit_release</strong> function when transmission of a packet is complete. This function checks to make sure the packet is not part of a TCP output queue before it is actually placed back in the available pool.</em>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/image14.jpg" alt="Packet Header and Packet Pool Layout">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 3. Packet Header and Packet Pool Layout</strong></p>
</div>
<div class="paragraph">
<p>The fields of the packet header are defined as follows. Note that this table is not a comprehensive list of all the members in the <em>NX_PACKET</em> structure.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Packet header</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>nx_packet_pool_owner</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field points to the packet pool that owns this particular packet. When the packet is released, it is released to this particular pool. With the pool ownership inside each packet, it is possible for a datagram to span multiple packets from multiple packet pools.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>nx_packet_next</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field points to the next packet within the same frame. If NULL, there are no additional packets that are part of the frame. This field is also used to hold fragmented packets until the entire packet can be re-assembled. it is removed if <strong><em>NX_DISABLE_PACKET_CHAIN</em></strong>is defined.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>nx_packet_last</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field points to the last packet within the same network packet. If NULL, this packet represents the entire network packet. This field is removed if <strong><em>NX_DISABLE_PACKET_CHAIN</em></strong>is defined.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>nx_packet_length</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the total number of bytes in the entire network packet, including the total of all bytes in all packets chained together by the <em>nx_packet_next</em>member.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>nx_packet_ip_interface</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field is the interface control block which is assigned to the packet when it is received by the interface driver, and by NetX Duo for outgoing packets. An interface control block describes the interface e.g. network address, MAC address, IP address and interface status such as link enabled and physical mapping required.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>nx_packet_data_start</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field points to the start of the physical payload area of this packet. It does not have to be immediately following the NX_PACKET header, but that is the default for the <strong><em>nx_packet_pool_create</em></strong> service.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>nx_packet_data_end</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field points to the end of the physical payload area of this packet. The difference between this field and the <em>nx_packet_data_start</em> field represents the payload size.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>nx_packet_prepend_ptr</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field points to the location of where packet data, either protocol header or actual data, is added in front of the existing packet data (if any) in the packet payload area. It must be greater than or equal to the <em>nx_packet_data_start</em> pointer location and less than or equal to the <em>nx_packet_append_ptr</em> pointer.<br>
<br>
<strong>Caution:</strong> <em>For performance reasons, NetX Duo assumes that when the packet is passed into NetX Duo services for transmission, the prepend pointer points to long word aligned address.</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>nx_packet_append_ptr</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field points to the end of the data currently in the packet payload area. It must be in between the memory location pointed to by <em>nx_packet_prepend_ptr</em> and <em>nx_packet_data_end.</em> The difference between this field and the <em>nx_packet_prepend_ptr</em> field represents the amount of data in this packet.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>nx_packet_packet_pad</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This fields defines the length of padding in 4-byte words to achieve the desired alignment requirement. This field is removed if <strong><em>NX_PACKET_HEADER_PAD</em></strong> is not defined. Alternatively <strong><em>NX_PACKET_ALIGNMENT</em></strong> can be used instead of defining <em>nx_packet_header_pad.</em></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_packet_header_offsets">Packet Header Offsets</h3>
<div class="paragraph">
<p>Packet header size is defined to allow enough room  to accommodate the size of the header. The <strong><em>nx_packet_allocate</em></strong> service is used to allocate a packet and adjusts the prepend pointer in the packet according to the type of packet specified. The packet type tells NetX Duo the offset required
for inserting the protocol header (such as UDP, TCP, or ICMP) in front of the protocol data.</p>
</div>
<div class="paragraph">
<p>The following types are defined in NetX Duo to take into account the IP header and physical layer (Ethernet) header in the packet. In the latter case, it is assumed to be 16 bytes taking the required 4-byte alignment into consideration. IPv4 packets are still defined in NetX Duo for applications to allocate packets for IPv4 networks. Note that if the NetX Duo library is built with IPv6 enabled, the generic packet types (such as NX_IP_PACKET) are mapped to the IPv6 version. If the NetX Duo Library is built without IPv6 enabled, these generic packet types are mapped to the IPv4 version.</p>
</div>
<div class="paragraph">
<p>The following table shows symbols defined with IPv6 enabled:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Packet Type</strong></th>
<th class="tableblock halign-left valign-top"><strong>Value</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_IPv6_PACKET (NX_IP_PACKET)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x38</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_UDPv6_PACKET (NX_UDP_PACKET)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x40</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_TCPv6_PACKET (NX_TCP_PACKET)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x4c</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_IPv4_PACKET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x24</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_IPv4_UDP_PACKET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2c</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_IPv4_TCP_PACKET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x38</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table shows symbols defined with IPv6 disabled:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Packet Type</strong></th>
<th class="tableblock halign-left valign-top"><strong>Value</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_IPv4_PACKET (NX_IP_PACKET)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x24</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_IPv4_UDP_PACKET (NX_UDP_PACKET)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2c</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_IPv4_TCP_PACKET (NX_TCP_PACKET)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x38</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note that these values will change if <em>NX_IPSEC_ENABLE</em> is defined. For application using IPsec, refer to NetX Duo IPsec User Guide for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pool_capacity">Pool Capacity</h3>
<div class="paragraph">
<p>The number of packets in a packet pool is a function of the payload size and the total number of bytes in the memory area supplied to the packet pool create service. The capacity of the pool is calculated by dividing the packet size (including the size of the NX_PACKET header, the payload size, and proper alignment) into the total number of bytes in the supplied memory area.</p>
</div>
</div>
<div class="sect2">
<h3 id="_payload_area_alignment">Payload Area Alignment</h3>
<div class="paragraph">
<p>Packet pool design in NetX Duo supports zero-copy. At the device driver level, the driver is able to assign the payload area directly into buffer descriptors for data reception. Sometimes the DMA engine or the cache synchronization mechanism requires the starting address of the payload area to have a certain alignment requirement. This can be achieved by defining the desired alignment requirement (in bytes) in <strong><em>NX_PACKET_ALIGNMENT</em></strong>. When creating a packet pool, the starting address of the payload area will aligned to this value. By default, starting address is 4-byte aligned.</p>
</div>
</div>
<div class="sect2">
<h3 id="_thread_suspension">Thread Suspension</h3>
<div class="paragraph">
<p>Application threads can suspend while waiting for a packet from an empty pool. When a packet is returned to the pool, the suspended thread is given this packet and resumed.</p>
</div>
<div class="paragraph">
<p>If multiple threads are suspended on the same packet pool, they  resumed in the order they were suspended (FIFO).</p>
</div>
</div>
<div class="sect2">
<h3 id="_pool_statistics_and_errors">Pool Statistics and Errors</h3>
<div class="paragraph">
<p>If enabled, the NetX Duo packet management software keeps track of several statistics and errors that may be useful to the application. The following statistics and error reports are maintained for packet pools:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Total Packets in Pool</p>
</li>
<li>
<p>Free Packets in Pool</p>
</li>
<li>
<p>Total Packet Allocations</p>
</li>
<li>
<p>Pool Empty Allocation Requests</p>
</li>
<li>
<p>Pool Empty Allocation Suspensions</p>
</li>
<li>
<p>Invalid Packet Releases</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All of these statistics and error reports, except for total and free packet count in pool, are built into NetX Duo library unless <strong><em>NX_DISABLE_PACKET_INFO</em></strong> is defined. This data is available to the application with the <strong><em>nx_packet_pool_info_get</em></strong> service.</p>
</div>
</div>
<div class="sect2">
<h3 id="_packet_pool_control_block_nx_packet_pool">Packet Pool Control Block NX_PACKET_POOL</h3>
<div class="paragraph">
<p>The characteristics of each packet memory pool are found in its control block. It contains useful information such as the linked list of free packets, the number of free packets, and the payload size for packets in this pool. This structure is defined in the <strong><em>nx_api.h</em></strong> file.</p>
</div>
<div class="paragraph">
<p>Packet pool control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ipv4_protocol">IPv4 Protocol</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Internet Protocol (IP) component of NetX Duo is responsible for sending and receiving IPv4 packets on the Internet. In NetX Duo, it is the component ultimately responsible for sending and receiving TCP,
UDP, ICMP, and IGMP messages, utilizing the underlying network driver.</p>
</div>
<div class="paragraph">
<p>NetX Duo supports both IPv4 protocol (RFC 791) and IPv6 protocol (RFC 2460). This section discusses IPv4. IPv6 is discussed in the next section.</p>
</div>
<div class="sect2">
<h3 id="_ipv4_addresses">IPv4 Addresses</h3>
<div class="paragraph">
<p>Each host on the Internet has a unique 32-bit identifier called an IP address. There are five classes of IPv4 addresses as described in Figure 4. The ranges of the five IPv4 address classes are as follows:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Class</th>
<th class="tableblock halign-left valign-top">Range</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.0 to 127.255.255.255</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128.0.0.0 to 191.255.255.255</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">192.0.0.0 to 223.255.255.255</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">224.0.0.0 to 239.255.255.255</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">240.0.0.0 to 247.255.255.255</p></td>
</tr>
</tbody>
</table>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/ipv4-address-structure.PNG" alt="Diagram of the IPv4 Address Structure.">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 4. IPv4 Address Structure</strong></p>
</div>
<div class="paragraph">
<p>There are also three types of address specifications: <em>unicast</em>, <em>broadcast</em>, and <em>multicast</em>. Unicast addresses are those IPv4 addresses that identify a specific host on the Internet. Unicast addresses can be either a source or a destination IPv4 address. A broadcast address identifies all hosts on a specific network or sub-network and can only be used as destination addresses. Broadcast addresses are specified by having the host ID portion of the address set to ones. Multicast addresses (Class D) specify a dynamic group of hosts on the Internet. Members of the multicast group may join and leave whenever they wish.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>Only connectionless protocols like UDP over IPv4 can utilize broadcast and the limited broadcast capability of the multicast group.</em>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>The macro <strong>IP_ADDRESS</em> is defined in *<em>nx_api.h</em></strong>. It allows easy specification of IPv4 addresses using commas instead of a periods. For example, <em>IP_ADDRESS(128,0,0,0)</em> specifies the first class B address shown in Figure 4.*
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_ipv4_gateway_address">IPv4 Gateway Address</h3>
<div class="paragraph">
<p>Network gateways assist hosts on their networks to relay packets destined to destinations outside the local domain. Each node has some knowledge of which next hop to send to, either the destination
one of its neighbors, or through a pre-programmed static routing table. However if these approaches fail, the node should forward the packet to its default gateway which has better knowledge on how to
route the packet to its destination. Note that the default gateway must be directly accessible through one of the physical interfaces attached to the IP instance. The application calls <strong><em>nx_ip_gateway_address_set</em></strong> to configure IPv4 default gateway address. Use the service <strong><em>nx_ip_gateway_address_get</em></strong> to retrieve the current IPv4 gateway settings. Application shall use the service <strong><em>nx_ip_gateway_address_clear</em></strong> to clear the gateway setting.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ipv4_header">IPv4 Header</h3>
<div class="paragraph">
<p>For any IPv4 packet to be sent on the Internet, it must have an IPv4 header. When higher-level protocols (UDP, TCP, ICMP, or IGMP) call the IP component to send a packet, the IPv4 transmit
module places an IPv4 header in front of the data. Conversely, when IP packets are received from the network, the IP component removes the IPv4 header from the packet before delivery to the higher-level protocols. Figure 5 shows the format of the IP header.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/ipv4-header-format.png" alt="IPv4 Header Format">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 5. IPv4 Header Format</strong></p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>All headers in the TCP/IP implementation are expected to be in <strong>big endian</strong> format. In this format, the most significant byte of the word resides at the lowest byte address. For example, the 4-bit version and the 4-bit header length of the IP header must be located on the first byte of the header.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The fields of the IPv4 header are defined as follows:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">IPv4&nbsp;Header&nbsp;Field</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>4-bit version</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the version of IP this header represents. For IP version 4, which is what NetX Duo supports, the value of this field is 4.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>4-bit header length</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field specifies the number of 32-bit words in the IP header. If no option words are present, the value for this field is 5.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>8-bit type of service (TOS)</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field specifies the type of service requested for this IP packet. Valid requests are as follows:<br>
- Normal: 0x00<br>
- Minimum Delay: 0x00<br>
- Maximum Data: 0x08<br>
- Maximum Reliability: 0x04<br>
- Minimum Cost: 0x02</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>16-bit total length</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the total length of the IP datagram in bytes, including the IP header. An IP datagram is the basic unit of information found on a TCP/IP Internet. It contains a destination and source address in addition to data. Because it is a 16-bit field, the maximum size of an IP datagram is 65,535 bytes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>16-bit identification</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The field is a number used to uniquely identify each IP datagram sent from a host. This number is typically incremented after an IP datagram is sent. It is especially useful in assembling received IP packet fragments.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>3-bit flags</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains IP fragmentation information. Bit 14 is the "don&#8217;t fragment" bit. If this bit is set, the outgoing IP datagram will not be fragmented. Bit 13 is the "more fragments" bit. If this bit is set, there are more fragments. If this bit is clear, this is the last fragment of the IP packet.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>13-bit fragment offset</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the upper 13-bits of the fragment offset. Because of this, fragment offsets are only allowed on 8-byte boundaries. The first fragment of a fragmented IP datagram will have the "more fragments" bit set and have an offset of 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>8-bit time to live (TTL)</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the number of routers this datagram can pass, which basically limits the lifetime of the datagram.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>8-bit protocol</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field specifies which protocol is using the IP datagram. The following is a list of valid protocols and their values:<br>
- ICMP: 0x01<br>
- IGMP: 0x02<br>
- TCP: 0X06<br>
- UDP: 0X11</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>16-bit checksum</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the 16-bit checksum that covers the IP header only. There are additional checksums in the higher level protocols that cover the IP payload.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>32-bit source IP address</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the IP address of the sender and is always a host address.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>32-bit destination IP address</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the IP address of the receiver or receivers if the address is a broadcast or multicast address.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_creating_ip_instances">Creating IP Instances</h3>
<div class="paragraph">
<p>IP instances are created either during initialization or during runtime by application threads. The initial IPv4 address, network mask, default packet pool, media driver, and memory and priority of the internal IP thread are defined by the <strong><em>nx_ip_create</em></strong>service even if the application intends to use IPv6 networks only. If the application initializes the IP instance with its IPv4 address set to an invalid address(0.0.0.0), it is assumed that the interface address is going to resolved by manual configuration later, via RARP, or through DHCP or similar protocols.</p>
</div>
<div class="paragraph">
<p>For systems with multiple network interfaces, the primary interface is designated when calling <strong><em>nx_ip_create</em></strong>. Each additional interface can be attached to the same IP instance by calling <strong><em>nx_ip_interface_attach</em></strong>. This service stores information about the network interface (such as IP
address, network mask) in the interface control block, and associates the driver instance with the interface control block in the IP instance. As the driver receives a data packet, it needs to store the
interface information in the NX_PACKET structure before forwarding it to the IP receive logic. Note an IP instance must already be created before attaching any interfaces.</p>
</div>
<div class="paragraph">
<p>IPv6 services are not started after calling <strong><em>nx_ip_create</em></strong>. Applications wishing to use IPv6 services must call the service <strong><em>nx_ipv6_enable</em></strong> to start IPv6.</p>
</div>
<div class="paragraph">
<p>On the IPv6 network, each interface in an IP instance may have multiple IPv6 global addresses. In addition to using DHCPv6 for IPv6 address assignment, a device may also use Stateless Address Autoconfiguration. More information is available in the "IP Control Block" and "IPv6 Address Resolution"
sections later in this chapter.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ip_send">IP Send</h3>
<div class="paragraph">
<p>The IP send processing in NetX Duo is very streamlined. The prepend pointer in the packet is moved backwards to accommodate the IP header. The IP header is completed (with all the options specified by the calling protocol layer), the IP checksum is computed in-line (for IPv4 packets only), and the packet is dispatched to the associated network driver. In addition, outgoing fragmentation is also coordinated from within the IP send processing.</p>
</div>
<div class="paragraph">
<p>For IPv4, NetX Duo initiates ARP requests if physical mapping is needed for the destination IP address. IPv6 uses Neighbor Discovery for IPv6-address-to-physical-address mapping.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>For IPv4 connectivity, packets that require IP address resolution (i.e., physical mapping) are enqueued on the ARP queue until the number of packets queued exceeds the ARP queue depth (defined by the symbol <strong>NX_ARP_MAX_QUEUE_DEPTH</strong>). If the queue depth is reached, NetX Duo will remove the oldest packet on the queue and continue waiting for address resolution for the remaining packets enqueued. On the other hand, if an ARP entry is not resolved, the pending packets on the ARP entry are released upon ARP entry timeout.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For systems with multiple network interfaces, NetX Duo chooses an interface based on the destination IP address. The following procedure applies to the selection process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If the sender specifies an outgoing interface and the interface is valid, use that interface.</p>
</li>
<li>
<p>If a destination address is IPv4 broadcast or multicast, the first enabled physical interface is used.</p>
</li>
<li>
<p>If the destination address is found in the static routing table, the interface associated with the gateway is used.</p>
</li>
<li>
<p>If the destination is on-link, the on-link interface is used.</p>
</li>
<li>
<p>If the destination address is a link-local address (169.254.0.0/16), the first valid interface is used.</p>
</li>
<li>
<p>If the default gateway is configured, use the interface associated with the default gateway to transmit the packet.</p>
</li>
<li>
<p>Finally, if one of the valid interface IP address is link-local address (169.254.0.0/16), this interface is used as source address for the transmission.</p>
</li>
<li>
<p>The output packet is dropped if all above fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_ip_receive">IP Receive</h3>
<div class="paragraph">
<p>The IP receive processing is either called from the network driver or the internal IP thread (for processing packets on the deferred received packet queue). The IP receive processing examines the protocol field and attempts to dispatch the packet to the proper protocol component. Before the packet is actually dispatched, the IP header is removed by advancing the prepend pointer past the IP header.</p>
</div>
<div class="paragraph">
<p>IP receive processing also detects fragmented IP packets and performs the necessary steps to reassemble them if fragmentation is enabled. If fragmentation is needed but not enabled, the packet is dropped.</p>
</div>
<div class="paragraph">
<p>NetX Duo determines the appropriate network interface based on the interface specified in the packet. If the packet interface is NULL, NetX Duo defaults to the primary interface. This is done to guarantee compatibility with legacy NetX Duo Ethernet drivers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_raw_ip_send">Raw IP Send</h3>
<div class="paragraph">
<p>A raw IP packet is an IP frame that contains upper layer protocol payload not directly supported (and processed) by NetX Duo. A raw packet allows developers to define their own IP-based applications. An application may send raw IP packets directly using the <strong><em>nxd_ip_raw_packet_send</em></strong> service if raw IP packet processing has been enabled with the <strong><em>nx_ip_raw_packet_enabled</em></strong> service. When transmitting a unicast packet on an IPv6 network, NetX Duo automatically determines the best source IPv6 address to use to send the packets out on, based on the destination address. If the destination address is a multicast (or broadcast for IPv4) address, however, NetX Duo will default to the first (primary) interface. Therefore, to send such packets out on secondary interfaces, the application must use the <strong><em>nx_ip_raw_packet_source_send</em></strong> service to specify the source address to use for the outgoing packet.</p>
</div>
</div>
<div class="sect2">
<h3 id="_raw_ip_receive">Raw IP Receive</h3>
<div class="paragraph">
<p>If raw IP packet processing is enabled, the application may receive raw IP packets through the <strong><em>nx_ip_raw_packet_receive</em></strong> service. All incoming packets are processed according to the protocol specified in the IP header. If the protocol specifies UDP, TCP, IGMP or ICMP, NetX Duo will process the packet using the appropriate handler for the packet protocol type. If the protocol is not one of these protocols, and raw IP receive is enabled, the incoming packet will be put into the raw packet queue waiting for the application to receive it via the <strong><em>nx_ip_raw_packet_receive</em></strong> service. In addition, application threads may suspend with an optional timeout while waiting for a raw
IP packet. The number of packets that can be queued on the raw packet queue is limited. The maximum value is defined in <strong><em>NX_IP_RAW_MAX_QUEUE_DEPTH</em></strong>, whose default value is 20. An application may change the maximum value by calling the <strong><em>nx_ip_raw_receive_queue_max_set</em></strong> service.</p>
</div>
<div class="paragraph">
<p>Alternatively, the NetX Duo library may be built with <strong><em>NX_ENABLE_IP_RAW_PACKET_FILTER</em>.</strong> In this mode of operation, the application provides a callback function that is invoked every time a packet with an unhandled protocol type is received. The IP receive logic forwards the packet to the user-defined raw packet receive filter routine. The filter routine decides whether or not to keep the raw packet for future process. The return value from the callback routine indicates whether the packet has been processed by the raw packet receive filter. If the packet is processed by the callback function, the packet should be released after the application is done with the packet. Otherwise, NetX Duo is responsible for releasing the packet. Refer to the <strong><em>nx_ip_raw_packet_filter_set</em></strong> for more information on how to use the raw packet filter function.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>The BSD wrapper function for NetX Duo relies on the raw packet filter function to handle BSD raw sockets. Therefore, to support raw socket in the BSD wrapper, the NetX Duo library must be built with <strong>*NX_ENABLE_IP_RAW_PACKET_FILTER*</em> defined, and the application should not use the *<em>nx_ip_raw_packet_filter_set</em></strong> to install its own raw packet filter functions.*
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_default_packet_pool">Default Packet Pool</h3>
<div class="paragraph">
<p>Each IP instance is given a default packet pool during creation. This packet pool is used to allocate packets for ARP, RARP, ICMP, IGMP, various TCP control packets (SYN, ACK, and so on), Neighbor Discovery, Router Discovery, and Duplicate Address Detection. If the default packet pool is empty when NetX Duo needs to allocate a packet, NetX Duo may have to abort the particular operation, and will return an error message if possible.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ip_helper_thread">IP Helper Thread</h3>
<div class="paragraph">
<p>Each IP instance has a helper thread. This thread is responsible for handling all deferred packet processing and all periodic processing. The IP helper thread is created in <strong><em>nx_ip_create.</em></strong>This is where the thread is given its stack and priority. Note that the first processing in the IP helper thread is to finish the network driver initialization associated with the IP create service. After the network driver initialization is complete, the helper thread starts an endless loop to process packet and periodic requests.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If unexplained behavior is seen within the IP helper thread, increasing its stack size during the IP create service is the first debugging step. If the stack is too small, the IP helper thread could
possibly be overwriting memory, which may cause unusual problems.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_thread_suspension_2">Thread Suspension</h3>
<div class="paragraph">
<p>Application threads can suspend while attempting to receive raw IP packets. After a raw packet is received, the new packet is given to the first thread suspended and that thread is resumed. NetX Duo services for receiving packets all have an optional suspension timeout. When a packet is received or the timeout expires, the application thread is resumed with the appropriate completion status.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ip_statistics_and_errors">IP Statistics and Errors</h3>
<div class="paragraph">
<p>If enabled, the NetX Duo keeps track of several statistics and errors that may be useful to the application. The following statistics and error reports are maintained for each IP instance:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Total IP Packets Sent</p>
</li>
<li>
<p>Total IP Bytes Sent</p>
</li>
<li>
<p>Total IP Packets Received</p>
</li>
<li>
<p>Total IP Bytes Received</p>
</li>
<li>
<p>Total IP Invalid Packets</p>
</li>
<li>
<p>Total IP Receive Packets Dropped</p>
</li>
<li>
<p>Total IP Receive Checksum Errors</p>
</li>
<li>
<p>Total IP Send Packets Dropped</p>
</li>
<li>
<p>Total IP Fragments Sent</p>
</li>
<li>
<p>Total IP Fragments Received</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All of these statistics and error reports are available to the application with the <strong><em>nx_ip_info_get</em></strong>service.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ip_control_block_nx_ip">IP Control Block NX_IP</h3>
<div class="paragraph">
<p>The characteristics of each IP instance are found in its control block. It contains useful information such as the IP addresses and network masks of each network device, and a table of neighbor IP and physical hardware address mapping. This structure is defined in the <strong><em>nx_api.h</em></strong>file. If IPv6 is enabled, it also contains an array of IPv6 address, the number of which is specified by the user configurable option <strong><em>NX_MAX_IPV6_ADDRESSES</em></strong>. The default value allows each physical network
interface to have three IPv6 addresses.</p>
</div>
<div class="paragraph">
<p>IP instance control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</p>
</div>
</div>
<div class="sect2">
<h3 id="_static_ipv4_routing">Static IPv4 Routing</h3>
<div class="paragraph">
<p>The static routing feature allows an application to specify an IPv4 network and next hop address for specific out of network destination IP addresses. If static routing is enabled, NetX Duo searches through the static routing table for an entry matching the destination address of the packet to send. If no match is found, NetX Duo searches through the list of physical interfaces and chooses a source IP address and next hop address based on the destination IP address and the network mask. If the destination does not match any of the IP addresses of the network drivers attached to the IP instance,
NetX Duo chooses an interface that is directly connected to the default gateway, and uses the IP address of the interface as source address, and the default gateway as the next hop.</p>
</div>
<div class="paragraph">
<p>Entries can be added and removed from the static routing table using the <strong><em>nx_ip_static_route_add</em></strong> and <strong><em>nx_ip_static_route_delete</em></strong> services, respectively. To use static routing, the host application must enable this feature by defining
<strong><em>NX_ENABLE_IP_STATIC_ROUTING.</em></strong></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>When adding an entry to the static routing table, NetX Duo checks for a matching entry for the specified destination address already in the table. If one exists, it gives preference to the entry with the smaller network (longer prefix) in the network mask.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_ipv4_forwarding">IPv4 Forwarding</h3>
<div class="paragraph">
<p>If the incoming IPv4 packet is not destined for this node and IPv4 forwarding feature is enabled, NetX Duo attempts to forward the packet out via the other interfaces.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ip_fragmentation">IP Fragmentation</h3>
<div class="paragraph">
<p>The network device may have limits on the size of outgoing packets. This limit is called the maximum transmission unit (MTU). IP MTU is the largest IP frame size a link layer driver is able to transmit without fragmenting the IP packet. During a device driver initialization phase, the driver module must configure its IP MTU size via the service <strong><em>nx_ip_interface_mtu_set.</em></strong></p>
</div>
<div class="paragraph">
<p>Although not recommended, the application may generate datagrams larger than the underlying IP MTU supported by the device. Before transmitting such IP datagram, the IP layer must fragment these packets. On receiving fragmented IP frames, the receiving end must store all fragmented IP frames with the same fragmentation ID, and reassemble them in order. If the IP receive logic is unable to collect all the fragments to restore the original IP frame in time, all the fragments are released. It is up to the upper layer protocol to detect such packet loss and recover from it.</p>
</div>
<div class="paragraph">
<p>The IP fragmentation applies to both IPv4 and IPv6 packets.</p>
</div>
<div class="paragraph">
<p>In order to support IP fragmentation and reassembly operation, the system designer must enable the IP fragmentation feature in NetX Duo using the <strong><em>nx_ip_fragment_enable</em></strong> service. If this feature is
not enabled, incoming fragmented IP packets are discarded, as well as packets that exceed the network driver&#8217;s MTU.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>The IP Fragmentation logic can be removed completely by defining <strong>*NX_DISABLE_FRAGMENTATION*</em> when building the NetX Duo library. Doing so helps reduce the code size of NetX Duo. Note that in this situation, both the IPv4 and IPv6 fragmentation/reassembly functions are disabled.</strong>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>If <strong>NX_DISABLE_CHAINED_PACKET</strong> is defined, IP fragmentation must be disabled.</em>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>In an IPv6 network, routers do not fragment a datagram if the size of the datagram exceeds its minimum MTU size. Therefore, it is up to the sending device to determine the minimum MTU between the source and the destination, and to ensure the IP datagram size does not exceed the path MTU. In NetX Duo, IPv6 PATH MTU discovery can be enabled by building NetX Duo library with the symbol <strong>NX_ENABLE_IPV6_PATH_MTU_DISCOVERY</strong> defined.</em>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_address_resolution_protocol_arp_in_ipv4">Address Resolution Protocol (ARP) in IPv4</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Address Resolution Protocol (ARP) is responsible for dynamically mapping 32-bit IPv4 addresses to those of the underlying physical media (RFC 826). Ethernet is the most typical physical media, and it
supports 48-bit addresses. The need for ARP is determined by the network driver supplied to the <strong><em>nx_ip_create</em></strong> service. If physical mapping is required, the network driver must use the <strong><em>nx_interface_address_mapping_needed</em></strong> service to configure the driver interface properly.</p>
</div>
<div class="sect2">
<h3 id="_arp_enable">ARP Enable</h3>
<div class="paragraph">
<p>For ARP to function properly, it must first be enabled by the application with the <strong><em>nx_arp_enable</em></strong> service. This service sets up various data structures for ARP processing, including the creation of an ARP cache area from the memory supplied to the ARP enable service.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arp_cache">ARP Cache</h3>
<div class="paragraph">
<p>The ARP cache can be viewed as an array of internal ARP mapping data structures. Each internal structure is capable of maintaining the relationship between an IP address and a physical hardware address. In addition, each data structure has link pointers so it can be part of multiple linked lists.</p>
</div>
<div class="paragraph">
<p>Application can look up an IP address from the ARP cache by supplying hardware MAC address using the service <strong><em>nx_arp_ip_address_find</em></strong> if the mapping exists in the ARP table. Similarly, the service <strong><em>nx_arp_hardware_address_find</em></strong> returns the MAC address for a given IP address.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arp_dynamic_entries">ARP Dynamic Entries</h3>
<div class="paragraph">
<p>By default, the ARP enable service places all entries in the ARP cache on the list of available dynamic ARP entries. A dynamic ARP entry is allocated from this list by NetX Duo when a send request to an unmapped IP address is detected. After allocation, the ARP entry is set up and an ARP request is sent to the physical media.</p>
</div>
<div class="paragraph">
<p>A dynamic entry can also be created by the service <strong><em>nx_arp_dynamic_entry_set</em></strong>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If all dynamic ARP entries are in use, the least recently used ARP entry is replaced with a new mapping.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_arp_static_entries">ARP Static Entries</h3>
<div class="paragraph">
<p>The application can also set up static ARP mapping by using the <strong><em>nx_arp_static_entry_create</em></strong>service. This service allocates an ARP entry from the dynamic ARP entry list and places it on the static list with the mapping information supplied by the application. Static ARP entries are not subject to reuse or aging. The application can delete a static entry by using the service <strong><em>nx_arp_static_entry_delete</em></strong>. To remove all static entries in the ARP table, the application may use the service <strong><em>nx_arp_static_entries_delete</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_automatic_arp_entry">Automatic ARP Entry</h3>
<div class="paragraph">
<p>NetX Duo records the peer&#8217;s IP/MAC mapping after the peer responses to the ARP request. NetX Duo also implements the automatic ARP entry feature where it records peer IP/MAC address mapping based on unsolicited ARP requests from the network. This feature allows the ARP table to be populated with peer information, reducing the delay needed to go through the ARP request/response cycle. However the downside with enabling automatic ARP is that the ARP table tend to fill up quickly on a busy network with many nodes on the local link, which would eventually lead to ARP entry replacement.</p>
</div>
<div class="paragraph">
<p>This feature is enabled by default. To disable it, the NetX Duo library must be compiled with the symbol <strong><em>NX_DISABLE_ARP_AUTO_ENTRY</em></strong>defined.&lt;/p&gt;</p>
</div>
</div>
<div class="sect2">
<h3 id="_arp_messages">ARP Messages</h3>
<div class="paragraph">
<p>As mentioned previously, an ARP request message is sent when the IP task detects that mapping is needed for an IP address. ARP requests are sent periodically (every <strong><em>NX_ARP_UPDATE_RATE</em></strong> seconds) until a corresponding ARP response is received. A total of <strong><em>NX_ARP_MAXIMUM_RETRIES</em></strong> ARP requests are made before the ARP attempt is abandoned. When an ARP response is received, the associated physical address information is stored in the ARP entry that is in the cache.</p>
</div>
<div class="paragraph">
<p>For multihome systems, NetX Duo determines which interface to send the ARP requests and responses based on destination address specified.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>Outgoing IP packets are queued while NetX Duo waits for the ARP response. The number of outgoing IP packets queued is defined by the constant <strong>NX_ARP_MAX_QUEUE_DEPTH</strong>.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>NetX Duo also responds to ARP requests from other nodes on the local IPv4 network. When an external ARP request is made that matches the current IP address of the interface that receives the ARP request, NetX Duo builds an ARP response message that contains the current physical address.</p>
</div>
<div class="paragraph">
<p>The formats of Ethernet ARP requests and responses are shown in Figure 6 and are described below.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Request/Response&nbsp;Field</strong></th>
<th class="tableblock halign-left valign-top"><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>Ethernet Destination Address</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This 6-byte field contains the destination address for the ARP response and is a broadcast (all ones) for ARP requests. This field is setup by the network driver.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>Ethernet Source Address</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This 6-byte field contains the address of the sender of the ARP request or response and is set up by the network driver.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>Frame Type</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This 2-byte field contains the type of Ethernet frame present and, for ARP requests and responses, this is equal to 0x0806. This is the last field the network driver is responsible for setting up.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>Hardware Type</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This 2-byte field contains the hardware type, which is 0x0001 for Ethernet.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>Protocol Type</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This 2-byte field contains the protocol type, which is 0x0800 for IP addresses.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>Hardware Size</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This 1-byte field contains the hardware address size, which is 6 for Ethernet addresses.</p></td>
</tr>
</tbody>
</table>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/arp-packet-format.PNG" alt="Diagram of the  ARP Packet Format.">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 6. ARP Packet Format</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Request/Response&nbsp;Field</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>Protocol Size</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This 1-byte field contains the IP address size, which is 4 for IP addresses.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>Operation Code</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This 2-byte field contains the operation for this ARP packet. An ARP request is specified with the value of 0x0001, while an ARP response is represented by a value of 0x0002.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>Sender Ethernet Address</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This 6-byte field contains the sender&#8217;s Ethernet address.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>Sender IP Address</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This 4-byte field contains the sender&#8217;s IP address.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>Target Ethernet Address</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This 6-byte field contains the target&#8217;s Ethernet address.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><em>Target IP Address</em></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This 4-byte field contains the target&#8217;s IP address.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>ARP requests and responses are Ethernet-level packets. All other TCP/IP packets are encapsulated by an IP packet header.</em>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>All ARP messages in the TCP/IP implementation are expected to be in <strong>big endian</strong> format. In this format, the most significant byte of the word resides at the lowest byte address.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_arp_aging">ARP Aging</h3>
<div class="paragraph">
<p>NetX Duo supports automatic dynamic ARP entry invalidation. <strong><em>NX_ARP_EXPIRATION_RATE</em></strong> specifies the number of seconds an established IP address to physical mapping stays valid. After expiration, the ARP entry is removed from the ARP cache. The next attempt to send to the corresponding IP address will result in a new ARP request. Setting <strong><em>NX_ARP_EXPIRATION_RATE</em></strong> to zero disables ARP aging, which is the default configuration.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arp_defend">ARP Defend</h3>
<div class="paragraph">
<p>When an ARP request or ARP response packet is received and the sender has the same IP address, which conflicts with the IP address of this node, NetX Duo sends an ARP request for that address as a defense. If the conflict ARP packet is received more than once in 10 seconds, NetX Duo does not send more defend packets. The default interval 10 seconds can be redefined by <strong><em>NX_ARP_DEFEND_INTERVAL</em></strong>. This behavior follows the policy specified in 2.4(c) of RFC5227. Since Windows XP ignores ARP announcement as a response for its ARP probe, user can define <strong><em>NX_ARP_DEFEND_BY_REPLY</em></strong> to send ARP response as additional defense.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arp_statistics_and_errors">ARP Statistics and Errors</h3>
<div class="paragraph">
<p>If enabled, the NetX Duo ARP software keeps track of several statistics and errors that may be useful to the application. The following statistics and error reports are maintained for each IP&#8217;s ARP processing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Total ARP Requests Sent</p>
</li>
<li>
<p>Total ARP Requests Received</p>
</li>
<li>
<p>Total ARP Responses Sent</p>
</li>
<li>
<p>Total ARP Responses Received</p>
</li>
<li>
<p>Total ARP Dynamic Entries</p>
</li>
<li>
<p>Total ARP Static Entries</p>
</li>
<li>
<p>Total ARP Aged Entries</p>
</li>
<li>
<p>Total ARP Invalid Messages</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All these statistics and error reports are available to the application with the <strong><em>nx_arp_info_get</em></strong> service.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reverse_address_resolution_protocol_rarp_in_ipv4">Reverse Address Resolution Protocol (RARP) in IPv4</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Reverse Address Resolution Protocol (RARP) is the protocol for requesting network assignment of the host&#8217;s 32-bit IP addresses (RFC 903). This is done through an RARP request and continues periodically until a network member assigns an IP address to the host network interface in an RARP response. The application creates an IP instance by the service <strong><em>nx_ip_create</em></strong> with a zero IP address. If RARP is enabled by the application, it can use the RARP protocol to request an IP address from the network server accessible through the interface that has a zero IP address.</p>
</div>
<div class="sect2">
<h3 id="_rarp_enable">RARP Enable</h3>
<div class="paragraph">
<p>To use RARP, the application must create the IP instance with an IP address of zero, then enable RARP using the service <strong><em>nx_rarp_enable</em></strong>. For multihome systems, at least one network device associated with the IP instance must have an IP address of zero. The RARP processing periodically sends RARP request messages for the NetX Duo system requiring an IP address until a valid RARP reply with the network designated IP address is received. At this point, RARP processing is complete.</p>
</div>
<div class="paragraph">
<p>After RARP has been enabled, it is disabled automatically after all interface addresses are resolved. The application may force RARP to terminate by using the service <strong><em>nx_rarp_disable</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rarp_request">RARP Request</h3>
<div class="paragraph">
<p>The format of an RARP request packet is almost identical to the ARP packet shown in <a href="#arp-messages">Figure 6</a>.The only difference is the frame type field is 0x8035 and the <em>Operation Code</em> field is 3, designating an RARP request. As mentioned previously, RARP requests will be sent periodically (every <strong><em>NX_RARP_UPDATE_RATE</em></strong> seconds) until a RARP reply with the network assigned IP address is received.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>All RARP messages in the TCP/IP implementation are expected to be in <strong>big endian</strong> format. In this format, the most significant byte of the word resides at the lowest byte address.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_rarp_reply">RARP Reply</h3>
<div class="paragraph">
<p>RARP reply messages are received from the network and contain the network assigned IP address for this host. The format of an RARP reply packet is almost identical to the ARP packet shown in Figure 6. The only difference is the frame type field is 0x8035 and the <em>Operation Code</em> field is 4, which designates an RARP reply. After received, the IP address is setup in the IP instance, the periodic RARP request is disabled, and the IP instance is now ready for normal network operation.</p>
</div>
<div class="paragraph">
<p>For multihome hosts, the IP address is applied to the requesting network interface. If there are other network interfaces still requesting an IP address assignment, the periodic RARP service continues until all interface IP address requests are resolved.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>The application should not use the IP instance until the RARP processing is complete. The <strong>nx_ip_status_check</strong> may be used by applications to wait for the RARP completion. For multihome systems, the application should not use the requesting interface until the RARP processing is complete on that interface. Status of the IP address on the secondary device can be checked with the <strong>nx_ip_interface_status_check</strong> service.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_rarp_statistics_and_errors">RARP Statistics and Errors</h3>
<div class="paragraph">
<p>If enabled, the NetX Duo RARP software keeps track of several statistics and errors that may be useful to the application. The following statistics and error reports are maintained for each IP&#8217;s RARP processing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Total RARP Requests Sent</p>
</li>
<li>
<p>Total RARP Responses Received</p>
</li>
<li>
<p>Total RARP Invalid Messages</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All these statistics and error reports are available to the application with the <strong><em>nx_rarp_info_get</em></strong> service.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_internet_control_message_protocol_icmp">Internet Control Message Protocol (ICMP)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Internet Control Message Protocol for IPv4 (ICMP) is limited to passing error and control information between IP network members. Internet Control Message Protocol for IPv6 (ICMPv6) also handles error
and control information and is required for address resolution protocols such as Duplicate Address Detection (DAD) and stateless address autoconfiguration.</p>
</div>
<div class="paragraph">
<p>Like most other application layer (e.g., TCP/IP) messages, ICMP and ICMPv6 messages are encapsulated by an IP header with the ICMP (or ICMPv6) protocol designation.</p>
</div>
<div class="sect2">
<h3 id="_icmp_statistics_and_errors">ICMP Statistics and Errors</h3>
<div class="paragraph">
<p>If enabled, NetX Duo keeps track of several ICMP statistics and errors that may be useful to the application. The following statistics and error reports are maintained for each IP&#8217;s ICMP processing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Total ICMP Pings Sent</p>
</li>
<li>
<p>Total ICMP Ping Timeouts</p>
</li>
<li>
<p>Total ICMP Ping Threads Suspended</p>
</li>
<li>
<p>Total ICMP Ping Responses Received</p>
</li>
<li>
<p>Total ICMP Checksum Errors</p>
</li>
<li>
<p>Total ICMP Unhandled Messages</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All these statistics and error reports are available to the application with the <strong><em>nx_icmp_info_get</em></strong> service.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_icmpv4_services_in_netx_duo">ICMPv4 Services in NetX Duo</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_icmpv4_enable">ICMPv4 Enable</h3>
<div class="paragraph">
<p>Before ICMPv4 messages can be processed by NetX Duo, the application must call the <strong><em>nx_icmp_enable</em></strong> service to enable ICMPv4 processing. After this is done, the application can issue ping requests and field incoming ping packets.</p>
</div>
</div>
<div class="sect2">
<h3 id="_icmpv4_echo_request">ICMPv4 Echo Request</h3>
<div class="paragraph">
<p>An echo request is one type of ICMPv4 message that is typically used to check for the existence of a specific node on the network, as identified by its host IP address. The popular ping command is implemented using ICMP echo request/echo reply messages. If the specific host is present, its network stack processes the ping request and responses with a ping response. Figure 7 details the ICMPv4 ping message format.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/icmpv4-ping-message.png" alt="ICMPv4 Ping Message">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 7. ICMPv4 Ping Message</strong></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>All ICMPv4 messages in the TCP/IP implementation are expected to be in <strong>big endian</strong> format. In this format, the most significant byte of the word resides at the lowest byte address.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following describes the ICMPv4 header format:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Header Field</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Type</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field specifies the ICMPv4 message (bits 31-24). The most common are:<br>
-  0: Echo Reply<br>
- 3: Destination Unreachable<br>
- 8: Echo Request<br>
- 11: Time Exceeded<br>
- 12: Parameter Problem</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Code</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field is context specific on the type field (bits 23-16). For an echo request or reply the code is set to zero.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Checksum</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the 16-bit checksum of the one&#8217;s complement sum of the ICMPv4 message including the entire the ICMPv4 header starting with the Type field. Before generating the checksum, the checksum field is cleared.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Identification</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains an ID value identifying the host; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Sequence number</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains an ID value; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16). Unlike the identifier field, this value will change in a subsequent Echo request from the same host (bits 15-0).</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_icmpv4_echo_response">ICMPv4 Echo Response</h3>
<div class="paragraph">
<p>A ping response is another type of ICMP message that is generated internally by the ICMP component in response to an external ping request. In addition to acknowledgement, the ping response also contains a copy of the user data supplied in the ping request.</p>
</div>
</div>
<div class="sect2">
<h3 id="_icmpv4_error_messages">ICMPv4 Error Messages</h3>
<div class="paragraph">
<p>The following ICMPv4 error messages are supported in NetX Duo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Destination Unreachable</p>
</li>
<li>
<p>Time Exceed</p>
</li>
<li>
<p>Parameter Problem</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_internet_group_management_protocol_igmp">Internet Group Management Protocol (IGMP)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Internet Group Management Protocol (IGMP) provides a device to communicate with its neighbors and its routers that it intends to receive, or join, an IPv4 multicast group (RFC 1112 and RFC 2236). A multicast group is basically a dynamic collection of network members and is represented by a Class D IP address. Members of the multicast group may leave at any time, and new members may join at any time. The coordination involved in joining and leaving the group is the responsibility of IGMP.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>IGMP is designed only for IPv4 multicast groups. It cannot be used on the IPv6 network.</em>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_igmp_enable">IGMP Enable</h3>
<div class="paragraph">
<p>Before any multicasting activity can take place in NetX Duo, the application must call the <strong><em>nx_igmp_enable</em></strong> service. This service performs basic IGMP initialization in preparation for multicast requests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multicast_ipv4_addressing">Multicast IPv4 Addressing</h3>
<div class="paragraph">
<p>As mentioned previously, multicast addresses are actually Class D IP addresses as shown in <a href="#ipv4-addresses">Figure 4</a>. The lower 28-bits of the Class D address correspond to the multicast group ID. There are a series of pre-defined multicast addresses; however, the <em>all hosts address</em> (244.0.0.1) is particularly important to IGMP processing. The <em>all hosts address</em> is used by routers to query all multicast members to report on which multicast groups they belong to.</p>
</div>
</div>
<div class="sect2">
<h3 id="_physical_address_mapping_in_ipv4">Physical Address Mapping in IPv4</h3>
<div class="paragraph">
<p>Class D multicast addresses map directly to physical Ethernet addresses ranging from 01.00.5e.00.00.00 through 01.00.5e.7f.ff.ff. The lower 23 bits of the IP multicast address map directly to the lower 23 bits of the Ethernet address.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multicast_group_join">Multicast Group Join</h3>
<div class="paragraph">
<p>Applications that need to join a particular multicast group may do so by calling the <strong><em>nx_igmp_multicast_join</em></strong> service. This service keeps track of the number of requests to join this multicast group. If this is the first application request to join the multicast group, an IGMP report is sent out on the primary network indicating this host&#8217;s intention to join the group. Next, the
network driver is called to set up for listening for packets with the Ethernet address for this multicast group.</p>
</div>
<div class="paragraph">
<p>In a multihome system, if the multicast group is accessible via a specific interface, application shall use the service <strong><em>nx_igmp_multicast_interface_join</em></strong> instead of <strong><em>nx_igmp_multicast_join</em></strong>, which is limited to multicast groups on the primary network.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multicast_group_leave">Multicast Group Leave</h3>
<div class="paragraph">
<p>Applications that need to leave a previously joined multicast group may do so by calling the <strong><em>nx_igmp_multicast_leave</em></strong> service. This service reduces the internal count associated with how many times the group was joined. If there are no outstanding join requests for a group, the network driver is called to disable listening for packets with this multicast group&#8217;s Ethernet address.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multicast_loopback">Multicast Loopback</h3>
<div class="paragraph">
<p>An application may wish to receive multicast traffic originated from one of the sources on the same node. This requires the IP multicast component to have loopback enabled by using the service <strong><em>nx_igmp_loopback_enable</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_igmp_report_message">IGMP Report Message</h3>
<div class="paragraph">
<p>When the application joins a multicast group, an IGMP report message is sent via the network to indicate the host&#8217;s intention to join a particular multicast group. The format of the IGMP report message is shown in Figure 8. The multicast group address is used for both the group message in the IGMP report message and the destination IP address.</p>
</div>
<div class="paragraph">
<p>In the figure above (Figure 8), the IGMP header contains a version/type field, maximum response</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/image17.jpg" alt="Diagram of a IGMP report message.">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 8. IGMP Report Message</strong></p>
</div>
<div class="paragraph">
<p>time, a checksum field, and a multicast group address field. For IGMPv1 messages, the Maximum Response Time field is always set to zero, as this is not part of the IGMPv1 protocol. The Maximum Response Time field is set when the host receives a Query type IGMP message and cleared when a host receives another host&#8217;s Report type message as defined by the IGMPv2 protocol.</p>
</div>
<div class="paragraph">
<p>The following describes the IGMP header format:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Header Field</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Version</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field specifies the IGMP version (bits 31- 28).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Type</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field specifies the type of IGMP message (bits 27 -24).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Maximum Response Time</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not used in IGMP v1. In IGMP v2 this field serves as the maximum response time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Checksum</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the 16-bit checksum of the one&#8217;s complement sum of the IGMP message starting with the IGMP version (bits 0-15)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Group Address</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32-bit class D group IP address</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>IGMP report messages are also sent in response to IGMP query messages sent by a multicast router. Multicast routers periodically send query messages out to see which hosts still require group membership. Query messages have the same format as the IGMP Report message shown in Figure 8. The only differences are the IGMP type is equal to 1 and the group address field is set to 0. IGMP Query messages are sent to the <em>all hosts</em> IP address by the multicast router. A host that still wishes to maintain group membership responds by sending another IGMP Report message.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>All messages in the TCP/IP implementation are expected to be in <strong>big endian</strong> format. In this format, the most significant byte of the word resides at the lowest byte address.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_igmp_statistics_and_errors">IGMP Statistics and Errors</h3>
<div class="paragraph">
<p>If enabled, the NetX Duo IGMP software keeps track of several statistics and errors that may be useful to the application. The following statistics and error reports are maintained for each IP&#8217;s IGMP processing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Total IGMP Reports Sent</p>
</li>
<li>
<p>Total IGMP Queries Received</p>
</li>
<li>
<p>Total IGMP Checksum Errors</p>
</li>
<li>
<p>Total IGMP Current Groups Joined</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All these statistics and error reports are available to the application with the <strong><em>nx_igmp_info_get</em></strong>service.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multicast_without_igmp">Multicast without IGMP</h3>
<div class="paragraph">
<p>Application expecting IPv4 multicast traffic can join a multicast group address without invoking IGMP messages by using the service <strong><em>nx_ipv4_multicast_interface_join</em></strong>. This service instructs the IPv4 layer and the underlying interface driver to accept packets from the designated IPv4 multicast address. However there is no IGMP group management messages being sent or processed for this group.</p>
</div>
<div class="paragraph">
<p>Application no longer wish to receive traffic from the group can use the service <strong><em>nx_ipv4_multicast_interface_leave.</em></strong></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ipv6_in_netx_duo">IPv6 in NetX Duo</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_ipv6_addresses">IPv6 Addresses</h3>
<div class="paragraph">
<p>IPv6 addresses are 128 bits. The architecture of IPv6 address is described in RFC 4291. The address is divided into a prefix containing the most significant bits and a host address containing the lower bits. The prefix indicates the type of address and is roughly the equivalent of the network address in IPv4 network.</p>
</div>
<div class="paragraph">
<p>IPv6 has three types of address specifications: unicast, anycast (not supported in NetX Duo), and multicast. Unicast addresses are those IP addresses that identify a specific host on the Internet. Unicast addresses can be either a source or a destination IP address. Multicast addresses specify a dynamic group of hosts on the Internet. Members of the multicast group may join and leave whenever they wish.</p>
</div>
<div class="paragraph">
<p>IPv6 does not have the equivalent of the IPv4 broadcast mechanism. The ability to send a packet to all hosts can be achieved by sending a packet to the link-local all hosts multicast group.</p>
</div>
<div class="paragraph">
<p>IPv6 utilizes multicast addresses to perform Neighbor Discovery, Router Discovery, and Stateless Address Auto Configuration procedures.</p>
</div>
<div class="paragraph">
<p>There are two types of IPv6 unicast addresses: link local addresses, typically constructed by combining the well-known link local prefix with the interface MAC address, and global IP addresses, which also has the prefix portion and the host ID portion. A global address may be configured manually, or through the Stateless Address Autoconfiguration or DHCPv6. NetX Duo supports both link local address and global address.</p>
</div>
<div class="paragraph">
<p>To accommodate both IPv4 and IPv6 formats, NetX Duo provides a new data type, NXD_ADDRESS, for holding IPv4 and IPv6 addresses. The definition of this structure is shown below. The address field is a union of IPv4 and IPv6 addresses.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">typedef struct NXD_ADDRESS_STRUCT
{
    ULONG nxd_ip_version;
    union
    {
        ULONG v4;
        ULONG v6[4];
    } nxd_ip_address;
} NXD_ADDRESS;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the NXD_ADDRESS structure, the first element, <em>nxd_ip_version</em>, indicates IPv4 or IPv6 version. Supported values are either NX_IP_VERSION_V4 or NX_IP_VERSION_V6. <em>nxd_ip_version</em> indicates which field in the <em>nxd_ip_address</em> union to use as the IP address. NetX Duo API services typically take a pointer to NXD_ADDRESS structure as input argument in lieu of the ULONG (32 bit) IP address.</p>
</div>
</div>
<div class="sect2">
<h3 id="_link_local_addresses">Link Local Addresses</h3>
<div class="paragraph">
<p>A link-local address is only valid on the local network. A device can send and receive packets to another device on the same network after a valid link local address is assigned to it. An application assigns a link-local address by calling the NetX Duo service <strong><em>nxd_ipv6_address_set</em></strong>, with the prefix length parameter set to 10. The application may supply a link-local address to the service, or it may simply use NX_NULL as the link-local address and allow NetX Duo to construct a link-local address based on the device&#8217;s MAC address.</p>
</div>
<div class="paragraph">
<p>The following example instructs NetX Duo to configure the link-local address with a prefix length of 10 on the primary device (index 0) using its MAC address:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">nxd_ipv6_address_set(ip_ptr, 0, NX_NULL, 10, NX_NULL);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, if the MAC address of the interface is 54:32:10:1A:BC:67, the corresponding link-local address would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FE80::5632:10FF:FE1A:BC67</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the host ID portion of the IPv6 address (<strong>5632:10FF:FE1A:BC67</strong>) is made up of the 6-byte MAC address, with the following modifications:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>0xFFFE</strong> inserted between byte 3 and byte 4 of the MAC address</p>
</li>
<li>
<p>Second lowest bit of the first byte of the MAC address (U/L bit) is set to 1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Refer to RFC 2464 (Transmission of IPv6 Packets over Ethernet Network) for more information on how to construct the host portion of an IPv6 address from its interface MAC address.</p>
</div>
<div class="paragraph">
<p>There are a few special multicast addresses for sending multicast messages to one or more hosts in IPv6:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Group</th>
<th class="tableblock halign-left valign-top">Address</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">All nodes group</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>FF02::1</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All hosts on the local network</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">All routers group</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>FF02::2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All routers on the local network</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Solicited-node</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>FF02::1:FF00:0/104</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Explained below</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A solicited-node multicast address targets specific hosts on the local link rather than all the IPv6 hosts. It consists of the prefix <strong>FF02::1:FF00:0/104</strong>, which is 104 bits and the last 24-bits of the target IPv6 address. For example, an IPv6 address <strong>205B:209D:D028::F058:D1C8:1024</strong> has a solicited-node multicast address of address <strong>FF02::1:FFC8:1024</strong>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>The double colon notation indicates the intervening bits are all zeroes. <strong>FF02::1:FF00:0/104</strong> fully expanded looks like</em> <strong>FF02:0000:0000:0000:0000:0001:FF00:0000</strong>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_global_addresses">Global Addresses</h3>
<div class="paragraph">
<p>An example of an IPv6 global address is <strong>2001:0123:4567:89AB:CDEF::1</strong> NetX Duo stores IPv6 addresses in the NXD_ADDRESS structure. In the example below, the NXD_ADDRESS variable <strong>global_ipv6_address</strong> contains a unicast IPv6 address. The following example demonstrates a NetX Duo device creating a specific IPv6 global address for its primary device:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NXD_ADDRESS global_ipv6_address;
UINT        primary_interface_index = 0;

global_ipv6_address.nxd_ip_version = NX_IP_VERSION_V6;
global_ipv6_address.nxd_ip_address.v6[0] = 0x20010123;
global_ipv6_address.nxd_ip_address.v6[1] = 0x456789AB;
global_ipv6_address.nxd_ip_address.v6[2] = 0xCDEF0000;
global_ipv6_address.nxd_ip_address.v6[3] = 0x00000001;

status = nxd_ipv6_address_set(
            &amp;ip_0,
            primary_interface_index,
            &amp;global_ipv6_address,
            64,
            NX_NULL);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the prefix of this IPv6 address is <strong>2001:0123:4567:89AB</strong>, which is 64 bits long and is a common prefix length for global unicast IPv6 addresses on Ethernet.</p>
</div>
<div class="paragraph">
<p>The NXD_ADDRESS structure also holds IPv4 addresses. An IP address of <strong>192.1.168.10</strong> (<strong>0xC001A80A</strong>) stored in global_ipv4_address would have the following memory layout:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Field</th>
<th class="tableblock halign-left valign-top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">global_ipv4_address.nxd_ip_version</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NX_IP_VERSION_V4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">global_ipv4_address.nxd_ip_address.v4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xC001A80A</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When an application passes an address to NetX Duo services, the <em>nxd_ip_version</em> field must specify the correct IP version for proper packet handling.</p>
</div>
<div class="paragraph">
<p>To be backward compatible with existing NetX applications, NetX Duo supports all NetX services. Internally, NetX Duo converts the IPv4 address type ULONG to an NXD_ADDRESS data type before forwarding it to the actual NetX Duo service.</p>
</div>
<div class="paragraph">
<p>The following example illustrates the similarity and the differences between services in NetX and NetX Duo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Make a connection to the destination IPv4 address
   192.1.168.12 through an already created TCP socket bound
   to the well known HTTP port number 80. */

global_ipv4_address.nxd_ip_version = NX_IP_VERSION_V4;
global_ipv4_address.nxd_ip_address.v4 = 0xC001A80C;

nxd_tcp_client_socket_connect(&amp;tcp_socket,
                              &amp;global_ipv4_address,
                              port_number,
                              NX_WAIT_FOREVER);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the equivalent NetX API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">ULONG         server_ip = 0xC001A80C;
NX_TCP_SOCKET tcp_socket;
UINT          port_number = 80;

nx_tcp_client_socket_connect(&amp;tcp_socket,
                             server_ip,
                             port_number,
                             NX_WAIT_FOREVER);</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>Application developers are encouraged to use the nxd version of these APIs</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_ipv6_default_routers">IPv6 Default Routers</h3>
<div class="paragraph">
<p>IPv6 uses a default router to forward packets to offlink destinations. The NetX Duo service <strong><em>nxd_ipv6_default_router_add</em></strong>enables an application to add an IPv6 router to the default router table. See Chapter 4 "Description of Services" for more default router services offered by NetX Duo.</p>
</div>
<div class="paragraph">
<p>When forwarding IPv6 packets, NetX Duo first checks if the packet destination is on-link. If not, NetX Duo checks the default routing table for a valid router to forward the off-link packet to.</p>
</div>
<div class="paragraph">
<p>To remove a router from the IPv6 default router table, application shall use the service <strong><em>nxd_ipv6_default_router_delete</em></strong>. To obtain entries of the IPv6 default router table, use the service <strong><em>nxd_ipv6_default_router_entry_get</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ipv6_header">IPv6 Header</h3>
<div class="paragraph">
<p>The IPv6 header has been modified from the IPv4 header. When allocating a packet, the caller specifies the application protocol (e.g., UDP, TCP), buffer size in bytes, and hop limit.</p>
</div>
<div class="paragraph">
<p>Figure 9 shows the format of the IPv6 header and the table lists the header components.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/image18.png" alt="Diagram of the IPv6 header format.">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 9. IPv6 Header Format</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">IP header</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Version</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4-bit field for IP version. For IPv6 networks, the value in this field must be 6; For IPv4 networks it must be 4.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Traffic Class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8-bit field that stores the traffic class information. This field is not used by NetX Duo.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Flow Label</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20-bit field to uniquely identify the flow, if any, that a packet is associated with. A value of zero indicates the packet does not belong to a particular flow. This field replaces the <em>TOS</em>field in IPv4.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Payload Length</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16-bit field indicating the amount of data in bytes of the IPv6 packet following the IPv6 base header. This includes all encapsulated protocol header and data.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Next Header</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8-bit field indicating the type of the extension header that follows the IPv6 base header. This field replaces the <em>Protocol</em>field in IPv4.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hop Limit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8-bit field that limits the number of routers the packet is allowed to go through. This field replaces the <em>TTL</em>field in IPv4.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Source Address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128-bit field that stores the IPv6 address of the sender.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Destination Address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128-bit field that sores the IPv6 address of the destination.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_enabling_ipv6_in_netx_duo">Enabling IPv6 in NetX Duo</h3>
<div class="paragraph">
<p>By default IPv6 is enabled in NetX Duo. IPv6 services are enabled in NetX Duo if the configurable option <strong><em>NX_DISABLE_IPV6</em></strong> in <em>nx_user.h</em> is not defined. If <strong><em>NX_DISABLE_IPV6</em></strong> is defined, NetX Duo will only offer IPv4 services, and all the IPv6-related modules and services are not built into NetX Duo library.</p>
</div>
<div class="paragraph">
<p>The following service is provided for applications to configure the device IPv6 address: <strong><em>nxd_ipv6_address_set</em></strong></p>
</div>
<div class="paragraph">
<p>In addition to manually setting the device&#8217;s IPv6 addresses, the system may also use Stateless Address Autoconfiguration. To use this option, the application must call <strong><em>nxd_ipv6_enable</em></strong> to start IPv6 services on the device. In addition, ICMPv6 services must be started by calling <strong><em>nxd_icmp_enable</em></strong>, which enables NetX Duo to perform services such as Router Solicitation, Neighbor Discovery, and Duplicate Address Detection. Note that <strong><em>nx_icmp_enable</em></strong> only starts ICMP for IPv4 services. <strong><em>nxd_icmp_enable</em></strong> starts ICMP services for both IPv4 and IPv6. If the system does not need ICMPv6 services, then <strong><em>nx_icmp_enable</em></strong> can be used so the ICMPv6 module is not linked into the system.</p>
</div>
<div class="paragraph">
<p>The following example shows a typical NetX Duo IPv6 initialization procedure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Assume ip_0 has been created and IPv4 services (such as ARP,
   ICMP, have been enabled. */
#define SECONDARY_INTERFACE 1

/* Enable IPv6 */
status = nxd_ipv6_enable(&amp;ip_0);

if(status != NX_SUCCESS)
{
    /* nxd_ipv6_enable failed. */
}

/* Enable ICMPv6 */
status = nxd_icmp_enable(&amp;ip_0);
if(status != NX_SUCCESS)
{
    /* nxd_icmp_enable failed. */
}

/* Configure the link local address on the primary interface. */
status = nxd_ipv6_address_set(&amp;ip_0, 0, NX_NULL, 10, NX_NULL);

/* Configure ip_0 primary interface global address. */
ip_address.nxd_ip_version = NX_IP_VERSION_V6
ip_address.nxd_ip_address.v6[0] = 0x20010db8;
ip_address.nxd_ip_address.v6[1] = 0x0000f101;
ip_address.nxd_ip_address.v6[2] = 0;
ip_address.nxd_ip_address.v6[3] = 0x202;

/* Configure global address of the primary interface. */
status = nxd_ipv6_address_set(&amp;ip_0, SECONDARY_INTERFACE,
                              &amp;ip_address, 64, NX_NULL);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Upper layer protocols (such as TCP and UDP) can be enabled either before or after IPv6 starts.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>IPv6 services are available only after IP thread is initialized and the device is enabled.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After the interface is enabled (i.e.,the interface device driver is ready to send and receive data, and a valid link local address has been obtained), the device may obtain global IPv6 addresses by one of
the these methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Stateless Address Auto Configuration;</p>
</li>
<li>
<p>Manual IPv6 address configuration;</p>
</li>
<li>
<p>Address configuration via DHCPv6 (with optional DHCPv6 package)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first two methods are described below. The 3rd method (DHCPv6) is described in the DHCP package.</p>
</div>
</div>
<div class="sect2">
<h3 id="_stateless_address_autoconfiguration_using_router_solicitation">Stateless Address Autoconfiguration Using Router Solicitation</h3>
<div class="paragraph">
<p>NetX Duo devices can configure their interfaces automatically when connected to an IPv6 network with a router that supplies prefix information. Devices that require Stateless Address Autoconfiguration send out router solicitation (RS) messages. Routers on the network respond with solicited router advertisement (RA) messages. RA messages advertise prefixes that identify the network addresses associated with a link. Devices then generate a unique identifier for the network the device is attached to. The address is formed by combining the prefix and its unique identifier. In this manner on receiving the RA messages, hosts generate their IP address. Routers may also send periodic unsolicited RA messages.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>NetX Duo allows an application to enable or disable Stateless Address Autoconfiguration at run time. To enable this feature, NetX Duo library must be compiled with <strong>NX_IPV6_STATELESS_AUTOCONFIG_CONTROL</strong> defined. Once this feature is enabled, applications may use <strong>nxd_ipv6_stateless_address_autoconfigure_enable</strong> and <strong>nxd_ipv6_stateless_address_autoconfigure_disable</strong> to enable or disable IPv6 stateless address autoconfiguration</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_manual_ipv6_address_configuration">Manual IPv6 Address Configuration</h3>
<div class="paragraph">
<p>If a specific IPv6 address is needed, the application may use <strong><em>nxd_ipv6_address_set</em></strong> to manually configure an IPv6 address. A network interface may have multiple IPv6 addresses. However keep in mind that the total number of IPv6 addresses in a system, either obtained through Stateless Address
Autoconfiguration, or through the Manual Configuration, cannot exceed <strong><em>NX_MAX_IPV6_ADDRESSES</em></strong>.</p>
</div>
<div class="paragraph">
<p>The following example illustrates how to manually configure a global address on the primary interface (device 0) in ip_0:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">NXD_ADDRESS global_address;
global_address.nxd_ip_version = NX_IP_VERSION_V6;
global_address.nxd_ip_address.v6[0] = 0x20010000;
global_address.nxd_ip_address.v6[1] = 0x00000000;
global_address.nxd_ip_address.v6[2] = 0x00000000;
global_address.nxd_ip_address.v6[3] = 0x0000ABCD;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The host then calls the following NetX Duo service to assign this address as its global IP address:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">status = nxd_ipv6_address_set(&amp;ip_0, 0,
                              &amp;global_address, 64
                              NX_NULL);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_duplicate_address_detection_dad">Duplicate Address Detection (DAD)</h3>
<div class="paragraph">
<p>After a system configures its IPv6 address, the address is marked as <em>TENTATIVE</em>. If Duplicate Address Detection (DAD), described in RFC 4862, is enabled, NetX Duo automatically sends neighbor solicitation (NS) messages with this tentative address as the destination. If no hosts on the network respond to these NS messages within a given period of time, the address is assumed to be unique on the local link, and its state transits to the VALID state. At this point the application may start using this IP address for communication.</p>
</div>
<div class="paragraph">
<p>The DAD functionality is part of the ICMPv6 module. Therefore, the application must enable ICMPv6 services before a newly configured address can go through the DAD process. Alternatively, the DAD
process may be turned off by defining <strong><em>NX_DISABLE_IPV6_DAD</em></strong> option in the NetX Duo library build environment (defined as <strong><em>nx_user.h</em></strong>). During the DAD process, the <strong><em>NX_IPV6_DAD_TRANSMITS</em></strong> parameter determines the number of NS messages sent by NetX Duo without receiving a response to determine that the address is unique. By default and recommended by RFC 4862, <strong><em>NX_IPV6_DAD_TRANSMITS</em></strong> is set at 3. Setting this symbol to zero effectively disables DAD.</p>
</div>
<div class="paragraph">
<p>If ICMPv6 or DAD is not enabled at the time the application assigns an IPv6 address, DAD is not performed and NetX Duo sets the state of the IPv6 address to VALID immediately.</p>
</div>
<div class="paragraph">
<p>NetX Duo cannot communicate on the IPv6 network until its link local and/or global address is valid. After a valid address is obtained, NetX Duo attempts to match the destination address of an incoming packet against one of its configured IPv6 address or an enabled multicast address. If no matches are found, the packet is dropped.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>During the DAD process, the number of DAD NS packets to be transmitted is defined by <strong>*NX_IPV6_DAD_TRANSMITS*</em>, which defaults to 3, and by default there is a one second delay between each DAD NS message is sent. Therefore, in a system with DAD enabled, after an IPv6 address is assigned (and assuming this is not a duplicated address), there is approximately 3 seconds delay before the IP address is in a VALID state and is ready for communication.</strong>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Applications may want to receive notifications when IPv6 addresses in the system are changed. To enable the IPv6 address change notification feature, the NetX Duo library must be built with the symbol <strong>NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY</strong> defined. Once the feature is enabled, applications may install the callback function by using the <strong><em>nxd_ipv6_address_change_notify</em></strong> service.</p>
</div>
<div class="paragraph">
<p>Once an IPv6 address is changed, or becomes invalid, the user-supplied callback function is invoked with the following information:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ip_ptr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the IP instance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">interface_index</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Index to the network interface that this IPv6 address is associated with</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ipv6_addr_index</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Index to the IPv6 address table</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ipv6_address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pointer to the IPv6 address, in the form of an array of four ULONG integers. Pv6 addresses are presented in host byte order.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_ipv6_multicast_support_in_netx_duo">IPv6 Multicast Support In NetX Duo</h3>
<div class="paragraph">
<p>Multicast addresses specify a dynamic group of hosts on the Internet. Members of the multicast group may join and leave whenever they wish. NetX Duo implements several ICMPv6 protocols, including Duplicate Address Detection, Neighbor Discovery, and Router Discovery, which require IP multicast capability. Therefore, NetX Duo expects the underlying device driver to support multicast operations.</p>
</div>
<div class="paragraph">
<p>When NetX Duo needs to join or leave a multicast group (such as the all-node multicast address, and the <em>solicited-node</em> multicast address), it issues a driver command to the device driver to join or leave a multicast MAC address. The driver command for joining the multicast address is <strong><em>NX_LINK_MULTICAST_JOIN</em></strong>. To leave a multicast address, NetX Duo issues the driver command <strong><em>NX_LINK_MULTICAST_LEAVE</em></strong>. The device driver must implement these two commands for ICMPv6 protocols to work properly.</p>
</div>
<div class="paragraph">
<p>Applications may join an IPv6 multicast group by using the service <strong><em>nxd_ipv6_multicast_interface_join</em>.</strong> This service registers the multicast address with the IP stack, and then notifies the specified device driver of the IPv6 multicast address. To leave a
multicast group, applications use the service <strong><em>nxd_ipv6_multicast_interface_leave.</em></strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_neighbor_discovery_nd">Neighbor Discovery (ND)</h3>
<div class="paragraph">
<p>Neighbor Discovery is a protocol in IPv6 networks for mapping physical addresses to the IPv6 addresses (global address or link-local address). This mapping is maintained in the Neighbor Discovery Cache (ND Cache). The ND process is the equivalent of the ARP process in IPv4, and the ND Cache is similar to the ARP table. An IPv6 node can obtain its neighbor&#8217;s MAC address using the Neighbor Discovery (ND) protocol. It sends out a neighbor solicitation (NS) message to the all-node solicited node multicast address, and waits for a corresponding neighbor advertisement (NA) message. The MAC address obtained through this process is stored in the ND Cache.</p>
</div>
<div class="paragraph">
<p>Each IP instance has one ND cache. The ND Cache is maintained as an array of entries. The size of the array is defined at compilation time by setting the option <strong><em>NX_IPV6_NEIGHBOR_CACHE_SIZE</em></strong> which in <strong><em>nx_user.h</em></strong>. Note that all interfaces attached to an IP instance share the same ND cache.</p>
</div>
<div class="paragraph">
<p>The entire ND Cache is empty when NetX Duo starts up. As the system runs, NetX Duo automatically updates the ND Cache, adding and deleting entries as per ND protocol. However, an application may also update the ND Cache by manually adding and deleting cache entries using the following NetX Duo services:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><em>nxd_nd_cache_entry_delete</em></strong></p>
</li>
<li>
<p><strong><em>nxd_nd_cache_entry_set</em></strong></p>
</li>
<li>
<p><strong><em>nxd_nd_cache_invalidate</em></strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When sending and receiving IPv6 packets, NetX Duo automatically updates the ND Cache table.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_internet_control_message_protocol_in_ipv6_icmpv6">Internet Control Message Protocol in IPv6 (ICMPv6)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The role of ICMPv6 in IPv6 has been greatly expanded to support IPv6 address mapping and router discovery. In addition, NetX Duo ICMPv6 supports echo request and response, ICMPv6 error reports, and ICMPv6 redirect messages.</p>
</div>
<div class="sect2">
<h3 id="_icmpv6_enable">ICMPv6 Enable</h3>
<div class="paragraph">
<p>Before ICMPv6 messages can be processed by NetX Duo, the application must call the <strong><em>nxd_icmp_enable</em></strong> service to enable ICMPv6 processing as explained previously.</p>
</div>
</div>
<div class="sect2">
<h3 id="_icmpv6_messages">ICMPv6 Messages</h3>
<div class="paragraph">
<p>The ICMPv6 header structure is similar to the ICMPv4 header structure. As shown below, the basic ICMPv6 header contains the three fields, type, code, and checksum, plus variable length of ICMPv6 option data.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/image19.png" alt="Diagram of a basic ICMPv6 header.">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 10. Basic ICMPv6 Header</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Field</th>
<th class="tableblock halign-left valign-top">Size(bytes)</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Identifies the ICMPv6 message type;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 Destination Unreachable</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 Packet Too Big</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 Time Exceeded</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 Parameter Problem</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128 Echo Request</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">129 Echo Reply</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">133 Router Solicitation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">134 Router Advertisement</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">135 Neighbor Solicitation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">136 Neighbor Advertisement</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">137 Redirect Message</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Code</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Further qualifies the ICMPv6 message type. Generally used with error messages. If not used, it is set to zero. Echo request/reply and NS messages do not use it.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Checksum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16-bit checksum field for the ICMP Header. This is a 16-bit complement of the entire ICMPv6 message, including the ICMPv6 header. It also includes a pseudo-header of the IPv6 source address, destination address, and packet payload length.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>An example Neighbor Solicitation header is shown below.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/image20.jpg" alt="Diagram of an example Neighbor Solicitation header.">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 11. ICMPv6 Header for a Neighbor Solicitation Message</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Field</th>
<th class="tableblock halign-left valign-top">Size(bytes)</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Identifies the ICMPv6 message type for neighbor solicitation messages. Value is 135.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Code</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not used. Set to 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Checksum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16-bit checksum field for the ICMPv6 header.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 reserved bytes set to 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Target Address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv6 address of target of the solicitation. For IPv6 address resolution, this is the actual unicast IP address of the device whose link layer address needs to be resolved.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Options</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional information specified by the Neighbor Discovery Protocol.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_icmpv6_ping_request">ICMPv6 Ping Request</h3>
<div class="paragraph">
<p>In NetX Duo applications use <strong><em>nxd_icmp_ping</em></strong> to issue either IPv6 or IPv4 ping requests, based on the destination IP address specified in the parameters.</p>
</div>
</div>
<div class="sect2">
<h3 id="_icmpv6_ping_response">ICMPv6 Ping Response</h3>
<div class="paragraph">
<p>An ICMPv6 ping response is another type of ICMPv6 message that is generated internally by the ICMPv6 component in response to an external ICMPv6 ping request. In additional to acknowledgement, the ICMPv6 ping response also contains a copy of the user data supplied in the ICMPv6 ping request.</p>
</div>
</div>
<div class="sect2">
<h3 id="_thread_suspension_3">Thread Suspension</h3>
<div class="paragraph">
<p>Application threads can suspend while attempting to ping another network member. After a ping response is received, the ping response message is given to the first thread suspended and that thread is resumed. Like all NetX Duo services, suspending on a ping request has an optional timeout.</p>
</div>
</div>
<div class="sect2">
<h3 id="_other_icmpv6_messages">Other ICMPv6 Messages</h3>
<div class="paragraph">
<p>ICMPv6 messages are required for the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Neighbor Discovery</p>
</li>
<li>
<p>Stateless Address Autoconfiguration</p>
</li>
<li>
<p>Router Discovery</p>
</li>
<li>
<p>Neighbor Unreachability Detection</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_neighbor_unreachability_router_and_prefix_discovery">Neighbor Unreachability, Router and Prefix Discovery</h3>
<div class="paragraph">
<p>Neighbor Unreachability Detection, Router Discovery, and Prefix Discovery are based on the Neighbor Discovery protocol and are described below.</p>
</div>
<div class="paragraph">
<p><strong><em>Neighbor Unreachability Detection:</em></strong> An IPv6 device searches its Neighbor Discovery (ND) Cache for the destination link layer address when it wishes to send a packet. The immediate destination, sometimes referred to as the 'next hop,' may be the actual destination on the same link or it may be a router if the destination is off link. An ND cache entry contains the status on a neighbor&#8217;s reachability.</p>
</div>
<div class="paragraph">
<p>A REACHABLE status indicates the neighbor is considered reachable. A neighbor is reachable if it has recently received confirmation that packets sent to the neighbor have been received. Confirmation in NetX Duo take the form of receiving an NA message from the neighbor in response to an NS message sent by the NetX Duo device. NetX Duo will also change the state of the neighbor status to REACHABLE if the
application calls the NetX Duo service <strong><em>nxd_nd_cache_entry_set</em></strong> to manually enter a cache record.</p>
</div>
<div class="paragraph">
<p><strong><em>Router Discovery:</em></strong> An IPv6 device uses a router to forward all packets intended for off link destinations. It may also use information sent by the router, such as router advertisement (RA) messages, to configure its global IPv6 addresses.</p>
</div>
<div class="paragraph">
<p>A device on the network may initiate the Router Discovery process by sending a router solicitation (RS) message to the all-router multicast address (FF01::2). Or it can wait on the all-node multicast address (FF::1) for a periodic RA from the routers.</p>
</div>
<div class="paragraph">
<p>An RA message contains the prefix information for configuring an IPv6 address for that network. In NetX Duo, router solicitation is by default enabled and can be disabled by setting the configuration option <strong><em>NX_DISABLE_ICMPV6_ROUTER_SOLICITATION</em></strong> in <strong><em>nx_user.h</em></strong>. See Configuration Options in the "Installation and Use of NetX Duo" chapter for more details on setting Router Solicitation parameters.</p>
</div>
<div class="paragraph">
<p><strong><em>Prefix Discovery</em></strong>: An IPv6 device uses prefix discovery to learn which target hosts are accessible directly without going through a router. This information is made available to the IPv6 device from RA messages from the router. The IPv6 device stores the prefix information in a prefix table. Prefix discovery is matching a prefix from the IPv6 device prefix table to a target address. A prefix matches a target address if all the bits in the prefix match the most significant bits of the target address. If more than one prefix covers an address, the longest prefix is selected.</p>
</div>
</div>
<div class="sect2">
<h3 id="_icmpv6_error_messages">ICMPv6 Error Messages</h3>
<div class="paragraph">
<p>The following ICMPv6 error messages are supported in NetX Duo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Destination Unreachable</p>
</li>
<li>
<p>Packet Too Big</p>
</li>
<li>
<p>Time Exceed</p>
</li>
<li>
<p>Parameter Problem</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_datagram_protocol_udp">User Datagram Protocol (UDP)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The User Datagram Protocol (UDP) provides the simplest form of data transfer between network members (RFC 768). UDP data packets are sent from one network member to another in a best effort fashion; i.e., there is no built-in mechanism for acknowledgement by the packet recipient. In addition, sending a UDP packet does not require any connection to be established in advance. Because of this, UDP packet transmission is very efficient.</p>
</div>
<div class="paragraph">
<p>For developers migrating their NetX applications to NetX Duo there are only a few basic changes in UDP functionality between NetX and NetX Duo. This is because IPv6 is primarily concerned with the underlying
IP layer. All NetX Duo UDP services can be used for either IPv4 or IPv6 connectivity.</p>
</div>
<div class="sect2">
<h3 id="_udp_header">UDP Header</h3>
<div class="paragraph">
<p>UDP places a simple packet header in front of the application&#8217;s data on transmission, and removes a
similar UDP header from the packet on reception before delivering a received UDP packet to the application. UDP utilizes the IP protocol for sending and receiving packets, which means there is an IP header in front of the UDP header when the packet is on the network. Figure 12 shows the format of the
UDP header.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/image21.png" alt="Diagram of the UDP header format.">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 12. UDP Header</strong></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>All headers in the UDP/IP implementation are expected to be in <strong>big endian</strong> format. In this format, the most significant byte of the word resides at the lowest byte address.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following describes the UDP header format:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Header Field</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>16-bit source port number</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the port on which the UDP packet is being sent from. Valid UDP ports range from 1 through 0xFFFF.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>16-bit destination port number</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the UDP port to which the packet is being sent to. Valid UDP ports range from 1 through 0xFFFF.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>16-bit UDP length</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the number of bytes in the UDP packet, including the size of the UDP header.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>16-bit UDP checksum</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the 16-bit checksum for the packet, including the UDP header, the packet data area, and the pseudo IP header.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_udp_enable">UDP Enable</h3>
<div class="paragraph">
<p>Before UDP packet transmission is possible, the application must first enable UDP by calling the <strong><em>nx_udp_enable</em></strong> service. After enabled, the application is free to send and receive UDP packets.</p>
</div>
</div>
<div class="sect2">
<h3 id="_udp_socket_create">UDP Socket Create</h3>
<div class="paragraph">
<p>UDP sockets are created either during initialization or during runtime by application threads. The initial type of service, time to live, and receive queue depth are defined by the <strong><em>nx_udp_socket_create</em></strong> service. There are no limits on the number of UDP sockets in an application.</p>
</div>
</div>
<div class="sect2">
<h3 id="_udp_checksum">UDP Checksum</h3>
<div class="paragraph">
<p>IPv6 protocol requires a UDP header checksum computation on packet data, whereas in the IPv4 protocol it is optional.</p>
</div>
<div class="paragraph">
<p>UDP specifies a one&#8217;s complement 16-bit checksum that covers the IP pseudo header (consisting of the source IP address, destination IP address, and the protocol/length IP word), the UDP header, and the UDP packet data. The only differences between IPv4 and IPv6 UDP packet header checksums is that the source and destination IP addresses are 32 bit in IPv4 while in IPv6 they are 128 bit. If the calculated UDP checksum is 0, it is stored as all ones (0xFFFF). If the sending socket has the UDP checksum logic disabled, a zero is placed in the UDP checksum field to indicate the checksum was not calculated.</p>
</div>
<div class="paragraph">
<p>If the UDP checksum does not match the computed checksum by the receiver, the UDP packet is simply discarded.</p>
</div>
<div class="paragraph">
<p>On the IPv4 network, UDP checksum is optional. NetX Duo allows an application to enable or disable UDP checksum calculation on a per-socket basis. By default, the UDP socket checksum logic is enabled. The application can disable checksum logic for a particular UDP socket by calling the <strong><em>nx_udp_socket_checksum_disable</em></strong> service. On the IPv6 network, however, UDP checksum is mandatory. Therefore, the service <strong><em>nx_udp_socket_checksum_disable</em></strong> would not disable UDP checksum logic when sending a packet through the IPv6 network.</p>
</div>
<div class="paragraph">
<p>Certain Ethernet controllers are able to generate the UDP checksum on the fly. If the system is able to use hardware checksum computation feature, the NetX Duo library can be built without the checksum logic. To disable UDP software checksum, the NetX Duo library must be built with the following symbols defined: <strong><em>NX_DISABLE_UDP_TX_CHECKSUM</em></strong> and <strong><em>NX_DISABLE_UDP_RX_CHECKSUM</em></strong> (described in Chapter two). The configuration options remove UDP checksum logic from NetX Duo entirely, while calling the <strong><em>nx_udp_socket_checksum_disable</em></strong> service allows the application to disable IPv4 UDP checksum processing on a per socket basis.</p>
</div>
</div>
<div class="sect2">
<h3 id="_udp_ports_and_binding">UDP Ports and Binding</h3>
<div class="paragraph">
<p>A UDP port is a logical end point in the UDP protocol. There are 65,535 valid ports in the UDP component of NetX Duo, ranging from 1 through 0xFFFF. To send or receive UDP data, the application must first create a UDP socket, then bind it to a desired port. After binding a UDP socket to a port, the application may send and receive data on that socket.</p>
</div>
</div>
<div class="sect2">
<h3 id="_udp_fast_path">UDP Fast Path</h3>
<div class="paragraph">
<p>The UDP Fast Path is the name for a low packet overhead path through the NetX Duo UDP implementation. Sending a UDP packet requires just a few function calls: <strong><em>nx_udp_socket_send</em></strong>, <strong><em>nx_ip_packet_send</em></strong>, and the eventual call to the network driver. <strong><em>nx_udp_socket_send</em></strong> is available in NetX Duo for existing NetX applications and is only applicable for IPv4 packets. The preferred method, however, is to use <strong><em>nxd_udp_socket_send</em></strong> service discussed below. On UDP packet reception, the UDP packet is either placed on the appropriate UDP socket receive queue or delivered to a suspended application thread in a single function call from the network driver&#8217;s receive interrupt processing. This highly optimized logic for sending and receiving UDP packets is the essence of UDP Fast Path technology.</p>
</div>
</div>
<div class="sect2">
<h3 id="_udp_packet_send">UDP Packet Send</h3>
<div class="paragraph">
<p>Sending UDP data over IPv6 or IPv4 networks is easily accomplished by calling the <strong><em>nxd_udp_socket_send</em></strong> function. The caller must set the IP version in the <em>nx_ip_version</em> field of the NXD_ADDRESS pointer parameter. NetX Duo will determine the best source address for transmitted UDP packets based on the destination IPv4/IPv6 address. This service places a UDP header in front of the packet data and sends it out onto the network using an internal IP send routine. There is no thread suspension on sending UDP packets because all UDP packet transmissions are processed immediately.</p>
</div>
<div class="paragraph">
<p>For multicast or broadcast destinations, the application should specify the source IP address to use if the NetX Duo device has multiple IP addresses to choose from. This can be done with the services <strong><em>nxd_udp_socket_source_send.</em></strong></p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If <strong>nx_udp_socket_send</strong> is used for transmitting multicast or broadcast packets, the IP address of the first enabled interface is used as source address</em>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>If UDP checksum logic is enabled for this socket, the checksum operation is performed in the context of the calling thread, without blocking access to the UDP or IP data structures</em>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>The UDP payload data residing in the NX_PACKET structure should reside on a long-word boundary. The application needs to leave sufficient space between the prepend pointer and the data start pointer for NetX Duo to place the UDP, IP, and physical media headers</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_udp_packet_receive">UDP Packet Receive</h3>
<div class="paragraph">
<p>Application threads may receive UDP packets from a particular socket by calling <strong><em>nx_udp_socket_receive</em></strong>. The socket receive function delivers the oldest packet on the socket&#8217;s receive queue. If there are no packets on the receive queue, the calling thread can suspend (with an optional timeout) until a packet arrives.</p>
</div>
<div class="paragraph">
<p>The UDP receive packet processing (usually called from the network driver&#8217;s receive interrupt handler) is responsible for either placing the packet on the UDP socket&#8217;s receive queue or delivering it to the first suspended thread waiting for a packet. If the packet is queued, the receive processing also checks the maximum receive queue depth associated with the socket. If this newly queued packet exceeds the queue depth, the oldest packet in the queue is discarded.</p>
</div>
</div>
<div class="sect2">
<h3 id="_udp_receive_notify">UDP Receive Notify</h3>
<div class="paragraph">
<p>If the application thread needs to process received data from more than one socket, the <strong><em>nx_udp_socket_receive_notify</em></strong> function should be used. This function registers a receive packet callback function for the socket. Whenever a packet is received on the socket, the callback function is executed.</p>
</div>
<div class="paragraph">
<p>The contents of the callback function is application specific; however, it would most likely contain logic to inform the processing thread that a packet is now available on the corresponding socket.</p>
</div>
</div>
<div class="sect2">
<h3 id="_peer_address_and_port">Peer Address and Port</h3>
<div class="paragraph">
<p>On receiving a UDP packet, application may find the sender&#8217;s IP address and port number by using the service <strong><em>nx_udp_packet_info_extract</em></strong>. On successful return, this service provides information on the sender&#8217;s IP address, sender&#8217;s port number, and the local interface through which the packet was received.</p>
</div>
</div>
<div class="sect2">
<h3 id="_thread_suspension_4">Thread Suspension</h3>
<div class="paragraph">
<p>As mentioned previously, application threads can suspend while attempting to receive a UDP packet on a particular UDP port. After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed. An optional timeout is available when suspending on a UDP receive packet, a feature available for most NetX Duo services.</p>
</div>
</div>
<div class="sect2">
<h3 id="_udp_socket_statistics_and_errors">UDP Socket Statistics and Errors</h3>
<div class="paragraph">
<p>If enabled, the NetX Duo UDP socket software keeps track of several statistics and errors that may be useful to the application. The following statistics and error reports are maintained for each IP/UDP instance:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Total UDP Packets Sent</p>
</li>
<li>
<p>Total UDP Bytes Sent</p>
</li>
<li>
<p>Total UDP Packets Received</p>
</li>
<li>
<p>Total UDP Bytes Received</p>
</li>
<li>
<p>Total UDP Invalid Packets</p>
</li>
<li>
<p>Total UDP Receive Packets Dropped</p>
</li>
<li>
<p>Total UDP Receive Checksum Errors</p>
</li>
<li>
<p>UDP Socket Packets Sent</p>
</li>
<li>
<p>UDP Socket Bytes Sent</p>
</li>
<li>
<p>UDP Socket Packets Received</p>
</li>
<li>
<p>UDP Socket Bytes Received</p>
</li>
<li>
<p>UDP Socket Packets Queued</p>
</li>
<li>
<p>UDP Socket Receive Packets Dropped</p>
</li>
<li>
<p>UDP Socket Checksum Errors</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All these statistics and error reports are available to the application with the <strong><em>nx_udp_info_get</em></strong> service for UDP statistics amassed over all UDP sockets, and the <strong><em>nx_udp_socket_info_get</em></strong> service for UDP statistics on the specified UDP socket.</p>
</div>
</div>
<div class="sect2">
<h3 id="_udp_socket_control_block_nx_udp_socket">UDP Socket Control Block NX_UDP_SOCKET</h3>
<div class="paragraph">
<p>The characteristics of each UDP socket are found in the associated NX_UDP_SOCKET control block. It contains useful information such as the link to the IP data structure, the network interface for the sending and receiving paths, the bound port, and the receive packet queue. This structure is defined in the <strong><em>nx_api.h</em></strong> file.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_transmission_control_protocol_tcp">Transmission Control Protocol (TCP)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Transmission Control Protocol (TCP) provides reliable stream data transfer between two network members (RFC 793). All data sent from one network member are verified and acknowledged by the receiving member. In addition, the two members must have established a connection prior to any data transfer. All this results in reliable data transfer; however, it does require substantially more overhead than the
previously described UDP data transfer.</p>
</div>
<div class="paragraph">
<p>Except where noted, there are no changes in TCP protocol API services between NetX and NetX Duo because IPv6 is primarily concerned with the underlying IP layer. All NetX Duo TCP services can be used for either IPv4 or IPv6 connections.</p>
</div>
<div class="sect2">
<h3 id="_tcp_header">TCP Header</h3>
<div class="paragraph">
<p>On transmission, TCP header is placed in front of the data from the user. On reception, TCP header is removed from the incoming packet, leaving only the user data available to the application. TCP utilizes the IP protocol to send and receive packets, which means there is an IP header in front of the TCP header when the packet is on the network. Figure 13 shows the format of the TCP header.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/image22.png" alt="Diagram of the TCP header format.">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 13. TCP Header</strong></p>
</div>
<div class="paragraph">
<p>The following describes the TCP header format:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Header&nbsp;Field</th>
<th class="tableblock halign-left valign-top">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>16-bit source port number</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the port the TCP packet is being sent out on. Valid TCP ports range from 1 through 0xFFFF.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>16-bit destination port</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the TCP port the packet is being sent to. Valid TCP ports range from 1 through 0xFFFF.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>32-bit sequence number</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the sequence number for data sent from this end of the connection. The original sequence is established during the initial connection sequence between two TCP nodes. Every data transfer from that point results in an increment of the sequence number by the amount bytes sent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>32-bit acknowledgement number</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the sequence number corresponding to the last byte received by this side of the connection. This is used to determine whether or not data previously sent has successfully been received by the other end of the connection.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>4-bit header length</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the number of 32-bit words in the TCP header. If no options are present in the TCP header, this field is 5.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>6-bit code bits</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the six different code bits used to indicate various control information associated with the connection. The control bits are defined as follows:&lt;br &gt; - URG (21): Urgent data present&lt;br &gt; - ACK (20): Acknowledgement number is valid&lt;br &gt; - PSH (19): Handle this data immediately&lt;br &gt; - RST (18): Reset the connection&lt;br &gt; - SYN (17): Synchronize sequence numbers (used to establish connection)&lt;br &gt; - FIN (16): Sender is finished with transmit (used to close connection)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>16-bit window</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field is used for flow control. It contains the amount of bytes the socket can currently receive. This basically is used for flow control. The sender is responsible for making sure the data to send will fit into the receiver&#8217;s advertised window.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>16-bit TCP checksum</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the 16-bit checksum for the packet including the TCP header, the packet data area, and the pseudo IP header.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>16-bit urgent pointer</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field contains the positive offset of the last byte of the urgent data. This field is only valid if the URG code bit is set in the header.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>All headers in the TCP/IP implementation are expected to be in <strong>big endian</strong> format. In this format, the most significant byte of the word resides at the lowest byte address</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_enable">TCP Enable</h3>
<div class="paragraph">
<p>Before TCP connections and packet transmissions are possible, the application must first enable TCP by calling the <strong><em>nx_tcp_enable</em></strong> service. After enabled, the application is free to access all TCP services.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_socket_create">TCP Socket Create</h3>
<div class="paragraph">
<p>TCP sockets are created either during initialization or during runtime by application threads. The initial type of service, time to live, and window size are defined by the <strong><em>nx_tcp_socket_create</em></strong> service. There are no limits on the number of TCP sockets in an application.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_checksum">TCP Checksum</h3>
<div class="paragraph">
<p>TCP specifies a one&#8217;s complement 16-bit checksum that covers the IP pseudo header, (consisting of the source IP address, destination IP address, and the protocol/length IP word), the TCP header, and the TCP packet data. The only difference between IPv4 and IPv6 TCP packet header checksums is that the source and destination IP addresses are 32 bit in IPv4 and 128 bit in IPv6.</p>
</div>
<div class="paragraph">
<p>Certain network controllers are able to perform TCP checksum computation and validation in hardware. For such systems, applications may want to use hardware checksum logic as much as possible to reduce runtime overhead. Applications may disable TCP checksum computation logic from the NetX Duo library altogether at build time by defining <strong><em>NX_DISABLE_TCP_TX_CHECKSUM</em></strong> and <strong><em>NX_DISABLE_TCP_RX_CHECKSUM</em></strong>. This way, the TCP checksum code is not compiled in. However one should exercise caution if the optional NetX Duo IPsec package is installed, and the TCP connection may need to traverse through a secure channel. In this case, data in packets belonging to the TCP connection is already encrypted, and most hardware TCP checksum modules present in the network driver are unable to generate correct checksum value from the encrypted TCP payload.</p>
</div>
<div class="paragraph">
<p>To address this issue, application shall keep the TCP checksum logic available in the library and use the interface capability feature. With interface capability feature enabled, the TCP module knows how to
properly handle the TCP checksum if the driver is also able to compute the checksum value:</p>
</div>
<div class="paragraph">
<p>1) If the TCP packet is not subject to IPsec process, the network interface hardware is able to compute the checksum. Therefore the TCP module does not attempt to compute the checksum;</p>
</div>
<div class="paragraph">
<p>2) If IPsec package is installed, and the TCP packet is subject to IPsec process, the TCP module computes checksum in software before sending the packet to IPsec layer.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_port">TCP Port</h3>
<div class="paragraph">
<p>A TCP port is a logical connection point in the TCP protocol. There are 65,535 valid ports in the TCP component of NetX Duo, ranging from 1 through 0xFFFF. Unlike UDP in which data from one port can be sent to any other destination port, a TCP port is connected to another specific TCP port, and only when this connection is established can any data transfer take place&#8212;&#8203;and only between the two ports making up the connection.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>TCP ports are completely separate from UDP ports; e.g., UDP port number 1 has no relation to TCP port number 1</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_client_server_model">Client-Server Model</h3>
<div class="paragraph">
<p>To use TCP for data transfer, a connection must first be established between the two TCP sockets. The establishment of the connection is done in a client-server fashion. The client side of the connection is the side that initiates the connection, while the server side simply waits for client connection requests before any processing is done.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>For multihome devices, NetX Duo automatically determines the source address to use for the connection, and the next hop address based on the destination IP address of the connection. Because TCP is limited to sending packets to unicast (e.g.nonbroadcast) destination addresses, NetX Duo does not require a "hint" for choosing the source IPv6 address</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_socket_state_machine">TCP Socket State Machine</h3>
<div class="paragraph">
<p>The connection between two TCP sockets (one client and one server) is complex and is managed in a state machine manner. Each TCP socket starts in a CLOSED state. Through connection events each socket&#8217;s state machine migrates into the ESTABLISHED state, which is where the bulk of the data transfer in TCP takes place. When one side of the connection no longer wishes to send data, it disconnects. After the other side disconnects, eventually the TCP socket returns to the CLOSED state. This process repeats each time a TCP client and server establish and close a connection. Figure 14 shows the various states of the TCP state machine.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_client_connection">TCP Client Connection</h3>
<div class="paragraph">
<p>As mentioned previously, the client side of the TCP connection initiates a connection request to a TCP server. Before a connection request can be made, TCP must be enabled on the client IP instance. In addition, the client TCP socket must next be created with the <strong><em>nx_tcp_socket_create</em></strong> service and bound to a port via the <strong><em>nx_tcp_client_socket_bind</em></strong> service.</p>
</div>
<div class="paragraph">
<p>After the client socket is bound, the <strong><em>nxd_tcp_client_socket_connect</em></strong> service is used to establish a connection with a TCP server. Note the socket must be in a CLOSED state to initiate a connection attempt. Establishing the connection starts with NetX Duo issuing a SYN packet and then waiting for a SYN ACK packet back from the server, which signifies acceptance of the connection request. After the SYN ACK is received, NetX Duo responds with an ACK packet and promotes the client socket to the ESTABLISHED state.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/image24.png" alt="Diagram of the states of the TCP state machine.">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 14. States of the TCP State Machine</strong></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Applications should use <strong>nxd_tcp_client_socket_connect</strong> for either IPv4 and IPv6 TCP connections. Applications can still use <strong>nx_tcp_client_socket_connect</strong> for IPv4 TCP connections, but developers are encouraged to use <strong>nxd_tcp_client_socket_connect</strong> since <strong>nx_tcp_client_socket_connect</strong> will eventually be deprecated</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>Similarly, <strong>nxd_tcp_socket_peer_info_get</strong> works with either IPv4 or IPv6 TCP connections. However, <strong>nx_tcp_socket_peer_info_get</strong> is still available for legacy applications. Developers are encouraged to use <strong>nxd_tcp_socket_peer_info_get</strong> going forward</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_client_disconnection">TCP Client Disconnection</h3>
<div class="paragraph">
<p>Closing the connection is accomplished by calling <strong><em>nx_tcp_socket_disconnect</em></strong>. If no suspension is specified, the client socket sends a RST packet to the server socket and places the socket in the CLOSED state. Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the server previously initiated a disconnect request (the client socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX Duo promotes the client TCP socket state to the LAST ACK state and sends a FIN packet. It then waits for an ACK from the server before completing the disconnect and entering the CLOSED state.</p>
</li>
<li>
<p>If on the other hand, the client is the first to initiate a disconnect request (the server has not disconnected and the socket is still in the ESTABLISHED state), NetX Duo sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the server before completing the disconnect and placing the socket in a CLOSED state.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If there are still packets on the socket transmit queue, NetX Duo suspends for the specified timeout to allow the packets to be acknowledged. If the timeout expires, NetX Duo empties the transmit queue of the client socket.</p>
</div>
<div class="paragraph">
<p>To unbind the port from the client socket, the application calls <strong><em>nx_tcp_client_socket_unbind</em></strong>. The socket must be in a CLOSED state or in the process of disconnecting (i.e., TIMED WAIT state) before the port is released; otherwise, an error is returned.</p>
</div>
<div class="paragraph">
<p>Finally, if the application no longer needs the client socket, it calls <strong><em>nx_tcp_socket_delete</em></strong> to delete the socket.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_server_connection">TCP Server Connection</h3>
<div class="paragraph">
<p>The server side of a TCP connection is passive; i.e., the server waits for a client to initiate connection request. To accept a client connection, TCP must first be enabled on the IP instance by calling the service <strong><em>nx_tcp_enable</em></strong>. Next, the application must create a TCP socket using the <strong><em>nx_tcp_socket_create</em></strong> service.</p>
</div>
<div class="paragraph">
<p>The server socket must also be set up for listening for connection requests. This is achieved by using the <strong><em>nx_tcp_server_socket_listen</em></strong> service. This service places the server socket in the LISTEN state and binds the specified server port to the socket.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>To set a socket listen callback routine the application specifies the appropriate callback function for the tcp_listen_callback argument of the <strong>nx_tcp_server_socket_listen</strong> service. This application callback function is then executed by NetX Duo whenever a new connection is requested on this server port. The processing in the callback is under application control.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To accept client connection requests, the application calls the <strong><em>nx_tcp_server_socket_accept</em></strong> service. The server socket must either be in a LISTEN state or a SYN RECEIVED state (i.e., the server is in the LISTEN state and has received a SYN packet from a client requesting a connection) to call the accept service. A successful return status from <strong><em>nx_tcp_server_socket_accept</em></strong> indicates the connection has been set up and the server socket is in the ESTABLISHED state.</p>
</div>
<div class="paragraph">
<p>After the server socket has a valid connection, additional client connection requests are queued up to the depth specified by the <em>listen_queue_size, passed into the</em> <strong><em>nx_tcp_server_socket_listen</em></strong> service. In order to process subsequent connections on a server port, the application must call <strong><em>nx_tcp_server_socket_relisten</em></strong> with an available socket (i.e., a socket in a CLOSED state). Note that the same server socket could be used if the previous connection associated with the socket is now finished and the socket is in the CLOSED state.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_server_disconnection">TCP Server Disconnection</h3>
<div class="paragraph">
<p>Closing the connection is accomplished by calling <strong><em>nx_tcp_socket_disconnect</em></strong>. If no suspension is specified, the server socket sends a RST packet to the client socket and places the socket in the CLOSED state. Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the client previously initiated a disconnect request (the server socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX Duo promotes the TCP socket state to the LAST ACK state and sends a FIN packet. It then waits for an ACK from the client before  completing the disconnect and entering the CLOSED state.</p>
</li>
<li>
<p>If on the other hand, the server is the first to initiate a disconnect request (the client has not disconnected and the socket is still in the ESTABLISHED state), NetX Duo sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the client before completing the disconnect and placing the socket in a CLOSED state.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If there are still packets on the socket transmit queue, NetX Duo suspends for the specified timeout to allow those packets to be acknowledged. If the timeout expires, NetX Duo flushes the transmit queue of the server socket.</p>
</div>
<div class="paragraph">
<p>After the disconnect processing is complete and the server socket is in the CLOSED state, the application must call the <strong><em>nx_tcp_server_socket_unaccept</em></strong> service to end the association of this socket with the server port. Note this service must be called by the application even if <strong><em>nx_tcp_socket_disconnect</em></strong> or <strong><em>nx_tcp_server_socket_accept</em></strong> return an error status. After the <strong><em>nx_tcp_server_socket_unaccept</em></strong> returns, the socket can be used as a client or server socket, or even deleted if it is no longer needed. If accepting another client connection on the same server port is desired, the <strong><em>nx_tcp_server_socket_relisten</em></strong> service should be called on this socket.</p>
</div>
<div class="paragraph">
<p>The following code segment illustrates the sequence of calls a typical TCP server uses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Set up a previously created TCP socket to
   listen on port 12 */
nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1)
{
    /* Wait for a client socket connection request
       for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP
       client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on
       the port. */
    nx_tcp_server_socket_unaccept(&amp;server_socket);
    /* Set up server socket to relisten on the
       same port for the next client. */
    nx_tcp_server_socket_relisten();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mss_validation">MSS Validation</h3>
<div class="paragraph">
<p>The Maximum Segment Size (MSS) is the maximum amount of bytes a TCP host can receive without being fragmented by the underlying IP layer. During TCP connection establishment phase, both ends exchanges its own TCP MSS value, so that the sender does not send a TCP data segment that is larger than the receiver&#8217;s MSS. NetX Duo TCP module will optionally validate its peer&#8217;s advertised MSS value before establishing a connection. By default NetX Duo does not enable such a check. Applications wishing to perform MSS validation shall define <strong><em>NX_ENABLE_TCP_MSS_CHECK</em></strong> when building the NetX Duo library, and the minimum value shall be defined in <strong><em>NX_TCP_MSS_MINIMUM</em></strong>. Incoming TCP connections with MSS values below <strong><em>NX_TCP_MSS_MINIMUM</em></strong> are dropped.</p>
</div>
</div>
<div class="sect2">
<h3 id="_stop_listening_on_a_server_port">Stop Listening on a Server Port</h3>
<div class="paragraph">
<p>If the application no longer wishes to listen for client connection requests on a server port that was previously specified by a call to the <strong><em>nx_tcp_server_socket_listen</em></strong> service, the application simply calls the <strong><em>nx_tcp_server_socket_unlisten</em></strong> service. This service places any socket waiting for a connection back in the CLOSED state and releases any queued client connection request packets.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_window_size">TCP Window Size</h3>
<div class="paragraph">
<p>During both the setup and data transfer phases of the connection, each port reports the amount of data it can handle, which is called its window size. As data are received and processed, this window size is adjusted dynamically. In TCP, a sender can only send an amount of data that fits into the receiver&#8217;s window. In essence, the window size provides flow control for data transfer in each direction of the connection.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_packet_send">TCP Packet Send</h3>
<div class="paragraph">
<p>Sending TCP data is easily accomplished by calling the <strong><em>nx_tcp_socket_send</em></strong> function. If the size of the data being transmitted is larger than the MSS value of the socket or the current peer receive window size, whichever is smaller, TCP internal logic carves off the data that fits into min (MSS, peer receive Window) for transmission. This service then builds a TCP header in front of the packet (including the checksum calculation). If the receiver&#8217;s window size is not zero, the caller will send as much data as it can to fill up the receiver window size. If the receive window becomes zero, the caller may suspend and wait for the receiver&#8217;s window size to increase enough for this packet to be sent. At any given time, multiple threads may suspend while trying to send data through the same socket.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>The TCP data residing in the NX_PACKET structure should reside on a long-word boundary. In addition, there needs to be sufficient space between the prepend pointer and the data start pointer to place the TCP, IP, and physical media headers</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_packet_retransmit">TCP Packet Retransmit</h3>
<div class="paragraph">
<p>Previously transmitted TCP packets sent actually stored internally until an ACK is returned from the other side of the connection. If transmitted data is not acknowledged within the timeout period, the stored packet is re-sent and the next timeout period is set. When an ACK is received, all packets covered by the acknowledgement number in the internal transmit queue are finally released.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Application shall not reuse the packet or alter the contents of the packet after nx_tcp_socket_send() returns with NX_SUCCESS. The transmitted packet is eventually released by NetX Duo internal processing after the data is acknowledged by the other end</em>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_keepalive">TCP Keepalive</h3>
<div class="paragraph">
<p>TCP Keepalive feature allows a socket to detect whether or not its peer disconnects without proper termination (for example, the peer crashed), or to prevent certain network monitoring facilities to terminate a connection for long periods of idle. TCP Keepalive works by periodically sending a TCP frame with no data, and the sequence number set to one less than the current sequence number. On receiving such TCP Keepalive frame, the recipient, if still alive, responses with an ACK for its current sequence number. This completes the keepalive transaction.</p>
</div>
<div class="paragraph">
<p>By default the keepalive feature is not enabled. To use this feature, NetX Duo library must be built with <strong><em>NX_ENABLE_TCP_KEEPALIVE</em></strong> defined. The symbol <strong><em>NX_TCP_KEEPALIVE_INITIAL</em></strong> specifies the number of seconds of inactivity before the keepalive frame is initiated.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_packet_receive">TCP Packet Receive</h3>
<div class="paragraph">
<p>The TCP receive packet processing (called from the IP helper thread) is responsible for handling various connection and disconnection actions as well as transmit acknowledge processing. In addition, the TCP receive packet processing is responsible for placing packets with receive data on the appropriate TCP socket&#8217;s receive queue or delivering the packet to the first suspended thread waiting for a packet.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_receive_notify">TCP Receive Notify</h3>
<div class="paragraph">
<p>If the application thread needs to process received data from more than one socket, the <strong><em>nx_tcp_socket_receive_notify</em></strong> function should be used. This function registers a receive packet callback function for the socket. Whenever a packet is received on the socket, the callback function is executed.</p>
</div>
<div class="paragraph">
<p>The contents of the callback function are application specific; however, the function would most likely contain logic to inform the processing thread that a packet is available on the corresponding socket.</p>
</div>
</div>
<div class="sect2">
<h3 id="_thread_suspension_5">Thread Suspension</h3>
<div class="paragraph">
<p>As mentioned previously, application threads can suspend while attempting to receive data from a particular TCP port. After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed. An optional timeout is available when suspending on a TCP receive packet, a feature available for most NetX Duo services.</p>
</div>
<div class="paragraph">
<p>Thread suspension is also available for connection (both client and server), client binding, and disconnection services.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_socket_statistics_and_errors">TCP Socket Statistics and Errors</h3>
<div class="paragraph">
<p>If enabled, the NetX Duo TCP socket software keeps track of several statistics and errors that may be useful to the application. The following statistics and error reports are maintained for each IP/TCP instance:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Total TCP Packets Sent</p>
</li>
<li>
<p>Total TCP Bytes Sent</p>
</li>
<li>
<p>Total TCP Packets Received</p>
</li>
<li>
<p>Total TCP Bytes Received</p>
</li>
<li>
<p>Total TCP Invalid Packets</p>
</li>
<li>
<p>Total TCP Receive Packets Dropped</p>
</li>
<li>
<p>Total TCP Receive Checksum Errors</p>
</li>
<li>
<p>Total TCP Connections</p>
</li>
<li>
<p>Total TCP Disconnections</p>
</li>
<li>
<p>Total TCP Connections Dropped</p>
</li>
<li>
<p>Total TCP Packet Retransmits</p>
</li>
<li>
<p>TCP Socket Packets Sent</p>
</li>
<li>
<p>TCP Socket Bytes Sent</p>
</li>
<li>
<p>TCP Socket Packets Received</p>
</li>
<li>
<p>TCP Socket Bytes Received</p>
</li>
<li>
<p>TCP Socket Packet Retransmits</p>
</li>
<li>
<p>TCP Socket Packets Queued</p>
</li>
<li>
<p>TCP Socket Checksum Errors</p>
</li>
<li>
<p>TCP Socket State</p>
</li>
<li>
<p>TCP Socket Transmit Queue Depth</p>
</li>
<li>
<p>TCP Socket Transmit Window Size</p>
</li>
<li>
<p>TCP Socket Receive Window Size</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All these statistics and error reports are available to the application with the <strong><em>nx_tcp_info_get</em></strong> service for total TCP statistics and the <strong><em>nx_tcp_socket_info_get</em></strong> service for TCP statistics per socket.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcp_socket_control_block_nx_tcp_socket">TCP Socket Control Block NX_TCP_SOCKET</h3>
<div class="paragraph">
<p>The characteristics of each TCP socket are found in the associated <em>NX_TCP_SOCKET</em> control block, which contains useful information such as the link to the IP data structure, the network connection interface, the bound port, and the receive packet queue. This structure is defined in the <strong><em>nx_api.h</em></strong> file.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tcpip_offload">TCP/IP Offload</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This feature enables NetX Duo to support network interface card that offers TCP/IP service on the hardware. Certain WiFi modules offer TCP/IP processing on the module, and the applications on MCU send and receive packets through APIs to access its TCP/IP stack. With this feature enabled, developers can run native NetX Duo applications directly.</p>
</div>
<div class="paragraph">
<p>To enable TCP/IP offload feature, NetX Duo must be built with <code>NX_ENABLE_TCPIP_OFFLOAD</code> and <code>NX_ENABLE_INTERFACE_CAPABILITY</code> defined.</p>
</div>
<div class="sect2">
<h3 id="_tcpip_offload_handler">TCP/IP Offload Handler</h3>
<div class="paragraph">
<p>NetX Duo communicates with network driver through a callback function to handle TCP or UDP socket operations. The callback function is defined in the <code>NX_INTERFACE_STRUCT</code>. Network driver needs to set the TCP/IP callback function during <code>NX_LINK_ENABLE</code> driver command. The prototype of TCP/IP callback function is as below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">UINT (*nx_interface_tcpip_offload_handler)(struct NX_IP_STRUCT *ip_ptr,
                                           struct NX_INTERFACE_STRUCT *interface_ptr,
                                           VOID *socket_ptr, UINT operation, NX_PACKET *packet_ptr,
                                           NXD_ADDRESS *local_ip, NXD_ADDRESS *remote_ip,
                                           UINT local_port, UINT *remote_port, UINT wait_option);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Description of parameters.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ip_ptr</code> - Pointer to IP instance</p>
</li>
<li>
<p><code>interface_ptr</code> - Pointer to interface</p>
</li>
<li>
<p><code>socket_ptr</code> - Pointer to <code>NX_TCP_SOCKET</code> or <code>NX_UDP_SOCKET</code>, depends on the value of <code>operation</code></p>
</li>
<li>
<p><code>operation</code> - Operation of current function call. Values are defined as below</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">#define NX_TCPIP_OFFLOAD_TCP_CLIENT_SOCKET_CONNECT  0
#define NX_TCPIP_OFFLOAD_TCP_SERVER_SOCKET_LISTEN   1
#define NX_TCPIP_OFFLOAD_TCP_SERVER_SOCKET_ACCEPT   2
#define NX_TCPIP_OFFLOAD_TCP_SERVER_SOCKET_UNLISTEN 3
#define NX_TCPIP_OFFLOAD_TCP_SOCKET_DISCONNECT      4
#define NX_TCPIP_OFFLOAD_TCP_SOCKET_SEND            5
#define NX_TCPIP_OFFLOAD_UDP_SOCKET_BIND            6
#define NX_TCPIP_OFFLOAD_UDP_SOCKET_UNBIND          7
#define NX_TCPIP_OFFLOAD_UDP_SOCKET_SEND            8</code></pre>
</div>
</div>
</li>
<li>
<p><code>packet_ptr</code> - Pointer to packet. The value is set when <code>operation</code> is <code>TCP_SOCKET_SEND</code> or <code>UDP_SOCKET_SEND</code></p>
</li>
<li>
<p><code>local_ip</code> - Pointer to local IP address. The value is set when <code>operation</code> is <code>UDP_SOCKET_SEND</code></p>
</li>
<li>
<p><code>remote_ip</code> - Pointer to remote IP address. The value is set when <code>operation</code> is <code>TCP_CLIENT_SOCKET_CONNECT</code> or <code>UDP_SOCKET_SEND</code>. When the operation is <code>TCP_SERVER_SOCKET_ACCEPT</code>, this value must be returned by callback function</p>
</li>
<li>
<p><code>local_port</code> - Local port. The value is set when <code>operation</code> is <code>TCP_CLIENT_SOCKET_CONNECT</code>, <code>TCP_SERVER_SOCKET_LISTEN</code>, <code>TCP_SERVER_SOCKET_ACCEPT</code>, <code>TCP_SERVER_SOCKET_UNLISTEN</code> or UDP</p>
</li>
<li>
<p><code>remote_port</code> - Remote port. The value is set when <code>operation</code> is <code>TCP_CLIENT_SOCKET_CONNECT</code> or <code>UDP_SOCKET_SEND</code>. When the operation is <code>TCP_SERVER_SOCKET_ACCEPT</code>, this value must be returned by callback function</p>
</li>
<li>
<p><code>wait_option</code> - Wait option in ticks. The value is set for all operations</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_tcpip_offload_context">TCP/IP Offload Context</h3>
<div class="paragraph">
<p>A pointer is added to <code>NX_TCP_SOCKET</code> structure to be used by TCP/IP offload driver.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>typedef struct NX_TCP_SOCKET_STRUCT
{
    // ...

    /* This pointer is designed to be accessed by TCP/IP offload directly.  */
    VOID *nx_tcp_socket_tcpip_offload_context;
} NX_TCP_SOCKET;</pre>
</div>
</div>
<div class="paragraph">
<p>A pointer is added to <code>NX_UDP_SOCKET</code> structure to be used by TCP/IP offload driver.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>typedef struct NX_UDP_SOCKET_STRUCT
{
    // ...

    /* This pointer is designed to be accessed by TCP/IP offload directly.  */
    VOID *nx_udp_socket_tcpip_offload_context;
} NX_UDP_SOCKET;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_apis_for_tcpip_offload_network_driver">APIs for TCP/IP Offload Network Driver</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-C" data-lang="C">/* Invoked when TCP packet is receive or connection error.  */
VOID _nx_tcp_socket_driver_packet_receive(NX_TCP_SOCKET *socket_ptr, NX_PACKET *packet_ptr);

/* Invoked when TCP connection is establish.  */
UINT _nx_tcp_socket_driver_establish(NX_TCP_SOCKET *socket_ptr, NX_INTERFACE *interface_ptr, UINT remote_port);

/* Invoked when UDP packet is receive.  */
VOID _nx_udp_socket_driver_packet_receive(NX_UDP_SOCKET *socket_ptr, NX_PACKET *packet_ptr,
                                          NXD_ADDRESS *local_ip, NXD_ADDRESS *remote_ip, UINT remote_port);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tcpip_offload_driver">TCP/IP Offload Driver</h3>
<div class="paragraph">
<p>A driver function is needed for each IP interface. Refer to <a href="chapter5.md#tcpip-offload-driver-guidance">Chapter 5</a> for more details on how to develop NetX Duo driver functions.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tcpip_offload_known_limitations">TCP/IP Offload Known Limitations</h3>
<div class="ulist">
<ul>
<li>
<p>Only TCP and UDP sockets are supported</p>
</li>
<li>
<p>DHCP is usually done by underlayer TCP/IP stack not NetX Duo</p>
</li>
<li>
<p>Other limitations from underlayer TCP/IP stack</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tsn_components">TSN Components</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Time-Sensitive Networking (TSN) is a suite of standards crafted by the IEEE 802.1 working group aimed at augmenting the capabilities of Ethernet networks. These standards define mechanisms for transmitting time-sensitive data over deterministic Ethernet networks.</p>
</div>
<div class="paragraph">
<p>In this section, the TSN compents in below frame work in colour blue are described.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./media/user-guide/tsn-framework.png" alt="Diagram of TSN Framework">
</div>
</div>
<div class="paragraph">
<p><strong>FIGURE 15. TSN Framework</strong></p>
</div>
<div class="sect2">
<h3 id="_link_layer">Link layer</h3>
<div class="paragraph">
<p>In NetxDuo, the Link Layer component offers a range of essential functionalities, These include:</p>
</div>
<div class="paragraph">
<p>VLAN Interface Creation: NetxDuo allows for the seamless creation of Virtual Local Area Network (VLAN) interfaces, enabling the segmentation of network traffic into distinct logical networks.</p>
</div>
<div class="paragraph">
<p>VLAN ID Modification: It provides the capability to modify VLAN IDs on specific VLAN interface, facilitating the customization and management of VLAN configurations to suit specific network requirements.</p>
</div>
<div class="paragraph">
<p>Raw Packet Transmission: NetxDuo provides a Raw Packet transmission interface for direct transmission of network packets at the Link Layer. This is particularly useful for specialized network communication needs, such as the direct sending of packets by MRP and ptp components using raw packet transmission.</p>
</div>
<div class="paragraph">
<p>Packet Distribution for Received Packets: The Link Layer in NetxDuo efficiently handles the reception of network packets, distributing them appropriately based on packet types. This includes the distribution of VLAN-tagged packets to the corresponding VLAN interfaces and the distribution of untagged packets to the default interface.</p>
</div>
<div class="paragraph">
<p>Above functionalities are used by TSN components to implement TSN features.</p>
</div>
</div>
<div class="sect2">
<h3 id="_credit_based_shaper_cbs_ieee_802_1qav_forwarding_and_queuing_enhancements_for_time_sensitive_stream">Credit-based shaper (CBS) - IEEE 802.1Qav Forwarding and Queuing Enhancements for Time-Sensitive Stream</h3>
<div class="paragraph">
<p>Credit-based shaper (CBS) is a traffic shaping mechanism that is in audio video bridge(AVB) network, to ensure/control the bandwidth of specific audio and video traffic streams. this mechanism can ensure that the data is transmitted at a constant rate and to avoid congestion in the network.</p>
</div>
<div class="paragraph">
<p>In CBS module of NetxDuo, following functionalities are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CBS shaper creation and deletion.</p>
</li>
<li>
<p>The Mapping configuration of PCP on VLAN tag to related hardware queue.</p>
</li>
<li>
<p>CBS parameters Setting, such as idle slope, send slope, and CBS credit limit.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By utilizing these functionalities, we can assign different SR class traffic to specific hardware queues and control the bandwidth of the traffic by setting the CBS parameters on related hardware queues.</p>
</div>
</div>
<div class="sect2">
<h3 id="_time_aware_shaper_tas_ieee_802_1qbv_enhancements_to_traffic_scheduling">Time-Aware Shaper (TAS) - IEEE 802.1Qbv Enhancements to Traffic Scheduling</h3>
<div class="paragraph">
<p>TAS (Time-Aware Scheduler) in TSN (Time-Sensitive Networking) is designed to ensures deterministic and prioritized communication by controlling the bandwidth allocation for high-priority streams through gate control and regulating cycles.</p>
</div>
<div class="paragraph">
<p>The IEEE 802.1Qbv time-aware scheduler orchestrates Ethernet network communication by dividing it into fixed-length, repeating time cycles. Within these cycles, customizable time slices are allocated to one or multiple of the eight Ethernet priorities. This approach enables exclusive utilization of the Ethernet transmission medium for time-sensitive traffic classes, ensuring uninterrupted transmission guarantees when needed. Operating on a time-division multiple access (TDMA) scheme, the scheduler establishes virtual communication channels for specific time periods, effectively segregating time-critical communication from non-critical background traffic.</p>
</div>
<div class="paragraph">
<p>In TAS module of NetxDuo, following functionalities are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TAS shaper creation and deletion. (Shared with CBS and FPE)</p>
</li>
<li>
<p>The Mapping configuration of PCP on VLAN tag to related hardware queue.(Shared with CBS)</p>
</li>
<li>
<p>TAS parameters setting. Include base time, cycle time, time slot and associated gate control settings.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By leveraging these functionalities, high-priority traffic can be directed to specific hardware queues with allocated time slots, enabling precise bandwidth control. Furthermore, through synchronized TAS settings across the entire TSN infrastructure and time synchronization facilitated by gPTP (generalized Precision Time Protocol), we can effectively manage end-to-end latency for traffic, ensuring timely and reliable communication.</p>
</div>
</div>
<div class="sect2">
<h3 id="_frame_preemption_fpe_802_1qbu">Frame preemption (FPE) - 802.1Qbu</h3>
<div class="paragraph">
<p>Frame Preemption (FPE) is a TSN feature that allows high-priority frames to interrupt the transmission of lower-priority frames. This feature is particularly useful in time-sensitive applications, where the timely delivery of high-priority frames is critical. By preempting the transmission of lower-priority frames, high-priority frames can be transmitted without delay, ensuring that they are delivered within the required time frame.</p>
</div>
<div class="paragraph">
<p>In FPE module of NetxDuo, following functionalities are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>FPE shaper creation and deletion. (Shared with CBS and TAS)</p>
</li>
<li>
<p>FPE parameters setting. such as enable/disable the FPE verification, express queue bitmap setting, ha/ra time setting, express queue guard band enable/disable.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>FPE (Frame Preemption Engine) is typically utilized in conjunction with TAS (Time-Aware Scheduler). By fragmenting preemptable frames, the guard band required for preemptable frame slots is reduced, thus increasing bandwidth utilization efficiency.</p>
</div>
</div>
<div class="sect2">
<h3 id="_time_synchronizationgptp">Time synchronization(gPTP)</h3>
<div class="paragraph">
<p>The gPTP (Generalized Precision Time Protocol), as described in the IEEE 1588 Precision Time Protocol standard, is utilized within Time-Sensitive Networks (TSN) to synchronize time across network devices.</p>
</div>
<div class="paragraph">
<p>In gPTP module of NetxDuo, following functionalities are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Creation and deletion of PTP client.</p>
</li>
<li>
<p>Starting and stopping the PTP client.</p>
</li>
<li>
<p>Retrieving and setting the PTP clock in the client.</p>
</li>
<li>
<p>Acquiring master clock information and sync message details through the PTP client.</p>
</li>
<li>
<p>Transmission of timestamp notifications for PTP packets.</p>
</li>
<li>
<p>Implementation of a software-based PTP clock.</p>
</li>
<li>
<p>Utility of computing the difference between two PTP times.</p>
</li>
<li>
<p>Utility of converting a PTP time to a UTC date and time.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_stream_registration_protocol_srp">Stream Registration Protocol (SRP)</h3>
<div class="paragraph">
<p>SRP (Stream Reservation Protocol) is a protocol used in Time-Sensitive Networking (TSN). It allows devices to reserve resources for specific streams of data across the network. This ensures that these streams have the necessary bandwidth and can meet their time sensitivity requirements.</p>
</div>
<div class="paragraph">
<p>In SRP module of NetxDuo, following functionalities are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialization of SRP service.</p>
</li>
<li>
<p>Starting and stopping the SRP talker service.</p>
</li>
<li>
<p>Starting and stopping the SRP listener service.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_stream_reservation_protocol_msrp">Multiple Stream Reservation Protocol (MSRP)</h3>
<div class="paragraph">
<p>MSRP (Multiple Stream Reservation Protocol) in Time-Sensitive Networking (TSN) is an extension of the Stream Reservation Protocol (SRP). By allowing multiple stream reservations, MSRP enhances the deterministic data delivery capabilities of TSN, ensuring that data can be delivered with a guaranteed level of performance across multiple streams.</p>
</div>
<div class="paragraph">
<p>In MSRP module of NetxDuo, following functionalities are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialization of an MSRP instance.</p>
</li>
<li>
<p>Parsing and packing of MRP Data Units (MRPDUs).</p>
</li>
<li>
<p>Management of the registration and deregistration processes for a stream.</p>
</li>
<li>
<p>Management of the registration and deregistration processes for an attachment to a stream.</p>
</li>
<li>
<p>Handling of indications for a stream&#8217;s registration and deregistration events.</p>
</li>
<li>
<p>Handling of indications for an attachment&#8217;s registration and deregistration events.</p>
</li>
<li>
<p>Management of the registration and deregistration processes for a domain, as well as handling the indications of these events.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_vlan_registration_protocol_mvrp">Multiple vlan registration protocol (MVRP)</h3>
<div class="paragraph">
<p>The Multiple VLAN Registration Protocol (MVRP) is a protocol that provides dynamic VLAN registration service. It is an MRP (Multiple Registration Protocol) application that makes use of MRP Attribute Declaration (MAD) and MRP Attribute Propagation (MAP) to provide common state machine descriptions and attribute propagation mechanisms.
MVRP provides a mechanism for dynamic maintenance of the contents of Dynamic VLAN Registration Entries for each VLAN and propagates the information they contain to other Bridges. This information allows MVRP-aware devices to dynamically establish and update their knowledge of the set of VLANs that currently have active members, and through which Ports those members can be reached.
In MVRP module of NetxDuo, following functionalities are provided to SRP/MRP components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialization of an MVRP instance.</p>
</li>
<li>
<p>Parsing and packing of MRP Data Units (MRPDUs).</p>
</li>
<li>
<p>Process the join or leave a VLAN request command from SRP, and trigger the corresponding VLAN registration or deregistration process.</p>
</li>
<li>
<p>Handling of indications for a stream&#8217;s registration and deregistration events from MRP.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_registration_protocol_mrp">Multiple registration protocol (MRP)</h3>
<div class="paragraph">
<p>The Multiple Registration Protocol (MRP) is a protocol that provides dynamic registration and deregistration of attributes in a network. It is used to manage resources in a network, such as VLANs, multicast addresses, and streams. MRP operates uses a common state machine and attribute propagation mechanisms to provide a consistent view of the network resources. MRP is used by other protocols, such as MVRP (Multiple VLAN Registration Protocol) and MSRP (Multiple Stream Registration Protocol), to provide dynamic registration of VLANs and streams, respectively.</p>
</div>
<div class="paragraph">
<p>In MRP module of NetxDuo, following functionalities are provided to MRP applications:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provide the interface of MRP initialization.</p>
</li>
<li>
<p>Maintaining state machine for MRP applications.</p>
</li>
<li>
<p>Process the event triggered by receiving different MRP messages.</p>
</li>
<li>
<p>Receiving the message from ethernet, and distribute the MRP messages to the corresponding MRP applications.</p>
</li>
<li>
<p>Handle the timer event for MRP applications.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-12-19 22:09:55 -0500
</div>
</div>
</body>
</html>