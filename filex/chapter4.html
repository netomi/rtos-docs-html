<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="description" content="This chapter contains a description of all FileX services in alphabetic order.">
<title>Chapter 4 - Description of FileX services</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Chapter 4 - Description of FileX services</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This chapter contains a description of all FileX services in alphabetic order. Service names are designed so all similar services are grouped together.</p>
</div>
<div class="paragraph">
<p>The FileX API functions available to the application are as follows.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_directory_services">Directory_Services</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="#fx_directory_attributes_read">fx_directory_attributes_read</a></p>
</li>
<li>
<p><a href="#fx_directory_attributes_set">fx_directory_attributes_set</a></p>
</li>
<li>
<p><a href="#fx_directory_create">fx_directory_create</a></p>
</li>
<li>
<p><a href="#fx_directory_default_get">fx_directory_default_get</a></p>
</li>
<li>
<p><a href="#fx_directory_default_set">fx_directory_default_set</a></p>
</li>
<li>
<p><a href="#fx_directory_delete">fx_directory_delete</a></p>
</li>
<li>
<p><a href="#fx_directory_first_entry_find">fx_directory_first_entry_find</a></p>
</li>
<li>
<p><a href="#fx_directory_information_get">fx_directory_information_get</a></p>
</li>
<li>
<p><a href="#fx_directory_local_path_clear">fx_directory_local_path_clear</a></p>
</li>
<li>
<p><a href="#fx_directory_local_path_get">fx_directory_local_path_get</a></p>
</li>
<li>
<p><a href="#fx_directory_local_path_restore">fx_directory_local_path_restore</a></p>
</li>
<li>
<p><a href="#fx_directory_local_path_set">fx_directory_local_path_set</a></p>
</li>
<li>
<p><a href="#fx_directory_long_name_get">fx_directory_long_name_get</a></p>
</li>
<li>
<p><a href="#fx_directory_name_test">fx_directory_name_test</a></p>
</li>
<li>
<p><a href="#fx_directory_next_entry_find">fx_directory_next_entry_find</a></p>
</li>
<li>
<p><a href="#fx_directory_next_full_entry_find">fx_directory_next_full_entry_find</a></p>
</li>
<li>
<p><a href="#fx_directory_rename">fx_directory_rename</a></p>
</li>
<li>
<p><a href="#fx_directory_short_name_get">fx_directory_short_name_get</a></p>
</li>
<li>
<p><a href="#fx_directory_short_name_get_extended">fx_directory_short_name_get_extended</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_file_services">File_Services</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="#fx_file_allocate">fx_file_allocate</a></p>
</li>
<li>
<p><a href="#fx_file_attributes_read">fx_file_attributes_read</a></p>
</li>
<li>
<p><a href="#fx_file_attributes_set">fx_file_attributes_set</a></p>
</li>
<li>
<p><a href="#fx_file_best_effort_allocate">fx_file_best_effort_allocate</a></p>
</li>
<li>
<p><a href="#fx_file_close_fx_file_create">fx_file_close_fx_file_create</a></p>
</li>
<li>
<p><a href="#fx_file_date_time_set">fx_file_date_time_set</a></p>
</li>
<li>
<p><a href="#fx_file_delete">fx_file_delete</a></p>
</li>
<li>
<p><a href="#fx_file_extended_allocate">fx_file_extended_allocate</a></p>
</li>
<li>
<p><a href="#fx_file_extended_best_effort_allocate">fx_file_extended_best_effort_allocate</a></p>
</li>
<li>
<p><a href="#fx_file_extended_relative_seek">fx_file_extended_relative_seek</a></p>
</li>
<li>
<p><a href="#fx_file_extended_seek">fx_file_extended_seek</a></p>
</li>
<li>
<p><a href="#fx_file_extended_truncate">fx_file_extended_truncate</a></p>
</li>
<li>
<p><a href="#fx_file_extended_truncate_release">fx_file_extended_truncate_release</a></p>
</li>
<li>
<p><a href="#fx_file_open_fx_file_read">fx_file_open_fx_file_read</a></p>
</li>
<li>
<p><a href="#fx_file_relative_seek">fx_file_relative_seek</a></p>
</li>
<li>
<p><a href="#fx_file_rename_fx_file_seek">fx_file_rename_fx_file_seek</a></p>
</li>
<li>
<p><a href="#fx_file_truncate">fx_file_truncate</a></p>
</li>
<li>
<p><a href="#fx_file_truncate_release">fx_file_truncate_release</a></p>
</li>
<li>
<p><a href="#fx_file_write">fx_file_write</a></p>
</li>
<li>
<p><a href="#fx_file_write_notify_set">fx_file_write_notify_set</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_media_services">Media_Services</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="#fx_fault_tolerant_enable">fx_fault_tolerant_enable</a></p>
</li>
<li>
<p><a href="#fx_media_abort">fx_media_abort</a></p>
</li>
<li>
<p><a href="#fx_media_cache_invalidate">fx_media_cache_invalidate</a></p>
</li>
<li>
<p><a href="#fx_media_check">fx_media_check</a></p>
</li>
<li>
<p><a href="#fx_media_close">fx_media_close</a></p>
</li>
<li>
<p><a href="#fx_media_close_notify_set">fx_media_close_notify_set</a></p>
</li>
<li>
<p><a href="#fx_media_extended_space_available">fx_media_extended_space_available</a></p>
</li>
<li>
<p><a href="#fx_media_flush">fx_media_flush</a></p>
</li>
<li>
<p><a href="#fx_media_format">fx_media_format</a></p>
</li>
<li>
<p><a href="#fx_media_open">fx_media_open</a></p>
</li>
<li>
<p><a href="#fx_media_open_notify_set">fx_media_open_notify_set</a></p>
</li>
<li>
<p><a href="#fx_media_read">fx_media_read</a></p>
</li>
<li>
<p><a href="#fx_media_space_available">fx_media_space_available</a></p>
</li>
<li>
<p><a href="#fx_media_volume_get">fx_media_volume_get</a></p>
</li>
<li>
<p><a href="#fx_media_write">fx_media_write</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_system_services">System_Services</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="#fx_system_date_get">fx_system_date_get</a></p>
</li>
<li>
<p><a href="#fx_system_date_set">fx_system_date_set</a></p>
</li>
<li>
<p><a href="#fx_system_initialize">fx_system_initialize</a></p>
</li>
<li>
<p><a href="#fx_system_time_get">fx_system_time_get</a></p>
</li>
<li>
<p><a href="#fx_system_time_set">fx_system_time_set</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_unicode_services">Unicode_Services</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="#fx_unicode_directory_create">fx_unicode_directory_create</a></p>
</li>
<li>
<p><a href="#fx_unicode_directory_rename">fx_unicode_directory_rename</a></p>
</li>
<li>
<p><a href="#fx_unicode_file_create">fx_unicode_file_create</a></p>
</li>
<li>
<p><a href="#fx_unicode_file_rename">fx_unicode_file_rename</a></p>
</li>
<li>
<p><a href="#fx_unicode_length_get">fx_unicode_length_get</a></p>
</li>
<li>
<p><a href="#fx_unicode_length_get_extended">fx_unicode_length_get_extended</a></p>
</li>
<li>
<p><a href="#fx_unicode_name_get">fx_unicode_name_get</a></p>
</li>
<li>
<p><a href="#fx_unicode_short_name_get">fx_unicode_short_name_get</a></p>
</li>
<li>
<p><a href="#fx_unicode_short_name_get_extended">fx_unicode_short_name_get_extended</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_attributes_read">fx_directory_attributes_read</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reads a specified directory&#8217;s attributes.</p>
</div>
<div class="sect2">
<h3 id="_prototype">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_attributes_read(
    FX_MEDIA *media_ptr,
    CHAR *directory_name,
    UINT *attributes_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description">Description</h3>
<div class="paragraph">
<p>This service reads the directory&#8217;s attributes from the specified media.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>directory_name</em>: Pointer to the name of the requested directory (directory path is optional).</p>
</li>
<li>
<p><em>attributes_ptr</em>: Pointer to the destination for the directory&#8217;s attributes to be placed. The directory attributes are returned in a bit-map format with the following possible settings.</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_READ_ONLY</strong> (0x01)</p>
</li>
<li>
<p><strong>FX_HIDDEN</strong> (0x02)</p>
</li>
<li>
<p><strong>FX_SYSTEM</strong> (0x04)</p>
</li>
<li>
<p><strong>FX_VOLUME</strong> (0x08)</p>
</li>
<li>
<p><strong>FX_DIRECTORY</strong> (0x10)</p>
</li>
<li>
<p><strong>FX_ARCHIVE</strong> (0x20)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful directory attributes read</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open</p>
</li>
<li>
<p><strong>FX _NOT FOUND</strong> (0x04) Specified directory was not found in the media</p>
</li>
<li>
<p><strong>FX_NOT_DIRECTORY</strong> (0x0E) Entry is not a directory</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA    my_media;
UINT        status;
/* Retrieve the attributes of "mydir" from the specified media.*/
status = fx_directory_attributes_read(&amp;my_media, "mydir", &amp;attributes);

/* If status equals FX_SUCCESS, "attributes" contains the directory attributes of "mydir". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_attributes_set">fx_directory_attributes_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sets a specified directory&#8217;s attributes.</p>
</div>
<div class="sect2">
<h3 id="_prototype_2">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_attributes_set(
    FX_MEDIA *media_ptr,
    CHAR *directory_name,
    UINT *attributes);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_2">Description</h3>
<div class="paragraph">
<p>This service sets the directory&#8217;s attributes to those specified by the caller.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>This application is only allowed to modify a subset of the directory&#8217;s attributes with this service. Any attempt to set additional attributes will result in an error.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_2">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>directory_name</em>: Pointer to the name of the requested directory (directory path is optional).</p>
</li>
<li>
<p><em>attributes</em>: The new attributes of  this directory. The valid directory attributes are defined as follows.</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_READ_ONLY</strong> (0x01)</p>
</li>
<li>
<p><strong>FX_HIDDEN</strong> (0x02)</p>
</li>
<li>
<p><strong>FX_SYSTEM</strong> (0x04)</p>
</li>
<li>
<p><strong>FX_ARCHIVE</strong> (0x20)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_2">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful directory attribute set</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Specified directory was not found in the media</p>
</li>
<li>
<p><strong>FX_NOT_DIRECTORY</strong> (0x0E) Entry is not a directory</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more entries in this directory</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer</p>
</li>
<li>
<p><strong>FX_INVALID_ATTR</strong> (0x19) Invalid attributes selected.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_2">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_2">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA    my_media;
UINT        status;

/*Set the attributes of "mydir" to read-only. */
status = fx_directory_attributes_set(&amp;my_media, "mydir", FX_READ_ONLY);

/* If status equals FX_SUCCESS, the directory "mydir" is read-only. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_2">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_create">fx_directory_create</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Creates a subdirectory</p>
</div>
<div class="sect2">
<h3 id="_prototype_3">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_create(
    FX_MEDIA *media_ptr,
    CHAR *directory_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_3">Description</h3>
<div class="paragraph">
<p>This service creates a subdirectory in the current default directory or in the path supplied in the directory name. Unlike the root directory, subdirectories do not have a limit on the number of files they can hold. The root directory can only hold the number of entries determined by the boot record.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_3">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>directory_name</em>: Pointer to the name of the directory to create (directory path is optional).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_3">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful directory create.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Specified directory was not found in the media</p>
</li>
<li>
<p><strong>FX_NOT_DIRECTORY</strong> (0x0E) Entry is not a directory</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error</p>
</li>
<li>
<p><strong>FX_FILE _CORRUPT</strong> (0x08) File is corrupted</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more entries in this directory</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer</p>
</li>
<li>
<p><strong>FX_INVALID_ATTR</strong> (0x19) Invalid attributes selected.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_3">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_3">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA    my_media;
UINT        status;

/* Create a subdirectory called "temp" in the current default directory. */

status = fx_directory_create(&amp;my_media, "temp");

/* If status equals FX_SUCCESS, the new subdirectory "temp" has been created. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_3">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_default_get">fx_directory_default_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the last default directory</p>
</div>
<div class="sect2">
<h3 id="_prototype_4">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_default_get(
    FX_MEDIA *media_ptr,
    CHAR **return_path_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_4">Description</h3>
<div class="paragraph">
<p>This service returns the pointer to the path last set by <strong><em>fx_directory_default_set</em></strong>. If the default directory has not been set or if the current default directory is the root directory, a value of <strong>FX_NULL</strong> is returned.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>The default size of the internal path string is 256 characters; it can be changed by modifying <strong>FX_MAXIMUM_PATH</strong> in <strong>fx_api.h</strong> and rebuilding the entire FileX library. The character string path is maintained for the application and is not used internally by FileX.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_4">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>return_path_name</em>: Pointer to the destination for the last default directory string. A value of <strong>FX_NULL</strong> is returned if the current setting of the default directory is the root. When the media is opened, root is the default.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_4">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful default directory get</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or destination pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_4">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_4">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA    my_media;
CHAR        *current_default_dir;
UINT        status;

/* Retrieve the current default directory. */
status = fx_directory_default_get(&amp;my_media, &amp;current_default_dir);

/* If status equals FX_SUCCESS, "current_default_dir"
    contains a pointer to the current default directory).*/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_4">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_default_set">fx_directory_default_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sets the default directory</p>
</div>
<div class="sect2">
<h3 id="_prototype_5">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_default_set(
    FX_MEDIA *media_ptr,
    CHAR *new_path_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_5">Description</h3>
<div class="paragraph">
<p>This service sets the default directory of the media. If a value of <strong>FX_NULL</strong> is supplied, the default directory is set to the media&#8217;s root directory. All subsequent file operations that do not explicitly specify a path will default to this directory.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>The default size of the internal path string is 256 characters; it can be changed by modifying <strong>FX_MAXIMUM_PATH</strong> in <strong>fx_api.h</strong> and rebuilding the entire FileX library. The character string path is maintained for the application and is not used internally by FileX.</em>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>For names supplied by the application, FileX supports both backslash (\) and forward slash (/) characters to separate directories, subdirectories, and file names. However, FileX only uses the backslash character in paths returned to the application.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_5">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>new_path_name</em>: Pointer to new default directory name. If a value of <strong>FX_NULL</strong> is supplied, the default directory of the media is set to the media&#8217;s root directory.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_5">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00)  Successful default directory set</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open</p>
</li>
<li>
<p><strong>FX_INVALID_PATH</strong> (0x0D) New directory could not be found</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_5">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_5">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA    my_media;
UINT        status;

/* Set the default directory to \abc\def\ghi. */
status = fx_directory_default_set(&amp;my_media, "\\abc\\def\\ghi");

/* If status equals FX_SUCCESS, the default directory for this media is \abc\def\ghi. All subsequent file operations that do not explicitly specify a path will default to this directory. Note that the character "\" serves as an escape character in a string. To represent the character "\", use the construct "\\". This is done because of the C language- only one "\" is really present in the string. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_5">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_delete">fx_directory_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Deletes the specified subdirectory.</p>
</div>
<div class="sect2">
<h3 id="_prototype_6">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_delete(
    FX_MEDIA *media_ptr,
    CHAR *directory_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_6">Description</h3>
<div class="paragraph">
<p>This service deletes the specified directory. Note that the directory must be empty to delete it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_6">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>directory_name</em>: Pointer to name of directory to delete (directory path is optional).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_6">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful directory delete</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Specified directory was not found</p>
</li>
<li>
<p><strong>FX_DIR_NOT_EMPTY</strong> (0x10) Specified directory is not empty</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more entries in this directory</p>
</li>
<li>
<p><strong>FX_NOT_DIRECTORY</strong> (0x0E) Not a directory entry</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_6">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_6">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA    my_media;
UINT        status;

/* Delete the subdirectory "abc." */
status = fx_directory_delete(&amp;my_media, "abc");

/* If status equals FX_SUCCESS, the subdirectory "abc" was deleted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_6">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_first_entry_find">fx_directory_first_entry_find</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the first directory entry.</p>
</div>
<div class="sect2">
<h3 id="_prototype_7">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_first_entry_find(
    FX_MEDIA *media_ptr,
    CHAR *return_entry_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_7">Description</h3>
<div class="paragraph">
<p>This service retrieves the first entry name in the default directory and copies it to the specified destination.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>The specified destination must be large enough to hold the maximum sized FileX name, as defined by *FX_MAX_LONG_NAME_LEN.*</em>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>If using a non-local path, it is important to prevent (with a ThreadX semaphore, mutex, or priority level change) other application threads from changing this directory while a directory traversal is taking place. Otherwise, invalid results may be obtained.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_7">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>return_entry_name</em>: Pointer to destination for the first entry name in the default directory.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_7">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful first directory entry find</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more entries in this directory</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or destination pointer</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_7">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_7">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA         my_media;
UINT             status;
CHAR             entry[FX_MAX_LONG_NAME_LEN];
/* Retrieve the first directory entry in the current directory. */
status = fx_directory_first_entry_find(&amp;my_media, entry);
/* If status equals FX_SUCCESS, the entry in the directory is the "entry" string. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_7">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_first_full_entry_find">fx_directory_first_full_entry_find</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the first directory entry with full information.</p>
</div>
<div class="sect2">
<h3 id="_prototype_8">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_first_full_entry_find(
    FX_MEDIA *media_ptr,
    CHAR *directory_name,
    UINT *attributes,
    ULONG *size,
    UINT *year, UINT *month, UINT *day,
    UINT *hour, UINT *minute, UINT *second);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_8">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>directory_name</em>: Pointer to the destination for the name of a directory entry. Must be at least as big as <strong>FX_MAX_LONG_NAME_LEN</strong>.</p>
</li>
<li>
<p><em>attributes</em>: If non-null, pointer to the destination for the entry&#8217;s attributes to be placed. The attributes are returned in a bit-map format with the following possible settings.</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_READ_ONLY</strong> (0x01)</p>
</li>
<li>
<p><strong>FX_HIDDEN</strong> (0x02)</p>
</li>
<li>
<p><strong>FX_SYSTEM</strong> (0x04)</p>
</li>
<li>
<p><strong>FX_VOLUME</strong> (0x08)</p>
</li>
<li>
<p><strong>FX_DIRECTORY</strong> (0x10)</p>
</li>
<li>
<p><strong>FX_ARCHIVE</strong> (0x20)</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>size</em>: If non-null, a pointer to the destination for the entry&#8217;s size in bytes.</p>
</li>
<li>
<p><em>year</em>: If non-null, a pointer to the destination for the entry&#8217;s year of modification.</p>
</li>
<li>
<p><em>month</em>: If non-null, a pointer to the destination for the entry&#8217;s month of modification.</p>
</li>
<li>
<p><em>day</em>: If non-null, a pointer to the destination for the entry&#8217;s day of modification.</p>
</li>
<li>
<p><em>hour</em>: If non-null, a pointer to the destination for the entry&#8217;s hour of modification.</p>
</li>
<li>
<p><em>minute</em>: If non-null, a pointer to the destination for the entry&#8217;s minute of modification.</p>
</li>
<li>
<p><em>second</em>: If non-null, a pointer to the destination for the entry&#8217;s second of modification.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_8">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful first directory entry find</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more entries in this directory</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected</p>
</li>
<li>
<p><strong>FX_FILE _CORRUPT</strong> (0x08) File is corrupted</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or destination pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_8">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_8">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA     my_media;
UINT         status;
CHAR         entry_name[FX_MAX_LONG_NAME_LEN];
UINT         attributes;
ULONG        size;
UINT         year;
UINT         month;
UINT         day;
UINT         hour;
UINT         minute;
UINT         second;
/* Get the first directory entry in the default directory with full information. */
status = fx_directory_first_full_entry_find(&amp;my_media, entry_name,
    &amp;attributes, &amp;size, &amp;year, &amp;month, &amp;day, &amp;hour, &amp;minute, &amp;second);

/* If status equals FX_SUCCESS, the entry's information is in the local variables. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_8">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_information_get">fx_directory_information_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets a directory&#8217;s  entry information</p>
</div>
<div class="sect2">
<h3 id="_prototype_9">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_information_get(
    FX_MEDIA *media_ptr,
    CHAR *directory_name,
    UINT *attributes,
    ULONG *size,
    UINT *year, UINT *month, UINT *day,
    UINT *hour, UINT *minute, UINT *second);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_9">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>directory_name</em>: Pointer to name of the directory entry.</p>
</li>
<li>
<p><em>attributes</em>: Pointer to the destination for the attributes.</p>
</li>
<li>
<p><em>size</em>: Pointer to the destination for the size.</p>
</li>
<li>
<p><em>year</em>: Pointer to the destination for the year.</p>
</li>
<li>
<p><em>month</em>: Pointer to the destination for the month.</p>
</li>
<li>
<p><em>day</em>: Pointer to the destination for the day.</p>
</li>
<li>
<p><em>hour</em>: Pointer to the destination for the hour.</p>
</li>
<li>
<p><em>minute</em>: Pointer to the destination for the minute.</p>
</li>
<li>
<p><em>second</em>: Pointer to the destination for the second.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_9">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful first directory entry find</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Specified directory was not found in the media</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media</p>
</li>
<li>
<p><strong>FX_FILE _CORRUPT</strong> (0x08) File is corrupted</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or destination pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_9">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_9">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA     my_media;
UINT         status; attributes; year; month; day;
CHAR         entry_name[FX_MAX_LONG_NAME_LEN];
ULONG        size;
UINT         hour; minute; second;
/* Retrieve information about the directory entry "myfile.txt".*/
status = fx_directory_information_get(&amp;my_media, "myfile.txt", &amp;attributes, &amp;size,
                                      &amp;year, &amp;month, &amp;day,
                                      &amp;hour, &amp;minute, &amp;second);
/* If status equals FX_SUCCESS, the directory entry information is available in the local variables. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_9">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_local_path_clear">fx_directory_local_path_clear</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clears the default local path</p>
</div>
<div class="sect2">
<h3 id="_prototype_10">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_local_path_clear(FX_MEDIA *media_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_8">Description</h3>
<div class="paragraph">
<p>This service clears the previous local path set up for the calling thread.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_10">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a previously opened media.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_10">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful local path clear.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not currently open</p>
</li>
<li>
<p><strong>FX_NOT_IMPLEMENTED</strong> (0x22) FX_NO_LCOAL_PATH is defined</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_10">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_10">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA             my_media;
UINT                 status;
/* Clear the previously setup local path for this media. */
status = fx_directory_local_path_clear(&amp;my_media);

/* If status equals FX_SUCCESS the local path is cleared. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_10">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_local_path_get">fx_directory_local_path_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the current local path string.</p>
</div>
<div class="sect2">
<h3 id="_prototype_11">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_local_path_clear(
    FX_MEDIA *media_ptr,
    CHAR **return_path_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_9">Description</h3>
<div class="paragraph">
<p>This service returns the local path pointer of the specified media. If there is no local path set, a <strong>NULL</strong> is returned to the caller.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_11">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>return_path_name</em>: Pointer to the destination string pointer for the local path string to be stored.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_11">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful local path get.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not currently open</p>
</li>
<li>
<p><strong>FX_NOT_IMPLEMENTED</strong> (0x22) NX_NO_LCOAL_PATH</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_11">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_11">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA         my_media;
CHAR             *my_path;
UINT             status;
/* Retrieve the current local path string. */
status = fx_directory_local_path_get(&amp;my_media, &amp;my_path);

/* If status equals FX_SUCCESS, "my_path" points to the local path string. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_11">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_local_path_restore">fx_directory_local_path_restore</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Restores the previous local path.</p>
</div>
<div class="sect2">
<h3 id="_prototype_12">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_local_path_restore(
    FX_MEDIA *media_ptr,
    FX_LOCAL_PATH *local_path_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_10">Description</h3>
<div class="paragraph">
<p>This service restores a previously set local path. The directory search position made on this local path is also restored, which makes this routine useful in recursive directory traversals by the application.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>Each local path contains a local path string of <strong>FX_MAXIMUM_PATH</strong> in size, which by default is 256 characters. This internal path string is not used by FileX and is provided only for the application&#8217;s use. If <strong>FX_LOCAL_PATH</strong> is going to be declared as a local variable, users should beware of the stack growing by the size of this structure. Users are welcome to reduce the size of <strong>FX_MAXIMUM_PATH</strong> and rebuild the FileX library source.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_12">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>local_path_ptr</em>: Pointer to the previously set local path. It&#8217;s very important to ensure that this pointer does indeed point to a previously used and still intact local path.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_12">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful local path restore.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not currently open.</p>
</li>
<li>
<p><strong>FX_NOT_IMPLEMENTED</strong> (0x22) FX_NO_LCOAL_PATH is defined.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or local path pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_12">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_12">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA                  my_media;
FX_LOCAL_PATH             my_previous_local_path;
UINT                      status;
/* Restore the previous local path. */

status = fx_directory_local_path_restore(&amp;my_media, &amp;my_previous_local_path);
/* If status equals FX_SUCCESS, the previous local path has been restored. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_12">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_local_path_set">fx_directory_local_path_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sets up a thread-specific local path</p>
</div>
<div class="sect2">
<h3 id="_prototype_13">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_local_path_set(
    FX_MEDIA *media_ptr,
    FX_LOCAL_PATH *local_path_ptr,
    CHAR *new_path_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_11">Description</h3>
<div class="paragraph">
<p>This service sets up a thread-specific path as specified by the <em>new_path_string</em>. After successful completion of this routine, the local path information stored in <em>local_path_ptr</em> will take precedence over the global media path for all file and directory operations made by this thread. This will have no impact on any other thread in the system.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>The default size of the local path string is 256 characters; it can be changed by modifying <strong>FX_MAXIMUM_PATH</strong> in <strong>*fx_api.h*</em> and rebuilding the entire FileX library. The character string path is maintained for the application and is not used internally by FileX.</strong>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>For names supplied by the application, FileX supports both backslash (\) and forward slash (/) characters to separate directories, subdirectories, and file names. However, FileX only uses the backslash character in paths returned to the application.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_13">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to the previously opened media.</p>
</li>
<li>
<p><em>local_path_ptr</em>: Destination for holding the thread-specific local path information. The address of this structure may be supplied to the local path restore function in the future.</p>
</li>
<li>
<p><em>new_path_name</em>: Specifies the local path to setup.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_13">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful default directory set.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_IMPLEMENTED</strong> (0x22) <strong>FX_NO_LOCAL_PATH</strong></p>
</li>
<li>
<p><strong>FX_INVALID_PATH</strong> (0x0D) New directory could not be found.</p>
</li>
<li>
<p><strong>FX_NOT_IMPLEMENTED</strong> (0x22)- <strong>FX_NO_LOCAL_PATH</strong> is defined.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or local path pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_13">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_13">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
UINT            status;
FX_LOCAL_PATH   local_path;

/* Set the local path to \abc\def\ghi. */
status = fx_directory_local_path_set(&amp;my_media, &amp;local_path, "\\abc\\def\\ghi");

/* If status equals FX_SUCCESS, the default directory for this thread
is \abc\def\ghi. All subsequent file operations that do not explicitly
specify a path will default to this directory. Note that the character
"\" serves as an escape character in a string. To represent the
character "\", use the construct "\\".*/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_13">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_long_name_get">fx_directory_long_name_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the long name of a directory from its short name.</p>
</div>
<div class="sect2">
<h3 id="_prototype_14">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_long_name_get(
    FX_MEDIA *media_ptr,
    CHAR *short_name,
    CHAR *long_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_12">Description</h3>
<div class="paragraph">
<p>This service retrieves the long name (if any) associated with the supplied short (8.3 format) name. The short name can be either a file name or a directory name.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_14">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>short_name</em>: Pointer to the source short name (8.3 format).</p>
</li>
<li>
<p><em>long_name</em>: Pointer to the destination for the long name. If there is no long name, the short name is returned. Note that the destination for the long name must be large enough to hold <strong>FX_MAX_LONG_NAME_LEN</strong> characters.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_14">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful long name get</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Short name was not found</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or name pointer</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_14">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_14">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA            my_media;
UCHAR               my_long_name[FX_MAX_LONG_NAME_LEN];
/* Retrieve the long name associated with "TEXT~01.TXT". */
status = fx_directory_long_name_get(&amp;my_media, "TEXT~01.TXT", my_long_name);
/* If status is FX_SUCCESS the long name was successfully retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_14">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_long_name_get_extended">fx_directory_long_name_get_extended</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the long name and extended information from short name.</p>
</div>
<div class="sect2">
<h3 id="_prototype_15">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_long_name_get_extended(
    FX_MEDIA *media_ptr,
    CHAR *short_name,
    CHAR *long_name,
    UINT long_file_name_buffer_length);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_13">Description</h3>
<div class="paragraph">
<p>This service retrieves the long name (if any) associated with the supplied short (8.3 format) name. The short name can be either a file name or a directory name.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_15">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>short_name</em>: Pointer to source short name (8.3 format).</p>
</li>
<li>
<p><em>long_name</em>: Pointer to destination for the long name. If there is no long name, the short name is returned. Note: Destination for the long name must be large enough to hold <strong>FX_MAX_LONG_NAME_LEN</strong> characters.</p>
</li>
<li>
<p><em>long_file_name_buffer_length</em>: Length of the long name buffer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_15">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful long name get.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Short name was not found.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or name pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_15">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_15">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
UCHAR           my_long_name[FX_MAX_LONG_NAME_LEN];
/* Retrieve the long name associated with "TEXT~01.TXT". */

status = fx_directory_long_name_get_extended(&amp;my_media,
    "TEXT~01.TXT", my_long_name, sizeof(my_long_name));

/* If status is FX_SUCCESS the long name was successfully retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_15">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_name_test">fx_directory_name_test</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Tests for the specified directory.</p>
</div>
<div class="sect2">
<h3 id="_prototype_16">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_name_test(
    FX_MEDIA *media_ptr,
    CHAR *directory_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_14">Description</h3>
<div class="paragraph">
<p>This service tests whether or not the supplied name is a directory. If so, a <strong>FX_SUCCESS</strong> is returned.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_16">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to the media control block.</p>
</li>
<li>
<p><em>directory_name</em>: Pointer to the name of the directory entry.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_16">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Supplied name is a directory.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Directory entry could not be found.</p>
</li>
<li>
<p><strong>FX_NOT_DIRECTORY</strong> (0x0E)  Entry is not a directory</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or name pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_16">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_16">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
UNIT            status;
/* Check to see if the name "abc" is directory */

status = fx_directory_name_test(&amp;my_media, "abc");

/* If status equals FX_SUCCESS "abc" is a directory. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_16">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_next_entry_find">fx_directory_next_entry_find</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Finds the next directory entry.</p>
</div>
<div class="sect2">
<h3 id="_prototype_17">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_next_entry_find(
    FX_MEDIA *media_ptr,
    CHAR *return_entry_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_15">Description</h3>
<div class="paragraph">
<p>This service returns the next entry name in the current default directory.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>If using a non-local path, it is also important to prevent (with a ThreadX semaphore or thread priority level) other application threads from changing this directory while a directory traversal is taking place. Otherwise, invalid results may be obtained.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_17">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>return_entry_name</em>: Pointer to destination for the next entry name in the default directory. The buffer this pointer points to must be large enough to hold the maximum size of FileX name, defined by <strong>FX_MAX_LONG_NAME_LEN</strong>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_17">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful next entry find</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more entries in this directory.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20)     Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_17">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_17">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
CHAR            next_name[FX_MAX_LONG_NAME_LEN];
UINT            status;

/* Retrieve the next entry in the default directory. */

status = fx_directory_next_entry_find(&amp;my_media, next_name);

/* If status equals TX_SUCCESS, the name of the next directory entry is in "next_name". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_17">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_next_full_entry_find">fx_directory_next_full_entry_find</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the next directory entry with its full information.</p>
</div>
<div class="sect2">
<h3 id="_prototype_18">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_next_full_entry_find(
    FX_MEDIA *media_ptr,
    CHAR *directory_name,
    UINT *attributes,
    ULONG *size,
    UINT *year,
    UINT *month,
    UINT *day,
    UINT *hour,
    UINT *minute,
    UINT *second);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_16">Description</h3>
<div class="paragraph">
<p>This service retrieves the next entry name in the default directory and copies it to the specified destination. It also returns full information about the entry as specified by the additional input parameters.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>The specified destination must be large enough to hold the maximum sized FileX name, as defined by *FX_MAX_LONG_NAME_LEN*</em>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>If using a non-local path, it is important to prevent (with a ThreadX semaphore, mutex, or priority level change) other application threads from changing this directory while a directory traversal is taking place. Otherwise, invalid results may be obtained.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_18">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>directory_name</em>: Pointer to the destination for the name of a directory entry. Must be at least as big as <strong>FX_MAX_LONG_NAME_LEN</strong>.</p>
</li>
<li>
<p><em>attributes</em>: If non-null, pointer to the destination for the entry&#8217;s attributes to be placed.The attributes are returned in a bit-map format with the following possible settings.</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_READ_ONLY</strong> (0x01)</p>
</li>
<li>
<p><strong>FX_HIDDEN</strong> (0x02)</p>
</li>
<li>
<p><strong>FX_SYSTEM</strong> (0x04)</p>
</li>
<li>
<p><strong>FX_VOLUME</strong> (0x08)</p>
</li>
<li>
<p><strong>FX_DIRECTORY</strong> (0x10)</p>
</li>
<li>
<p><strong>FX_ARCHIVE</strong> (0x20)</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>size</em>: If non-null, pointer to the destination for the entry&#8217;s size in bytes.</p>
</li>
<li>
<p><em>month</em>: If non-null, pointer to the destination for the entry&#8217;s month of modification.</p>
</li>
<li>
<p><em>year</em>: If non-null, pointer to the destination for the entry&#8217;s year of modification.</p>
</li>
<li>
<p><em>day</em>: If non-null, pointer to the destination for the entry&#8217;s day of modification.</p>
</li>
<li>
<p><em>hour</em>: If non-null, pointer to the destination for the entry&#8217;s hour of modification.</p>
</li>
<li>
<p><em>minute</em>: If non-null, pointer to the destination for the entry&#8217;s minute of modification.</p>
</li>
<li>
<p><em>second</em>: If non-null, pointer to the destination for the entry&#8217;s second of modification.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_18">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful directory next entry find.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more entries in this directory.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation.</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer or all input parameters are NULL.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_18">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_18">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA    my_media;
UINT        status;
CHAR        entry_name[FX_MAX_LONG_NAME_LEN];
UINT        attributes;
ULONG       size;
UINT        year;
UINT        month;
UINT        day;
UINT        hour;
UINT        minute;
UINT        second;

/* Get the next directory entry in the default directory with full information. */
status = fx_directory_next_full_entry_find(&amp;my_media, entry_name, &amp;attributes, &amp;size,
                                           &amp;year, &amp;month, &amp;day,
                                           &amp;hour, &amp;minute, &amp;second);

/* If status equals FX_SUCCESS, the entry's information is in the local variables. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_18">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_rename">fx_directory_rename</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Renames the specified directory.</p>
</div>
<div class="sect2">
<h3 id="_prototype_19">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_rename(
    FX_MEDIA *media_ptr,
    CHAR *old_directory_name,
    CHAR *new_directory_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_17">Description</h3>
<div class="paragraph">
<p>This service changes the directory name to the specified new directory name. Renaming is also done relative to the specified path or the default path. If a path is specified in the new directory name, the renamed directory is effectively moved to the specified path. If no path is specified, the renamed directory is placed in the current default path.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_19">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>old_directory_name</em>: Pointer to current directory name.</p>
</li>
<li>
<p><em>new_directory_name</em>: Pointer to new directory name.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_19">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful directory rename.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Directory entry could not be found.</p>
</li>
<li>
<p><strong>FX_NOT_DIRECTORY</strong> (0x0E) Entry is not a directory.</p>
</li>
<li>
<p><strong>FX_INVALID_NAME</strong> (0x0C) New directory name is invalid.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation.</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more entries in this directory.</p>
</li>
<li>
<p><strong>FX_INVALID_PATH</strong> (0x0D) Invalid path supplied with directory name.</p>
</li>
<li>
<p><strong>FX_ALREADY_CREATED</strong> (0x0B) Specified directory was already created.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_19">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_19">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA         my_media;
UINT             status;

/* Change the directory "abc" to "def". */
status = fx_directory_rename(&amp;my_media, "abc", "def");

/* If status equals FX_SUCCESS, the directory was changed to "def". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_19">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_short_name_get">fx_directory_short_name_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the specified directory&#8217;s short name from its long name.</p>
</div>
<div class="sect2">
<h3 id="_prototype_20">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_directory_short_name_get(
    FX_MEDIA *media_ptr,
    CHAR *long_name,
    CHAR *short_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_18">Description</h3>
<div class="paragraph">
<p>This service retrieves the short (8.3 format) name associated with the supplied long name. The long name can be either a file name or a directory name.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_20">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>long_name</em>: Pointer to source long name.</p>
</li>
<li>
<p><em>short_name</em>: Pointer to destination short name (8.3 format). Note that the destination for the short name must be large enough to hold 14 characters.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_20">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful short name get.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Long name was not found.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or name pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_20">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_20">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
UCHAR           my_short_name[14];

/* Retrieve the short name associated with "my_really_long_name". */

status = fx_directory_short_name_get(&amp;my_media,
    "my_really_long_name", my_short_name);

/* If status is FX_SUCCESS the short name was successfully retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_20">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_directory_short_name_get_extended">fx_directory_short_name_get_extended</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the specified directory&#8217;s short name from its long name.</p>
</div>
<div class="sect2">
<h3 id="_prototype_21">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">UINT fx_directory_short_name_get_extended(
    FX_MEDIA *media_ptr,
    CHAR *long_name,
    CHAR *short_name,
    UINT short_file_name_length);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_19">Description</h3>
<div class="paragraph">
<p>This service retrieves the short (8.3 format) name associated with the supplied long name. The long name can be either a file name or a directory name.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_21">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>long_name</em>: Pointer to source long name.</p>
</li>
<li>
<p><em>short_name</em>: Pointer to destination short name (8.3 format). Note: Destination for the short name must be large enough to hold 14 characters.</p>
</li>
<li>
<p><em>short_file_name_length</em>: Length of short name buffer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_21">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful short name get.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Long name was not found.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or name pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20)    Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_21">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_21">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
UCHAR           my_short_name[14];

/* Retrieve the short name associated with "my_really_long_name". */

status = fx_directory_short_name_get_extended(&amp;my_media,
    "my_really_long_name", my_short_name, sizeof(my_short_name));

/* If status is FX_SUCCESS the short name was successfully retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_21">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_directory_services">filex directory Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_fault_tolerant_enable">fx_fault_tolerant_enable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Enables the fault tolerant service.</p>
</div>
<div class="sect2">
<h3 id="_prototype_22">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">UINT fx_fault_tolerant_enable(
    FX_MEDIA *media_ptr,
    VOID *memory_buffer,
    UINT memory_size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_20">Description</h3>
<div class="paragraph">
<p>This service enables the fault tolerant module. Upon starting, the fault tolerant module detects whether or not the file system is under FileX fault tolerant protection. If it is not, the service finds available sectors on the file system to store logs on file system transactions. If the file system is under FileX fault tolerant protection, it applies the logs to the file system to maintain its integrity.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_22">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>memory_ptr</em>: Pointer to a block of memory used by the fault tolerant module as scratch memory.</p>
</li>
<li>
<p><em>memory_size</em>: The size of the scratch memory. In order for fault tolerant to work properly, the scratch memory size shall be at least 3072 bytes,- and must be multiple of sector size.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_22">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successfully enabled fault tolerant.</p>
</li>
<li>
<p><strong>FX_NOT_ENOUGH_MEMORY</strong> (0x91)    memory size too small.</p>
</li>
<li>
<p><strong>FX_BOOT_ERROR</strong> (0x01) Boot sector error.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more free cluster available.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) Media associated with this file does not have enough available clusters.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Sector is invalid</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20)    Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_22">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_22">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">/* Declare memory space used for fault tolerant. */

ULONG   fault_tolerant_memory[3072 / sizeof(ULONG)];

/* Enable fault tolerant. */

fx_fault_tolerant_enable(media_ptr, fault_tolerant_memory, sizeof(fault_tolerant_memory));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_22">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_allocate">fx_file_allocate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Allocates space for a file</p>
</div>
<div class="sect2">
<h3 id="_prototype_23">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">UINT fx_file_allocate(
    FX_FILE *file_ptr,
    ULONG size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_21">Description</h3>
<div class="paragraph">
<p>This service allocates and links one or more contiguous clusters to the end of the specified file. FileX determines the number of clusters required by dividing the requested size by the number of bytes per cluster. The result is then rounded up to the next whole cluster.</p>
</div>
<div class="paragraph">
<p>To allocate space beyond 4GB, application shall use the service <strong><em>fx_file_extended_allocate</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_23">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to a previously opened file.</p>
</li>
<li>
<p><em>size</em>: Number of bytes to allocate for the file.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_23">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file allocation.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Specified file is not open for writing.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Failed to read FAT entry.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not currently open.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more free cluster available.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) Media associated with this file does not have enough available clusters.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Sector is invalid</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_23">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_23">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE         my_file;
UINT            status;

/* Allocate 1024 bytes to the end of my_file. */

status = fx_file_allocate(&amp;my_file, 1024);

/* If status equals FX_SUCCESS the file now has one or more
    contiguous cluster(s) that can accommodate at least 1024 bytes of user data. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_23">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_attributes_read">fx_file_attributes_read</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reads a file&#8217;s attributes.</p>
</div>
<div class="sect2">
<h3 id="_prototype_24">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">    UINT fx_file_attributes_read(
    FX_MEDIA *media_ptr,
    CHAR *file_name,
    UINT *attributes_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_22">Description</h3>
<div class="paragraph">
<p>This service reads the file&#8217;s attributes from the specified media.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_24">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>file_name</em>: Pointer to the name of the requested file (directory path is optional).</p>
</li>
<li>
<p><em>attributes_ptr</em>: Pointer to the destination for the file&#8217;s attributes to be placed. The file attributes are returned in a bit-map format with the following possible settings.</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_READ_ONLY</strong> (0x01)</p>
</li>
<li>
<p><strong>FX_HIDDEN</strong> (0x02)</p>
</li>
<li>
<p><strong>FX_SYSTEM</strong> (0x04)</p>
</li>
<li>
<p><strong>FX_VOLUME</strong> (0x08)</p>
</li>
<li>
<p><strong>FX_DIRECTORY</strong> (0x10)</p>
</li>
<li>
<p><strong>FX_ARCHIVE</strong> (0x20)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_24">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful attribute read.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Specified file was not found in the media.</p>
</li>
<li>
<p><strong>FX_NOT_A_FILE</strong> (0x05) Specified file is a directory.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or attributes pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_24">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_24">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA         my_media;
UINT             status;
UINT             attributes;

/* Retrieve the attributes of "myfile.txt" from the specified media. */

status = fx_file_attributes_read(&amp;my_media, "myfile.txt", &amp;attributes);

/* If status equals FX_SUCCESS, "attributes"
    contains the file attributes for "myfile.txt". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_24">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_attributes_set">fx_file_attributes_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sets the specified file&#8217;s attributes.</p>
</div>
<div class="sect2">
<h3 id="_prototype_25">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_attributes_set(
    FX_MEDIA *media_ptr,
    CHAR *file_name,
    UINT attributes);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_23">Description</h3>
<div class="paragraph">
<p>This service sets the file&#8217;s attributes to those specified by the caller.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>The application is only allowed to modify a subset of the file&#8217;s attributes with this service. Any attempt to set additional attributes will result in an error.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_25">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>file_name</em>: Pointer to the name of the requested file** (directory path is optional).</p>
</li>
<li>
<p><em>attributes</em>: The new attributes for the file. The valid file attributes are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_READ_ONLY</strong> (0x01)</p>
</li>
<li>
<p><strong>FX_HIDDEN</strong> (0x02)</p>
</li>
<li>
<p><strong>FX_SYSTEM</strong> (0x04)</p>
</li>
<li>
<p><strong>FX_ARCHIVE</strong> (0x20)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_25">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful attribute set.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) File is open and cannot have its attributes set.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more entries in the FAT table.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Specified file was not found in the media.</p>
</li>
<li>
<p><strong>FX_NOT_A_FILE</strong> (0x05) Specified file is a directory.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Sector is invalid</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer.</p>
</li>
<li>
<p><strong>FX_INVALID_ATTR</strong> (0x19) Invalid attributes selected.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_25">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_25">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA         my_media;
UINT             status;

/* Set the attributes of "myfile.txt" to read-only. */

status = fx_file_attributes_set(&amp;my_media, "myfile.txt", FX_READ_ONLY);

/* If status equals FX_SUCCESS, the file is now read-only. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_25">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_best_effort_allocate">fx_file_best_effort_allocate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Makes its best effort to allocate space for a file.</p>
</div>
<div class="sect2">
<h3 id="_prototype_26">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_best_effort_allocate(
    FX_FILE *file_ptr,
    ULONG size,
    ULONG *actual_size_allocated);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_24">Description</h3>
<div class="paragraph">
<p>This service allocates and links one or more contiguous clusters to the end of the specified file. FileX determines the number of clusters required by dividing the requested size by the number of bytes per cluster. The result is then rounded up to the next whole cluster. If there are not enough consecutive clusters available in the media, this service links the largest available block of consecutive clusters to the file. The amount of space actually allocated to the file is returned to the caller.</p>
</div>
<div class="paragraph">
<p>To allocate space beyond 4GB, application shall use the service <em>fx_file_extended_best_effort_allocate</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_26">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to a previously opened file.</p>
</li>
<li>
<p><em>size</em>: Number of bytes to allocate for the file.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_26">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful best-effort file allocation.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Specified file is not open for writing.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not currently open.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) Media associated with this file does not have enough available clusters.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file pointer or destination.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_26">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_26">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE         my_file;
UINT            status;
ULONG           actual_allocation;

/* Attempt to allocate 1024 bytes to the end of my_file. */

status = fx_file_best_effort_allocate(&amp;my_file, 1024, &amp;actual_allocation);

/* If status equals FX_SUCCESS, the number of bytes
    allocated to the file is found in actual_allocation. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_26">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_close">fx_file_close</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Closes a file.</p>
</div>
<div class="sect2">
<h3 id="_prototype_27">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_close(FX_FILE *file_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_25">Description</h3>
<div class="paragraph">
<p>This service closes the specified file. If the file was open for writing and if it was modified, this service completes the file modification process by updating its directory entry with the new size and the current system time and date.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_27">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to a previously opened file.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_27">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file close.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not open.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or attributes pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_27">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_27">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE     my_file;
UINT        status;

/* Close the previously opened file "my_file". */
status = fx_file_close(&amp;my_file);

/* If status equals FX_SUCCESS, the file was closed successfully. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_27">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_create">fx_file_create</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Creates a file</p>
</div>
<div class="sect2">
<h3 id="_prototype_28">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_create(
    FX_MEDIA *media_ptr,
    CHAR *file_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_26">Description</h3>
<div class="paragraph">
<p>This service creates the specified file in the default directory or in the directory path supplied with the file name.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>This service creates a file of zero length, i.e., no clusters allocated. Allocation will automatically take place on subsequent file writes or can be done in advance with the fx_file_allocate service or fx_file_extended_allocate for space beyond 4GB) service.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_28">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>file_name</em>: Pointer to the name of the file to create (directory path is optional).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_28">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file create.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_ALREADY_CREATED</strong> (0x0B) Specified file was already created.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A)    Either there are no more entries in the root directory or there are no more clusters available.</p>
</li>
<li>
<p><strong>FX_INVALID_PATH</strong> (0x0D) Invalid path supplied with file name.</p>
</li>
<li>
<p><strong>FX_INVALID_NAME</strong> (0x0C) File name is invalid.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A)    No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02)Invalid media.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Underlying media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or file name pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20)    Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_28">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_28">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA         my_media;
UINT             status;

/* Create a file called "myfile.txt" in the
    root or the default directory of the media. */

status = fx_file_create(&amp;my_media, "myfile.txt");

/* If status equals FX_SUCCESS, a zero sized file named "myfile.txt". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_28">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_date_time_set">fx_file_date_time_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sets a file&#8217;s date and time.</p>
</div>
<div class="sect2">
<h3 id="_prototype_29">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_date_time_set(
    FX_MEDIA *media_ptr,
    CHAR *file_name,
    UINT year,
    UINT month,
    UINT day,
    UINT hour,
    UINT minute,
    UINT second);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_27">Description</h3>
<div class="paragraph">
<p>This service sets the date and time of the specified file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA         my_media;
UINT             status;

/* Set the date/time of "my_file". */
status = fx_file_date_time_set(&amp;my_media, "my_file", 1999, 12, 31, 23, 59, 59);

/* If status is FX_SUCCESS the file's date/time was successfully set. /*</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_29">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>file_name</em>: Pointer to name of the file.</p>
</li>
<li>
<p><em>year</em>: Value of year (1980-2107 inclusive).</p>
</li>
<li>
<p><em>month</em>: Value of month (1-12 inclusive).</p>
</li>
<li>
<p><em>day</em>: Value of day (1-31 inclusive).</p>
</li>
<li>
<p><em>hour</em>: Value of hour (0-23 inclusive).</p>
</li>
<li>
<p><em>minute</em>: Value of minute (0-59 inclusive).</p>
</li>
<li>
<p><em>second</em>: Value of second (0-59 inclusive).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_29">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful date/time set.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04)    File was not found.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08)    File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or name pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
<li>
<p><strong>FX_INVALID_YEAR</strong> (0x12) Year is invalid.</p>
</li>
<li>
<p><strong>FX_INVALID_MONTH</strong> (0x13) Month is invalid.</p>
</li>
<li>
<p><strong>FX_INVALID_DAY</strong> (0x14) Day is invalid.</p>
</li>
<li>
<p><strong>FX_INVALID_HOUR</strong> (0x15)    Hour is invalid.</p>
</li>
<li>
<p><strong>FX_INVALID_MINUTE</strong> (0x16) Minute is invalid.</p>
</li>
<li>
<p><strong>FX_INVALID_SECOND</strong> (0x17) Second is invalid.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_29">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_29">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA         my_media;
UINT             status;

/* Set the date/time of "my_file". */
status = fx_file_date_time_set(&amp;my_media, "my_file", 1999, 12, 31, 23, 59, 59);

/* If status is FX_SUCCESS the file's date/time was successfully set. /*</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_29">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_delete">fx_file_delete</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Deletes a file.</p>
</div>
<div class="sect2">
<h3 id="_prototype_30">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_delete(
    FX_MEDIA *media_ptr,
    CHAR *file_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_28">Description</h3>
<div class="paragraph">
<p>This service deletes the specified file.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_30">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>file_name</em>: Pointer to the name of the file to delete (directory path is optional).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_30">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file delete.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Specified file was not found.</p>
</li>
<li>
<p><strong>FX_NOT_A_FILE</strong> (0x05) Specified file name was a directory or volume.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Specified file is currently open.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_30">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_30">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
UINT            status;

/* Delete the file "myfile.txt". */

status = fx_file_delete(&amp;my_media, "myfile.txt");

/* If status equals FX_SUCCESS, "myfile.txt" has been deleted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_30">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_extended_allocate">fx_file_extended_allocate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Allocates space for a file.</p>
</div>
<div class="sect2">
<h3 id="_prototype_31">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_extended_allocate(
    FX_FILE *file_ptr,
    ULONG64 size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_29">Description</h3>
<div class="paragraph">
<p>This service allocates and links one or more contiguous clusters to the end of the specified file. FileX determines the number of clusters required by dividing the requested size by the number of bytes per cluster. The result is then rounded up to the next whole cluster.</p>
</div>
<div class="paragraph">
<p>The <em>size</em> parameter takes a 64-bit integer value, which allows the caller to pre-allocate space beyond 4GB range.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_31">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to a previously opened file.</p>
</li>
<li>
<p><em>size</em>: Number of bytes to allocate for the file.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_31">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file allocation.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Specified file is not open for writing.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not currently open.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) Media associated with this file does not have enough available clusters.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_31">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_31">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE         my_file;
UINT            status;

/* Allocate 0x100000000 bytes to the end of my_file. */

status = fx_file_extended_allocate(&amp;my_file, 0x100000000);

/* If status equals FX_SUCCESS the file now has
    one or more contiguous cluster(s) that can accommodate at least
    1024 bytes of user data. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_31">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_extended_best_effort_allocate">fx_file_extended_best_effort_allocate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Makes the best effort to allocate space for a file.</p>
</div>
<div class="sect2">
<h3 id="_prototype_32">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_extended best_effort_allocate(
    FX_FILE *file_ptr,
    ULONG64 size,
    ULONG64 *actual_size_allocated);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_30">Description</h3>
<div class="paragraph">
<p>This service allocates and links one or more contiguous clusters to the end of the specified file. FileX determines the number of clusters required by dividing the requested size by the number of bytes per cluster. The result is then rounded up to the next whole cluster. If there are not enough consecutive clusters available in the media, this service links the largest available block of consecutive clusters to the file. The amount of space actually allocated to the file is returned to the caller.</p>
</div>
<div class="paragraph">
<p>The <em>size</em> parameter takes a 64-bit integer value, which allows the caller to pre-allocate space beyond 4GB range.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_32">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to a previously opened file.</p>
</li>
<li>
<p><em>size</em>: Number of bytes to allocate for the file.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_32">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file allocation.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Specified file is not open for writing.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not currently open.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) Media associated with this file does not have enough available clusters.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_32">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_32">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE         my_file;
UINT            status;
ULONG64         actual_allocation;

/* Attempt to allocate 0x100000000 bytes to the end of my_file. */

status = fx_file_extended_best_effort_allocate(&amp;my_file,
    0x100000000, &amp;actual_allocation);

/* If status equals FX_SUCCESS, the number of bytes
    allocated to the file is found in actual_allocation. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_32">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_extended_relative_seek">fx_file_extended_relative_seek</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Positions the internal read/write file pointer to a relative byte offset.</p>
</div>
<div class="sect2">
<h3 id="_prototype_33">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_extended_relative_seek(
    FX_FILE *file_ptr,
    ULONG64 byte_offset,
    UINT seek_from);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_31">Description</h3>
<div class="paragraph">
<p>This service positions the internal file read/write pointer to the specified relative byte offset. Any subsequent file read or write request will begin at this location in the file.</p>
</div>
<div class="paragraph">
<p>The <em>byte_offset</em> parameter takes a 64bit integer value, which allows the caller to reposition the read/write pointer beyond 4GB range.</p>
</div>
<div class="paragraph">
<p>If <strong>FX_SEEK_BEGIN</strong> is specified for the <em>seek_from parameter</em>, the seek operation is performed from the beginning of the file. If <strong>FX_SEEK_END</strong> is specified the seek operation is performed backward from the end of the file. If <strong>FX_SEEK_FORWARD</strong> is specified, the seek operation is performed forward from the current file position. If <strong>FX_SEEK_BACK</strong> is specified, the seek operation is performed backward from the current file position.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If the seek operation attempts to seek past the end of the file, the file&#8217;s read/write pointer is positioned to the end of the file. Conversely, if the seek operation attempts to position past the beginning of the file, the file&#8217;s read/write pointer is positioned to the beginning of the file.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_33">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to a previously opened file.</p>
</li>
<li>
<p><em>byte_offset</em>: Desired relative byte offset in file.</p>
</li>
<li>
<p><em>seek_from</em>: The direction and location of where to perform the relative seek from. Valid seek options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SEEK_BEGIN</strong> (0x00)</p>
</li>
<li>
<p><strong>FX_SEEK_END</strong> (0x01)</p>
</li>
<li>
<p><strong>FX_SEEK_FORWARD</strong> (0x02)</p>
</li>
<li>
<p><strong>FX_SEEK_BACK</strong> (0x03)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If FX_SEEK_BEGIN is specified, the seek operation is performed from the beginning of the file. If FX_SEEK_END is specified the seek operation is performed backward from the end of the file. If FX_SEEK_FORWARD is specified, the seek operation is performed forward from the current file position. If FX_SEEK_BACK is specified, the seek operation is performed backward from the current file position.</p>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_33">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file relative seek.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not currently open.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_33">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_33">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE     my_file;
UINT        status;

/* Attempt to seek forward 0x100000000 bytes in "my_file". */

status = fx_file_extended_relative_seek(&amp;my_file, 0x100000000, FX_SEEK_FORWARD);

/* If status equals FX_SUCCESS, the file read/write
    pointers are positioned 0x100000000 bytes forward. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_33">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_extended_seek">fx_file_extended_seek</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Positions the internal read/write pointer to a byte offset.</p>
</div>
<div class="sect2">
<h3 id="_prototype_34">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_extended_seek(
    FX_FILE *file_ptr,
    ULONG64 byte_offset);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_32">Description</h3>
<div class="paragraph">
<p>This service positions the internal file read/write pointer to the specified byte offset. Any subsequent file read or write request will begin at this location in the file.</p>
</div>
<div class="paragraph">
<p>The <em>byte_offset</em> parameter takes a 64bit integer value, which allows the caller to reposition the read/write pointer beyond 4GB range.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_34">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to the file control block.</p>
</li>
<li>
<p><em>byte_offset</em>: Desired byte offset in file. A value of zero will position the read/write pointer at the beginning of the file, while a value greater than the file&#8217;s size will position the read/write pointer at the end of the file.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_34">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file seek.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not open.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_34">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_34">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE         my_file;
UINT            status;

/* Seek to position 0x100000000 of "my_file." */

status = fx_file_extended_seek(&amp;my_file, 0x100000000);

/* If status equals FX_SUCCESS, the file read/write pointer
    is now positioned 0x100000000 bytes from the beginning of the file. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_34">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
<div class="paragraph">
<p>== fx_file_extended_truncate</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Truncates a file.</p>
</div>
</div>
<div class="sect2">
<h3 id="_prototype_35">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_truncate(
    FX_FILE *file_ptr,
    ULONG64 size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_33">Description</h3>
<div class="paragraph">
<p>This service truncates the size of the file to the specified size. If the supplied size is greater than the actual file size, this service doesn&#8217;t do anything. None of the media clusters associated with the file are released.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Use caution truncating files that may also be simultaneously open for reading. Truncating a file also opened for reading can result in reading invalid data.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <em>size</em> parameter takes a 64-bit integer value, which allows the caller to operate beyond 4GB range.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_35">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to the file control block.</p>
</li>
<li>
<p><em>size</em>: New file size. Bytes past this new file size are discarded.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_35">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file truncate.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not open.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Specified file is not open for writing.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Underlying media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_35">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_35">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE         my_file;
UINT            status;

/* Truncate "my_file" to 0x100000000 bytes. */

status = fx_file_extended_truncate(&amp;my_file, 0x100000000);

/* If status equals FX_SUCCESS, "my_file" contains 0x100000000 or fewer bytes. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_35">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_extended_truncate_release">fx_file_extended_truncate_release</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Truncates a file and its releases cluster(s).</p>
</div>
<div class="sect2">
<h3 id="_prototype_36">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_extended_truncate_release(
    FX_FILE *file_ptr,
    ULONG64 size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_34">Description</h3>
<div class="paragraph">
<p>This service truncates the size of the file to the specified size. If the supplied size is greater than the actual file size, this service does not do anything. Unlike the <strong><em>fx_file_extended_truncate</em></strong> service, this service does release any unused clusters.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Use caution truncating files that may also be simultaneously open for reading. Truncating a file also opened for reading can result in reading invalid data.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <em>size</em> parameter takes a 64-bit integer value, which allows the caller to operate beyond 4GB range.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_36">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to a previously opened file.</p>
</li>
<li>
<p><em>size</em>: New file size. Bytes past this new file size are discarded.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_36">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file truncate.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Specified file is not open for writing.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not currently open.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_36">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_36">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE         my_file;
UINT            status;

/* Attempt to truncate everything after the first 0x100000000 bytes of "my_file". */

status = fx_file_extended_truncate_release(&amp;my_file, 0x100000000);

/* If status equals FX_SUCCESS, the file is now 0x100000000
    bytes or fewer and all unused clusters have been released. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_36">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_open">fx_file_open</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Opens a file.</p>
</div>
<div class="sect2">
<h3 id="_prototype_37">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_open(
    FX_MEDIA *media_ptr,
    FX_FILE *file_ptr,
    CHAR *file_name,
    UINT open_type);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_35">Description</h3>
<div class="paragraph">
<p>This service opens the specified file for either reading or writing. A file may be opened for reading multiple times, while a file can only be opened for writing once until the writer closes the file.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>Care must be taken if a file is concurrently open for reading and writing. File writing performed when a file is simultaneously opened for reading may not be seen by the reader, unless the reader closes and reopens the file for reading. Similarly, the file writer should be careful when using file truncate services. If a file is truncated by the writer, readers of the same file could return invalid data.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Opening files with <strong>FX_OPEN_FOR_READ</strong> and <strong>FX_OPEN_FOR_READ_FAST</strong> is similar, but not the same. <strong>FX_OPEN_FOR_READ</strong> includes verification that the linked list of the clusters that comprise the file are intact, while <strong>FX_OPEN_FOR_READ_FAST</strong> does not perform this verification.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_37">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>file_ptr</em>: Pointer to the file control block.</p>
</li>
<li>
<p><em>file_name</em>: Pointer to the name of the file to open (directory path is optional).</p>
</li>
<li>
<p><em>open_type</em>: Type of file open. Valid open type options are the following.</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_OPEN_FOR_READ</strong> (0x00)</p>
</li>
<li>
<p><strong>FX_OPEN_FOR_WRITE</strong> (0x01)</p>
</li>
<li>
<p><strong>FX_OPEN_FOR_READ_FAST</strong> (0x02)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_37">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file open.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Specified file was not found.</p>
</li>
<li>
<p><strong>FX_NOT_A_FILE</strong> (0x05) Specified file name was a directory or volume.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) Specified file is corrupt and the open failed.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Specified file is already open or open type is invalid.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Invalid media.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Underlying media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or file pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20)    Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_37">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_37">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA    my_media;
FX_FILE     my_file;
UINT        status;

/* Open the file "myfile.txt" for reading. */

status = fx_file_open(&amp;my_media, &amp;my_file, "myfile.txt", FX_OPEN_FOR_READ);

/* If status equals FX_SUCCESS, file "myfile.txt" is now
    open and may be accessed now with the my_file pointer. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_37">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_read">fx_file_read</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reads bytes from the specified file.</p>
</div>
<div class="sect2">
<h3 id="_prototype_38">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_read(
    FX_FILE *file_ptr,
    VOID *buffer_ptr,
    ULONG request_size,
    ULONG *actual_size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_36">Description</h3>
<div class="paragraph">
<p>This service reads bytes from the file and stores them in the supplied buffer. After the read is complete, the file&#8217;s internal read pointer is adjusted to point at the next byte in the file. If there are fewer bytes remaining in the request, only the bytes remaining are stored in the buffer. In any case, the total number of bytes placed in the buffer is returned to the caller.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>The application must ensure that the buffer supplied is able to store the specified number of requested bytes.</em>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Faster performance is achieved if the destination buffer is on a long-word boundary and the requested size is evenly divisible by sizeof(<strong>ULONG</strong>).</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_38">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to the file control block.</p>
</li>
<li>
<p><em>buffer_ptr</em>: Pointer to the destination buffer for the read.</p>
</li>
<li>
<p><em>request_size</em>: Maximum number of bytes to read.</p>
</li>
<li>
<p><em>actual_size</em>: Pointer to the variable to hold the actual number of bytes read into the supplied buffer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_38">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file read.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not open.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) Specified file is corrupt and the read failed.</p>
</li>
<li>
<p><strong>FX_END_OF_FILE</strong> (0x09) End of file has been reached.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file or buffer pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_38">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_38">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE                 my_file;
unsigned char           my_buffer[1024];
ULONG                   actual_bytes;
UINT                    status;

/* Read up to 1024 bytes into "my_buffer." */
status = fx_file_read(&amp;my_file, my_buffer, 1024, &amp;actual_bytes);

/* If status equals FX_SUCCESS, "my_buffer" contains the bytes
    read from the file. The total number of bytes read is in "actual_bytes." */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_38">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_relative_seek">fx_file_relative_seek</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Positions the internal read/write pointer to a relative byte offset.</p>
</div>
<div class="sect2">
<h3 id="_prototype_39">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_relative_seek(
    FX_FILE *file_ptr,
    ULONG byte_offset,
    UINT seek_from);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_37">Description</h3>
<div class="paragraph">
<p>This service positions the internal file read/write pointer to the specified relative byte offset. Any subsequent file read or write request will begin at this location in the file.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>If the seek operation attempts to seek past the end of the file, the file&#8217;s read/write pointer is positioned to the end of the file. Conversely, if the seek operation attempts to position past the beginning of the file, the file&#8217;s read/write pointer is positioned to the beginning of the file.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To seek with an offset value beyond 4GB, application shall use the service <em>fx_file_extended_relative_seek</em>.</p>
</div>
<div class="paragraph">
<p>If <strong>FX_SEEK_BEGIN</strong> is specified in the <em>seek-from</em> parameter, the seek operation is performed from the beginning of the file. If <strong>FX_SEEK_END</strong> is specified the seek operation is performed backward from the end of the file. If <strong>FX_SEEK_FORWARD</strong> is specified, the seek operation is performed forward from the current file position. If <strong>FX_SEEK_BACK</strong> is specified, the seek operation is performed backward from the current file position.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_39">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to a previously opened file.</p>
</li>
<li>
<p><em>byte_offset</em>: Desired relative byte offset in file.</p>
</li>
<li>
<p><em>seek_from</em>: The direction and location of where to perform the relative seek from. Valid seek options are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SEEK_BEGIN</strong> (0x00)</p>
</li>
<li>
<p><strong>FX_SEEK_END</strong> (0x01)</p>
</li>
<li>
<p><strong>FX_SEEK_FORWARD</strong> (0x02)</p>
</li>
<li>
<p><strong>FX_SEEK_BACK</strong> (0x03)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_39">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file relative seek.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not currently open.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_39">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_39">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE     my_file;
UINT        status;

/* Attempt to move 10 bytes forward in "my_file". */

status = fx_file_relative_seek(&amp;my_file, 10, FX_SEEK_FORWARD);

/* If status equals FX_SUCCESS, the file read/write pointers
    are positioned 10 bytes forward. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_39">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_rename">fx_file_rename</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Renames a file.</p>
</div>
<div class="sect2">
<h3 id="_prototype_40">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_rename(
    FX_MEDIA *media_ptr,
    CHAR *old_file_name,
    CHAR *new_file_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_38">Description</h3>
<div class="paragraph">
<p>This service changes the name of the file specified by <em>old_file_name</em>. Renaming is also done relative to the specified path or the default path. If a path is specified in the new file name, the renamed file is effectively moved to the specified path. If no path is specified, the renamed file is placed in the current default path.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_40">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a media control block.</p>
</li>
<li>
<p><em>old_file_name</em>: Pointer to a character string containing the name of the file to rename (directory path is optional).</p>
</li>
<li>
<p><em>new_file_name</em>: Pointer to the new file name. The directory path is not allowed.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_40">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file rename.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04)    Specified file was not found.</p>
</li>
<li>
<p><strong>FX_NOT_A_FILE</strong> (0x05) Specified file is a directory.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Specified file is already open.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23)    Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_INVALID_NAME</strong> (0x0C) Specified new file name is not a valid file name.</p>
</li>
<li>
<p><strong>FX_INVALID_PATH</strong> (0x0D)    Path is invalid.</p>
</li>
<li>
<p><strong>FX_ALREADY_CREATED</strong> (0x0B) The new file name is used.</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02)    Media is invalid.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT table.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_40">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_40">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA         my_media;
UINT             status;

/* Rename "myfile1.txt" to "myfile2.txt" in the default directory of the media. */

status = fx_file_rename(&amp;my_media, "myfile1.txt", "myfile2.txt");

/* If status equals FX_SUCCESS, the file was successfully renamed. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_40">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_seek">fx_file_seek</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Positions the internal read/write pointer to a byte offset.</p>
</div>
<div class="sect2">
<h3 id="_prototype_41">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_seek(
    FX_FILE *file_ptr,
    ULONG byte_offset);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_39">Description</h3>
<div class="paragraph">
<p>This service positions the internal file read/write pointer to the specified byte offset. Any subsequent file read or write request will begin at this location in the file.</p>
</div>
<div class="paragraph">
<p>To seek with an offset value beyond 4GB, application shall use the service <strong><em>fx_file_extended_seek</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_41">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to the file control block.</p>
</li>
<li>
<p><em>byte_offset</em>: Desired byte offset in file. A value of zero will position the read/write pointer at the beginning of the file, while a value greater than the file&#8217;s size will position the read/write pointer at the end of the file.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_41">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file seek.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not open.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_41">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_41">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE         my_file;
UINT            status;

/* Seek to the beginning of "my_file." */
status = fx_file_seek(&amp;my_file, 0);

/* If status equals FX_SUCCESS, the file read/write pointer
    is now positioned to the beginning of the file. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_41">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_truncate">fx_file_truncate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Truncates a file to a specified number of bytes.</p>
</div>
<div class="sect2">
<h3 id="_prototype_42">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_truncate(
    FX_FILE *file_ptr,
    ULONG size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_40">Description</h3>
<div class="paragraph">
<p>This service truncates the size of the file to the specified size. If the supplied size is greater than the actual file size, this service doesn&#8217;t do anything. None of the media clusters associated with the file are released.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Use caution truncating files that may also be simultaneously open for reading. Truncating a file also opened for reading can result in reading invalid data.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To operate beyond 4GB, application shall use the service <strong><em>fx_file_extended_truncate</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_42">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to the file control block.</p>
</li>
<li>
<p><em>size</em>: New file size. Bytes past this new file size are discarded.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_42">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file truncate.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not open.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Specified file is not open for writing.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space to complete the operation</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_42">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_42">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE     my_file;
UINT        status;

/* Truncate "my_file" to 100 bytes. */

status = fx_file_truncate(&amp;my_file, 100);

/* If status equals FX_SUCCESS, "my_file" contains 100 or fewer bytes. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_42">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_truncate_release">fx_file_truncate_release</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Truncates a file and releases its cluster(s).</p>
</div>
<div class="sect2">
<h3 id="_prototype_43">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_truncate(
    FX_FILE *file_ptr,
    ULONG size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_41">Description</h3>
<div class="paragraph">
<p>This service truncates the size of the file to the specified size. If the supplied size is greater than the actual file size, this service does not do anything. Unlike the <strong><em>fx_file_truncate</em></strong> service, this service does release any unused clusters.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Use caution truncating files that may also be simultaneously open for reading. Truncating a file also opened for reading can result in reading invalid data.</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To operate beyond 4GB, application shall use the service <strong><em>fx_file_extended_truncate_release</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_43">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to a previously opened file.</p>
</li>
<li>
<p><em>size</em>: New file size. Bytes past this new file size are discarded.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_43">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file truncate.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Specified file is not open for writing.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not currently open.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90)    Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Underlying media is write protected.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08)    File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A)    No more space to complete the operation.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_43">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_43">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE         my_file;
UINT            status;

/* Attempt to truncate everything after the first 100 bytes of "my_file". */

status = fx_file_truncate_release(&amp;my_file, 100);

/* If status equals FX_SUCCESS, the file is now 100 bytes
    or fewer and all unused clusters have been released. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_43">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_write">fx_file_write</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Writes bytes to a file.</p>
</div>
<div class="sect2">
<h3 id="_prototype_44">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_write(
    FX_FILE *file_ptr,
    VOID *buffer_ptr,
    ULONG size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_42">Description</h3>
<div class="paragraph">
<p>This service writes bytes from the specified buffer starting at the file&#8217;s current position. After the write is complete, the file&#8217;s internal read pointer is adjusted to point at the next byte in the file.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Faster performance is achieved if the source buffer is on a long-word boundary and the requested size is evenly divisible by sizeof(<strong>ULONG</strong>).</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_44">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to the file control block.</p>
</li>
<li>
<p><em>buffer_ptr</em>: Pointer to the source buffer for the write.</p>
</li>
<li>
<p><em>size</em>: Number of bytes to write.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_44">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file write.</p>
</li>
<li>
<p><strong>FX_NOT_OPEN</strong> (0x07) Specified file is not open.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Specified file is not open for writing.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) There is no more room available in the media to perform this write.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT entry.</p>
</li>
<li>
<p><strong>FX_NO_MORE_ENTRIES</strong> (0x0F) No more FAT entries.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid file or buffer pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_44">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_44">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_FILE         my_file;
UINT            status;

/* Write a 10 character buffer to "my_file." */

status = fx_file_write(&amp;my_file, "1234567890", 10);

/* If status equals FX_SUCCESS, the small text string was written out to the file. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_44">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_file_write_notify_set">fx_file_write_notify_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sets the file write notify callback function.</p>
</div>
<div class="sect2">
<h3 id="_prototype_45">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_file_write_notify_set(
    FX_FILE *file_ptr,
    VOID (*file_write_notify)(FX_FILE*));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_43">Description</h3>
<div class="paragraph">
<p>This service installs callback function that is invoked after a successful file write operation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_45">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>file_ptr</em>: Pointer to the file control block.</p>
</li>
<li>
<p><em>file_write_notify</em>: File write callback function to be installed. Set the callback function to <strong>NULL</strong> disables the callback function.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_45">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successfully installed the callback function.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) file_ptr is <strong>NULL</strong>.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_45">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_45">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">fx_file_write_notify_set(file_ptr, my_file_close_callback);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_45">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_file_services">filex file Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_abort">fx_media_abort</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Aborts all current activities on the specified media</p>
</div>
<div class="sect2">
<h3 id="_prototype_46">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_abort(FX_MEDIA *media_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_44">Description</h3>
<div class="paragraph">
<p>This service aborts all current activities associated with the media, including closing all open files, sending an abort request to the associated driver, and placing the media in an aborted state. This service is typically called when I/O errors are detected.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>The media must be re-opened to use it again after an abort operation is performed.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_46">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_46">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media abort.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_46">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_46">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA    my_media;
UINT        status;

/* Abort all activity associated with "my_media". */

status = fx_media_abort(&amp;my_media);

/* If status equals FX_SUCCESS, all activity
    associated with the media has been aborted. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_46">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_cache_invalidate">fx_media_cache_invalidate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Invalidates a logical sector cache.</p>
</div>
<div class="sect2">
<h3 id="_prototype_47">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_cache_invalidate(FX_MEDIA *media_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_45">Description</h3>
<div class="paragraph">
<p>This service flushes all dirty sectors in the cache and then invalidates the entire logical sector cache.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_47">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_47">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media cache invalidate.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or scratch pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_47">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_47">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA     my_media;

/* Invalidate the cache of the media. */
status = fx_media_cache_invalidate(&amp;my_media);

/* If status is FX_SUCCESS the cache in the media
    was successfully flushed and invalidated. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_47">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_check">fx_media_check</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Checks the specified media for errors.</p>
</div>
<div class="sect2">
<h3 id="_prototype_48">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_check(
    FX_MEDIA *media_ptr,
    UCHAR *scratch_memory_ptr,
    ULONG scratch_memory_size,
    ULONG error_correction_option,
    ULONG *errors_detected_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_46">Description</h3>
<div class="paragraph">
<p>This service checks the specified media for basic structural errors, including file/directory cross-linking, invalid FAT chains, and lost clusters. This service also provides the capability to correct detected errors.</p>
</div>
<div class="paragraph">
<p>The fx_media_check service requires scratch memory for its depth-first analysis of directories and files in the media. Specifically, the scratch memory supplied to the media check service must be large enough to hold several directory entries, a data structure to "stack" the current directory entry position before entering into subdirectories, and finally the logical FAT bit map. The scratch memory should be at least 512-1024 bytes plus memory for the logical FAT bit map, which requires as many bits as there are clusters in the media. For example, a device with 8000 clusters would require 1000 bytes to represent and thus require a total scratch area on the order of 2048 bytes.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>This service should only be called immediately after fx_media_open and without any other file system activity.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_48">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>scratch_memory_ptr</em>: Pointer to the start of scratch memory.</p>
</li>
<li>
<p><em>scratch_memory_size</em>: Size of scratch memory in bytes.</p>
</li>
<li>
<p><em>error_correction_option</em>: Error correction option bits, when the bit is set, error correction is performed. The error correction option bits are defined as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_FAT_CHAIN_ERROR</strong> (0x01)</p>
</li>
<li>
<p><strong>FX_DIRECTORY_ERROR</strong> (0x02)</p>
</li>
<li>
<p><strong>FX_LOST_CLUSTER_ERROR</strong> (0x04)
Simply OR together the required error correction options. If no error correction is required, a value of 0 should be supplied.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>errors_detected_ptr</em>: Destination for error detection bits, as defined below:</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_FAT_CHAIN_ERROR</strong> (0x01)</p>
</li>
<li>
<p><strong>FX_DIRECTORY_ERROR</strong> (0x02)</p>
</li>
<li>
<p><strong>FX_LOST_CLUSTER_ERROR</strong> (0x04)</p>
</li>
<li>
<p><strong>FX_FILE_SIZE_ERROR</strong> (0x08)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_48">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media check, view the errors detected destination for details.</p>
</li>
<li>
<p><strong>FX_ACCESS_ERROR</strong> (0x06) Unable to perform check with open files.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more space on the media.</p>
</li>
<li>
<p><strong>FX_NOT_ENOUGH_MEMORY</strong> (0x91) Supplied scratch memory is not large enough.</p>
</li>
<li>
<p><strong>FX_ERROR_NOT_FIXED</strong> (0x93) Corruption of FAT32 root directory that could not be fixed.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Sector is invalid.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or scratch pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_48">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_48">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
ULONG           detected_errors;
UCHAR           sratch_memory[4096];

/* Check the media and correct all errors. */

status = fx_media_check(&amp;my_media, sratch_memory, 4096,
                        FX_FAT_CHAIN_ERROR |
                        FX_DIRECTORY_ERROR |
                        FX_LOST_CLUSTER_ERROR, &amp;detected_errors);

/* If status is FX_SUCCESS and detected_errors is 0,
    the media was successfully checked and found to be error free. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_48">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_close">fx_media_close</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Closes the specified media.</p>
</div>
<div class="sect2">
<h3 id="_prototype_49">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_close(FX_MEDIA *media_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_47">Description</h3>
<div class="paragraph">
<p>This service closes the specified media. In the process of closing the media, all open files are closed and any remaining buffers are flushed to the physical media.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_49">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_49">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media close.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong>    (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_49">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_49">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA    my_media;
UINT        status;
/* Close "my_media". */

status = fx_media_close(&amp;my_media);

/* If status equals FX_SUCCESS, "my_media" is closed. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_49">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_close_notify_set">fx_media_close_notify_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sets the media close-notification callback function.</p>
</div>
<div class="sect2">
<h3 id="_prototype_50">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_close_notify_set(
    FX_MEDIA *media_ptr,
    VOID (*media_close_notify)(FX_MEDIA*));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_48">Description</h3>
<div class="paragraph">
<p>This service sets a notify callback function which will be invoked after a media is successfully closed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_50">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>media_close_notify</em>: Media close notify callback function to be installed. Passing NULL as the callback function disables the media close callback.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_50">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successfully installed the callback function.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) media_ptr is NULL.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong>    (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_50">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_50">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">fx_media_close_notify_set(media_ptr, my_media_close_callback);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_50">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_extended_space_available">fx_media_extended_space_available</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Returns the available media space.</p>
</div>
<div class="sect2">
<h3 id="_prototype_51">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_extended_space_available(
    FX_MEDIA *media_ptr,
    ULONG64 *available_bytes_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_49">Description</h3>
<div class="paragraph">
<p>This service returns the number of bytes available in the media.</p>
</div>
<div class="paragraph">
<p>The pointer to <em>available_bytes</em> parameter takes a 64-bit integer value, which allows the caller to work with media beyond 4GB range.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_51">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a previously opened media.</p>
</li>
<li>
<p><em>available_bytes_ptr</em>: Available bytes left in the media.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_51">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successfully retrieved space available on the media.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer or available bytes pointer is NULL.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong>    (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_51">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_51">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
ULONG64         available_bytes;
UINT            status;

/* Retrieve the available bytes in the media. */

status = fx_media_extended_space_available(&amp;my_media, &amp;available_bytes);

/* If status equals FX_SUCCESS, the number of available bytes is in "available_bytes." */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_51">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_flush">fx_media_flush</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Flushes all cached data to the physical media</p>
</div>
<div class="sect2">
<h3 id="_prototype_52">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_flush(FX_MEDIA *media_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_50">Description</h3>
<div class="paragraph">
<p>This service flushes all cached sectors and directory entries of any modified files to the physical media.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>This routine may be called periodically by the application to reduce the risk of file corruption and/or data loss in the event of a sudden loss of power on the target.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_52">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_52">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media flush.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong>    (0x08) File is corrupted.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong>    (0x20)    Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_52">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_52">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA         my_media;
UINT             status;

/* Flush all cached sectors and modified file entries to the physical media. */

status = fx_media_flush(&amp;my_media);

/* If status equals FX_SUCCESS, the physical media is completely up-to-date. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_52">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_format">fx_media_format</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Formats the specified media.</p>
</div>
<div class="sect2">
<h3 id="_prototype_53">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_format(
    FX_MEDIA *media_ptr,
    VOID (*driver)(FX_MEDIA *media),
    VOID *driver_info_ptr,
    UCHAR *memory_ptr,
    UINT memory_size,
    CHAR *volume_name,
    UINT number_of_fats,
    UINT directory_entries,
    UINT hidden_sectors,
    ULONG total_sectors,
    UINT bytes_per_sector,
    UINT sectors_per_cluster,
    UINT heads,
    UINT sectors_per_track);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_51">Description</h3>
<div class="paragraph">
<p>This service formats the supplied media in a FAT 12/16/32 compatible manner based on the supplied parameters. This service must be called prior to opening the media.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Formatting an already formatted media effectively erases all files and directories on the media.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_53">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block. This is used only to provide some basic information necessary for the driver to operate.</p>
</li>
<li>
<p><em>driver</em>: Pointer to the I/O driver for this media. This will typically be the same driver supplied to the subsequent fx_media_open call.</p>
</li>
<li>
<p><em>driver_info_ptr</em>: Pointer to optional information that the I/O driver may utilize.</p>
</li>
<li>
<p><em>memory_ptr</em>: Pointer to the working memory for the media.</p>
</li>
<li>
<p><em>memory_size</em>: Specifies the size of the working media memory. The size must be at least as large as the media&#8217;s sector size.</p>
</li>
<li>
<p><em>volume_name</em>: Pointer to the volume name string, which is a maximum of 11 characters.</p>
</li>
<li>
<p><em>number_of_fats</em>: Number of FATs in the media. The minimal value is 1 for the primary FAT. Values greater than 1 result in additional FAT copies being maintained at run-time.</p>
</li>
<li>
<p><em>directory_entries</em>: Number of directory entries in the root directory.</p>
</li>
<li>
<p><em>hidden_sectors</em>: Number of sectors hidden before this media&#8217;s boot sector. This is typical when multiple partitions are present.</p>
</li>
<li>
<p><em>total_sectors</em>: Total number of sectors in the media.</p>
</li>
<li>
<p><strong>bytes_per_sector</strong>*: Number of bytes per sector, which is typically 512. FileX requires this to be a multiple of 32.</p>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>With reference to the specification, the bytes per sector may take on only the following values: 512, 1024, 2048 or 4096.</em>
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_54">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to the media control block. This is used only to provide some basic information necessary for the driver to operate.</p>
</li>
<li>
<p><em>driver</em>: Pointer to the I/O driver for this media. This will typically be the same driver supplied to the subsequent fx_media_open call.</p>
</li>
<li>
<p><em>driver_info_ptr</em>: Pointer to the optional information that the I/O driver may utilize.</p>
</li>
<li>
<p><em>memory_ptr</em>: Pointer to the working memory for the media.</p>
</li>
<li>
<p><em>memory_size</em>: Specifies the size of the working media memory. The size must be at least as large as the media&#8217;s sector size.</p>
</li>
<li>
<p><em>volume_name</em>: Pointer to the volume name string, which is a maximum of 11 characters.</p>
</li>
<li>
<p><em>number_of_fats</em>: Number of FATs in the media. The minimal value is 1 for the primary FAT. Values greater than 1 result in additional FAT copies being maintained at run-time.</p>
</li>
<li>
<p><em>directory_entries</em>: Number of directory entries in the root directory.</p>
</li>
<li>
<p><em>hidden_sectors</em>: Number of sectors hidden before this media&#8217;s boot sector. This is typical when multiple partitions are present.</p>
</li>
<li>
<p><em>total_sectors</em>: Total number of sectors in the media.</p>
</li>
<li>
<p><em>bytes_per_sector</em>: Number of bytes per sector, which is typically 512. FileX requires this to be a multiple of 32.</p>
</li>
<li>
<p><em>sectors_per_cluster</em>: Number of sectors in each cluster. The cluster is the minimum allocation unit in a FAT file system.</p>
</li>
<li>
<p><em>heads</em>: Number of physical heads.</p>
</li>
<li>
<p><em>sectors_per_track</em>: Number of sectors per track.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_53">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media format.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media, driver, or memory pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong>    (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_53">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_53">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        ram_disk;
UCHAR           media_memory[512];
UCHAR           ram_disk_memory[32768];

/* Format a RAM disk with 32768 bytes and 512 bytes per sector. */

status = fx_media_format(&amp;ram_disk, _fx_ram_driver,
                         ram_disk_memory, media_memory,
                         sizeof(media_memory),
                         "MY_RAM_DISK" /* Volume Name */,
                         1 /* Number of FATs */,
                         32 /* Directory Entries */,
                         0 /* Hidden sectors */,
                         64 /* Total sectors */,
                         512 /* Sector size */,
                         1 /* Sectors per cluster */,
                         1 /* Heads */,
                         1 /* Sectors per track */);

/* If status is FX_SUCCESS, the media was successfully formatted
    and can now be opened with the following call: */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_53">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_open">fx_media_open</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Opens the specified media for file access.</p>
</div>
<div class="sect2">
<h3 id="_prototype_54">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_open(
    FX_MEDIA *media_ptr,
    CHAR *media_name,
    VOID(*media_driver)(FX_MEDIA *),
    VOID *driver_info_ptr,
    VOID *memory_ptr,
    ULONG memory_size);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_52">Description</h3>
<div class="paragraph">
<p>This service opens a media for file access using the supplied I/O driver.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>The memory supplied to this service is used to implement an internal logical sector cache, hence, the more memory supplied the more physical I/O is reduced. FileX requires a cache of at least one logical sector (bytes per sector of the media).</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_55">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>media_name</em>: Pointer to media&#8217;s name.</p>
</li>
<li>
<p><em>media_driver</em>: Pointer to I/O driver for this media. The I/O driver must conform to FileX driver requirements defined in Chapter 5.</p>
</li>
<li>
<p><em>driver_info_ptr</em>: Pointer to optional information that the supplied I/O driver may utilize.</p>
</li>
<li>
<p><em>memory_ptr</em>: Pointer to the working memory for the media.</p>
</li>
<li>
<p><em>memory_size</em>: Specifies the size of the working media memory. The size must be as large as the media&#8217;s sector size (typically 512 bytes).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_54">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media open.</p>
</li>
<li>
<p><strong>FX_BOOT_ERROR</strong> (0x01) Error reading the media&#8217;s boot sector.</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Specified media&#8217;s boot sector is corrupt or invalid. In addition, this return code is used to indicate that either the logical sector cache size or the FAT entry size is not a power of 2.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Error reading the media FAT.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) One or more pointers are NULL.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20)    Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_54">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_54">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        ram_disk,
UINT            status;
UCHAR           buffer[128];
/* Open a 32KByte RAM disk starting at the fixed address of 0x800000.
    Note that the total 32KByte media size and 128-byte sector size is defined inside of the driver. */

status = fx_media_open(&amp;ram_disk, "RAM DISK", fx_ram_driver, 0, &amp;buffer[0], sizeof(buffer));

/* If status equals FX_SUCCESS, the RAM disk has been successfully setup and is ready for file access! */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_54">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_open_notify_set">fx_media_open_notify_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sets the media open-notification callback function.</p>
</div>
<div class="sect2">
<h3 id="_prototype_55">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_open_notify_set(
    FX_MEDIA *media_ptr,
    VOID (*media_open_notify)(FX_MEDIA*));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_53">Description</h3>
<div class="paragraph">
<p>This service sets a notification callback function which will be invoked after a media is successfully opened.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_56">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to the media control block.</p>
</li>
<li>
<p><em>media_open_notify</em>: Media open-notification callback function to be installed. Passing <strong>NULL</strong> as the callback function disables the media open callback.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_55">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successfully installed the callback function.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) media_ptr is <strong>NULL</strong>.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong>    (0x20)    Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_55">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_55">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">fx_media_open_notify_set(media_ptr, my_media_open_callback);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_55">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_read">fx_media_read</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reads a logical sector from the media.</p>
</div>
<div class="sect2">
<h3 id="_prototype_56">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_read(
    FX_MEDIA *media_ptr,
    ULONG logical_sector,
    VOID *buffer_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_54">Description</h3>
<div class="paragraph">
<p>This service reads a logical sector from the media and places it into the supplied buffer.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_57">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a previously-opened media.</p>
</li>
<li>
<p><em>logical_sector</em>: Logical sector to read.</p>
</li>
<li>
<p><em>buffer_ptr</em>: Pointer to the destination for the logical sector read.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_56">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media read.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or buffer pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20)    Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_56">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_56">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
UCHAR           my_buffer[128];
UINT            STATUS;
/* Read logical sector 22 into "my_buffer" assuming the
    physical media has a sector size of 128. */
status = fx_media_read(&amp;my_media, 22, my_buffer);
/* If status equals FX_SUCCESS, the contents of logical sector 22 are in "my_buffer". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_56">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_space_available">fx_media_space_available</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Returns the available media space in bytes.</p>
</div>
<div class="sect2">
<h3 id="_prototype_57">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_space_available(
    FX_MEDIA *media_ptr,
    ULONG *available_bytes_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_55">Description</h3>
<div class="paragraph">
<p>This service returns the number of bytes available in the media.</p>
</div>
<div class="paragraph">
<p>To work with the media larger than 4GB, application shall use the service <strong><em>fx_media_extended_space_available</em></strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_58">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a previously-opened media.</p>
</li>
<li>
<p><em>available_bytes_ptr</em>: Available bytes left in the media.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_57">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successfully returned available space on media.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer or available bytes pointer is NULL.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong>    (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_57">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_57">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
ULONG           available_bytes;
UINT            status;

/* Retrieve the available bytes in the media. */

status = fx_media_space_available(&amp;my_media, &amp;available_bytes);

/* If status equals FX_SUCCESS, the number of available bytes is in "available_bytes." */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_57">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_volume_get">fx_media_volume_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the media&#8217;s volume name.</p>
</div>
<div class="sect2">
<h3 id="_prototype_58">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_volume_get(
    FX_MEDIA *media_ptr,
    CHAR *volume_name,
    UINT volume_source);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_56">Description</h3>
<div class="paragraph">
<p>This service retrieves the volume name of the previously-opened media.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_59">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to the media control block.</p>
</li>
<li>
<p><em>volume_name</em>: Pointer to destination for volume name. Note that the destination must be at least large enough to hold 12 characters.</p>
</li>
<li>
<p><em>volume_source</em>: Designates where to retrieve the name, either from the boot sector or the root directory. Valid values for this parameter are:</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_BOOT_SECTOR</strong></p>
</li>
<li>
<p><strong>FX_DIRECTORY_SECTOR</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_58">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media volume get.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Volume not found.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or volume destination pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_58">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_58">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        ram_disk;
UCHAR           volume_name[12];
UINT            status;

/* Retrieve the volume name of the RAM disk, from the boot sector. */

status = fx_media_volume_get_extended(&amp;ram_disk, volume_name,
                                      sizeof(volume_name), FX_BOOT_SECTOR);

/* If status is FX_SUCCESS, the volume name was successfully retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_58">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_volume_get_extended">fx_media_volume_get_extended</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the volume name of previously-opened media.</p>
</div>
<div class="sect2">
<h3 id="_prototype_59">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_volume_get_extended(
    FX_MEDIA *media_ptr,
    CHAR *volume_name,
    UINT volume_name_buffer_length,
    UINT volume_source);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_57">Description</h3>
<div class="paragraph">
<p>This service retrieves the volume name of the previously opened media.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
This service is identical to <strong><em>fx_media_volume_get</em></strong> except the caller passes in the size of the <em>volume_name</em> buffer.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_60">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to the media control block.</p>
</li>
<li>
<p><em>volume_name</em>: Pointer to the destination for volume name. The destination must be at least large enough to hold 12 characters.</p>
</li>
<li>
<p><em>volume_name_buffer_length</em>: Size of volume_name buffer.</p>
</li>
<li>
<p><em>volume_source</em>: Designates where to retrieve the name, either from the boot sector or the root directory. Valid values for this parameter are:</p>
<div class="ulist">
<ul>
<li>
<p><strong>FX_BOOT_SECTOR</strong></p>
</li>
<li>
<p><strong>FX_DIRECTORY_SECTOR</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_59">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media volume get.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Volume not found.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or volume destination pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_59">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_59">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        ram_disk;
UCHAR           volume_name[12];
UINT            status;

/* Retrieve the volume name of the RAM disk, from the boot sector. */

status = fx_media_volume_get_extended(&amp;ram_disk, volume_name,
                                      sizeof(volume_name),
                                      FX_BOOT_SECTOR);

/* If status is FX_SUCCESS, the volume name was successfully retrieved. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_59">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_volume_set">fx_media_volume_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sets the media&#8217;s volume name</p>
</div>
<div class="sect2">
<h3 id="_prototype_60">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_volume_set(
    FX_MEDIA *media_ptr,
    CHAR *volume_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_58">Description</h3>
<div class="paragraph">
<p>This service sets the volume name of the previously-opened media.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_61">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to the media control block.</p>
</li>
<li>
<p><em>volume_name</em>: Pointer to the volume name.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_60">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media volume set.</p>
</li>
<li>
<p><strong>FX_INVALID_NAME</strong> (0x0C) Volume_name is invalid.</p>
</li>
<li>
<p><strong>FX_MEDIA_INVALID</strong> (0x02) Unable to set volume name.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or volume name pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_60">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_60">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA    ram_disk;
UINT        status;

/* Set the volume name to "MY_VOLUME". */

status = fx_media_volume_set(&amp;ram_disk, "MY_VOLUME");

/* If status is FX_SUCCESS, the volume name was successfully set. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_60">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_media_write">fx_media_write</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Writes a logical sector to the media.</p>
</div>
<div class="sect2">
<h3 id="_prototype_61">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_media_write(
    FX_MEDIA *media_ptr,
    ULONG logical_sector,
    VOID *buffer_ptr);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_59">Description</h3>
<div class="paragraph">
<p>This service writes the supplied buffer to the specified logical sector.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_62">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to a previously-opened media.</p>
</li>
<li>
<p><em>logical_sector</em>: Logical sector to write.</p>
</li>
<li>
<p><em>buffer_ptr</em>: Pointer to the source for the logical sector write.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_61">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media write.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media pointer.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong>    (0x20)    Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_61">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_61">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
UCHAR           my_buffer[128];
UINT            status;

/* Write logical sector 22 from "my_buffer" assuming
    the physical media has a sector size of 128. */

status = fx_media_write(&amp;my_media, 22, my_buffer);

/* If status equals FX_SUCCESS, the contents of logical
    sector 22 are now the same as "my_buffer." */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_61">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_media_services">filex media Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_system_date_get">fx_system_date_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the file system date.</p>
</div>
<div class="sect2">
<h3 id="_prototype_62">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_system_date_get(
    UINT *year,
    UINT *month,
    UINT *day);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_60">Description</h3>
<div class="paragraph">
<p>This service returns the current system date.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_63">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>year</em>: Pointer to destination for year.</p>
</li>
<li>
<p><em>month</em>: Pointer to destination for month.</p>
</li>
<li>
<p><em>day</em>: Pointer to destination for day.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_62">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful date retrieval.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) One or more of the input parameters are NULL.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_62">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_62">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT            status;
UINT            year;
UINT            month;
UINT            day;
/* Retrieve the current system date. */

status = fx_system_date_get(&amp;year, &amp;month, &amp;day);

/* If status equals FX_SUCCESS, the year, month,
    and day parameters now have meaningful information. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_62">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_system_services">filex System Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_system_date_set">fx_system_date_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sets the system date.</p>
</div>
<div class="sect2">
<h3 id="_prototype_63">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_system_date_set(
    UINT year,
    UINT month,
    UINT day);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_61">Description</h3>
<div class="paragraph">
<p>This service sets the system date as specified.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>This service should be called shortly after invoking the <strong>*fx_system_initialize*</em> function to set the initial system date. By default, the system date is that of the last generic FileX release.</strong>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_64">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>year</em>: New year. The valid range is from 1980 through the year 2107.</p>
</li>
<li>
<p><em>month</em>: New month. The valid range is from 1 through 12.</p>
</li>
<li>
<p><em>day</em>: New day. The valid range is from 1 through 31, depending on month and leap year conditions.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_63">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful date setting.</p>
</li>
<li>
<p><strong>FX_INVALID_YEAR</strong> (0x12) Invalid year specified.</p>
</li>
<li>
<p><strong>FX_INVALID_MONTH</strong> (0x13) Invalid month specified.</p>
</li>
<li>
<p><strong>FX_INVALID_DAY</strong> (0x14) Invalid day specified.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_63">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_63">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c"> UINT             status;

/* Set the system date to December 12, 2005. */

status = fx_system_date_set(2005, 12, 12);

/* If status equals FX_SUCCESS, the file system date is now
    12-12-2005. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_63">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_system_services">filex System Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_system_initialize">fx_system_initialize</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Initializes the entire FileX system.</p>
</div>
<div class="sect2">
<h3 id="_prototype_64">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">VOID fx_system_initialize(void);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_62">Description</h3>
<div class="paragraph">
<p>This service initializes all the major FileX data structures. It should be called either in <strong><em>tx_application_define</em></strong> or possibly from an initialization thread and must be called prior to using any other FileX service.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>Once initialized by this call, the application should call <strong>*fx_system_date_set*</em> and *fx_system_time_set</strong> to start with an accurate system date and time.*
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_65">Input Parameters</h3>
<div class="paragraph">
<p>None</p>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_64">Return Values</h3>
<div class="paragraph">
<p>None</p>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_64">Allowed From</h3>
<div class="paragraph">
<p>Initialization, threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_64">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">void tx_application_define(VOID *free_memory)
{
    UINT status;

    /* Initialize the FileX system. */
    fx_system_initialize();

    /* Set the file system date. */
    fx_system_date_set(my_year, my_month, my_day);

    /* Set the file system time. */
    fx_system_time_set(my_hour, my_minute, my_second);

    /* Now perform all other initialization and possibly FileX media
        open calls if the corresponding driver does not block on the boot sector read. */

    ...

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_64">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_system_services">filex System Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_system_time_get">fx_system_time_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the current system time.</p>
</div>
<div class="sect2">
<h3 id="_prototype_65">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_system_time_get(
    UINT *hour,
    UINT *minute,
    UINT *second);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_63">Description</h3>
<div class="paragraph">
<p>This service retrieves the current system time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_66">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>hour</em>: Pointer to destination for hour.</p>
</li>
<li>
<p><em>minute</em>: Pointer to destination for minute.</p>
</li>
<li>
<p><em>second</em>: Pointer to destination for second.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_65">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful system time retrieval.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) One or more of the input parameters</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_65">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_65">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT             status;
UINT             hour;
UINT             minute;
UINT             second;

/* Retrieve the current system time. */

status = fx_system_time_get(&amp;hour, &amp;minute, &amp;second);

/* If status equals FX_SUCCESS, the current system time
    is in the hour, minute, and second variables. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_65">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_system_services">filex System Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_system_time_set">fx_system_time_set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sets the current system time.</p>
</div>
<div class="sect2">
<h3 id="_prototype_66">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_system_time_set(
    UINT hour,
    UINT minute,
    UINT second);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_64">Description</h3>
<div class="paragraph">
<p>This service sets the current system time to that specified by the input parameters.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>This service should be called shortly after invoking the <strong>*fx_system_initialize*</em> function to set the initial system time. By default, the system time is 0:0:0.</strong>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_67">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>hour</em>: New hour (0-23).</p>
</li>
<li>
<p><em>minute</em>: New minute (0-59).</p>
</li>
<li>
<p><em>second</em>: New second (0-59).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_66">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful system time retrieval.</p>
</li>
<li>
<p><strong>FX_INVALID_HOUR</strong>    (0x15) New hour is invalid.</p>
</li>
<li>
<p><strong>FX_INVALID_MINUTE</strong> (0x16) New minute is invalid.</p>
</li>
<li>
<p><strong>FX_INVALID_SECOND</strong> (0x17) New second is invalid.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_66">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_66">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c"> UINT status;

/* Set the current system time to hour 23, minute 21, and second 20. */

status = fx_system_time_set(23, 21, 20);

/* If status is FX_SUCCESS, the current system time has been set. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_66">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_system_services">filex System Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_unicode_directory_create">fx_unicode_directory_create</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Creates a Unicode-named directory.</p>
</div>
<div class="sect2">
<h3 id="_prototype_67">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_unicode_directory_create(
    FX_MEDIA *media_ptr,
    UCHAR *source_unicode_name,
    ULONG source_unicode_length,
    CHAR *short_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_65">Description</h3>
<div class="paragraph">
<p>This service creates a Unicode-named subdirectory in the current default directory&#8212;&#8203;no path information is allowed in the Unicode source name parameter. If successful, the short name (8.3 format) of the newly created Unicode subdirectory is returned by the service.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>All operations on the Unicode subdirectory (making it the default path, deleting, etc.) should be done by supplying the returned short name (8.3 format) to the standard FileX directory services.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_68">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>source_unicode_name</em>: Pointer to the Unicode name for the new subdirectory.</p>
</li>
<li>
<p><em>source_unicode_length</em>: Length of Unicode name.</p>
</li>
<li>
<p><em>short_name</em>: Pointer to destination for short name (8.3 format) for the new Unicode subdirectory.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_67">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful Unicode directory create.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_ALREADY_CREATED</strong> (0x0B) Specified directory already exists.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more clusters available in the media for the new directory entry.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or name pointers.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong>    (0x90) Driver I/O error.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_67">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_67">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA            ram_disk;
UCHAR               my_short_name[13];
UCHAR               my_unicode_name[] = {0x38,0xC1, 0x88,0xBC, 0xF8,0xC9, 0x20,0x00,
                                         0x54,0xD6, 0x7C,0xC7, 0x20,0x00, 0x74,0xC7,
                                         0x84,0xB9, 0x20,0x00, 0x85,0xC7, 0xC8,0xB2,
                                         0xE4,0xB2, 0x2E,0x00, 0x64,0x00, 0x6F,0x00,
                                         0x63,0x00, 0x00,0x00};

/* Create a Unicode subdirectory with the name contained in "my_unicode_name". */

length = fx_unicode_directory_create(&amp;ram_disk, my_unicode_name, 17, my_short_name);

/* If successful, the Unicode subdirectory is created and "my_short_name"
    contains the 8.3 format name that can be used with other FileX services. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_67">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_unicode_services">filex Unicode Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_unicode_directory_rename">fx_unicode_directory_rename</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Renames directory using a Unicode string.</p>
</div>
<div class="sect2">
<h3 id="_prototype_68">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_unicode_directory_rename(
    FX_MEDIA *media_ptr,
    UCHAR *old_unicode_name,
    ULONG old_unicode_length,
    UCHAR *new_unicode_name,
    ULONG new_unicode_length,
    CHAR *new_short_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_66">Description</h3>
<div class="paragraph">
<p>This service changes a Unicode-named subdirectory to specified new Unicode name in current working directory. The Unicode name parameters must not have path information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_69">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>old_unicode_name</em>: Pointer to the Unicode name for the current file.</p>
</li>
<li>
<p><em>old_unicode_name_length</em>: Length of current Unicode name.</p>
</li>
<li>
<p><em>new_unicode_name</em>: Pointer to the new Unicode file name.</p>
</li>
<li>
<p><em>old_unicode_name_length</em>: Length of new Unicode name.</p>
</li>
<li>
<p><em>new_short_name</em>: Pointer to destination for short name (8.3 format) for the renamed Unicode file. Rename Directory with Unicode</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_68">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media open.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_ALREADY_CREATED</strong> (0x0B) Specified directory name already exists.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) One or more pointers are NULL.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20)    Caller is not a thread.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write-protected.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_68">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_68">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA            my_media;
UINT                status;
UCHAR               my_short_name[13];
UCHAR               my_old_unicode_name[] = {'a', '\0', 'b', '\0', 'c', '\0', '\0', '\0'};
UCHAR               my_new_unicode_name[] = {'d', '\0', 'e', '\0', 'f', '\0', '\0', '\0'};

/* Change the Unicode-named file "abc" to "def". */

status = fx_unicode_directory_rename(&amp;my_media, my_old_unicode_name,
    3, my_new_unicode_name, 3, my_short_name);

/* If status equals FX_SUCCESS, the directory was changed to "def" and
    "my_short_name" contains the 8.3 format name that can be used with other FileX services. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_68">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_unicode_services">filex Unicode Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_unicode_file_create">fx_unicode_file_create</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Creates a Unicode-named file.</p>
</div>
<div class="sect2">
<h3 id="_prototype_69">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_unicode_file_create(
    FX_MEDIA *media_ptr,
    UCHAR *source_unicode_name,
    ULONG source_unicode_length,
    CHAR *short_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_67">Description</h3>
<div class="paragraph">
<p>This service creates a Unicode-named file in the current default directory&#8212;&#8203;no path information is allowed in the Unicode source name parameter. If successful, the short name (8.3 format) of the newly created Unicode file is returned by the service.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<em>All operations on the Unicode file (opening, writing, reading, closing, etc.) should be done by supplying the returned short name (8.3 format) to the standard FileX file services.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_70">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>source_unicode_name</em>: Pointer to the Unicode name for the new file.</p>
</li>
<li>
<p><em>source_unicode_length</em>: Length of Unicode name.</p>
</li>
<li>
<p><em>short_name</em>: Pointer to destination for short name (8.3 format) for the new Unicode file.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_69">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful file create.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_ALREADY_CREATED</strong> (0x0B) Specified file already exists.</p>
</li>
<li>
<p><strong>FX_NO_MORE_SPACE</strong> (0x0A) No more clusters available in the media for the new file entry.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write protected.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or name pointers.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_69">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_69">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        ram_disk;
UCHAR           my_short_name[13];
UCHAR           my_unicode_name[] = {0x38,0xC1, 0x88,0xBC, 0xF8,0xC9, 0x20,0x00,
                                     0x54,0xD6, 0x7C,0xC7, 0x20,0x00, 0x74,0xC7,
                                     0x84,0xB9, 0x20,0x00, 0x85,0xC7, 0xC8,0xB2,
                                     0xE4,0xB2, 0x2E,0x00, 0x64,0x00, 0x6F,0x00,
                                     0x63,0x00, 0x00,0x00};

/* Create a Unicode file with the name contained in "my_unicode_name". */

length = fx_unicode_file_create(&amp;ram_disk, my_unicode_name, 17, my_short_name);

/* If successful, the Unicode file is created and "my_short_name"
    contains the 8.3 format name that can be used with other FileX services. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_69">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_unicode_services">filex Unicode Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_unicode_file_rename">fx_unicode_file_rename</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Renames a file using a unicode string.</p>
</div>
<div class="sect2">
<h3 id="_prototype_70">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_unicode_file_rename(
    FX_MEDIA *media_ptr,
    UCHAR *old_unicode_name,
    ULONG old_unicode_length,
    UCHAR *new_unicode_name,
    ULONG new_unicode_length,
    CHAR *new_short_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_68">Description</h3>
<div class="paragraph">
<p>This service changes a Unicode-named file name to specified new Unicode name in current default directory. The Unicode name parameters must not have path information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_71">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>old_unicode_name</em>: Pointer to the Unicode name for the current file.</p>
</li>
<li>
<p><strong>old_unicode_name_length</strong>*: Length of current Unicode name.</p>
</li>
<li>
<p><em>new_unicode_name</em>: Pointer to the new Unicode file name.</p>
</li>
<li>
<p><em>new_unicode_name_length</em>: Length of new Unicode name.</p>
</li>
<li>
<p><em>new_short_name</em>: Pointer to destination for short name (8.3 format) for the renamed Unicode file.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_70">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful media open.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_ALREADY_CREATED</strong> (0x0B) Specified file name already exists.</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) One or more pointers are NULL.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
<li>
<p><strong>FX_WRITE_PROTECT</strong> (0x23) Specified media is write-protected.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_70">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_70">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        my_media;
UINT            status;
UCHAR           my_short_name[13];
UCHAR           my_old_unicode_name[] = {'a', '\0', 'b', '\0', 'c', '\0', '\0', '\0'};
UCHAR           my_new_unicode_name[] = {'d', '\0', 'e', '\0', 'f', '\0', '\0', '\0'};

/* Change the Unicode-named file "abc" to "def". */

status = fx_unicode_file_rename(&amp;my_media, my_old_unicode_name,
    3, my_new_unicode_name, 3, my_short_name);

/* If status equals FX_SUCCESS, the file name was changed to "def" and
    "my_short_name" contains the 8.3 format name that can be used with other FileX services. */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_70">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_unicode_services">filex Unicode Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_unicode_length_get">fx_unicode_length_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the length of a Unicode name.</p>
</div>
<div class="sect2">
<h3 id="_prototype_71">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">ULONG fx_unicode_length_get(UCHAR *unicode_name);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_69">Description</h3>
<div class="paragraph">
<p>This service determines the length of the supplied Unicode name. A Unicode character is represented by two bytes. A Unicode name is a series of two byte Unicode characters terminated by two <strong>NULL</strong> bytes (two bytes of 0 value).</p>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_72">Input Parameters</h3>
<div class="paragraph">
<p><em>unicode_name</em>: Pointer to the Unicode name.</p>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_71">Return Values</h3>
<div class="paragraph">
<p><strong>length</strong>: Length of Unicode name (number of Unicode characters in the name).</p>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_71">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_71">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UCHAR     my_unicode_name[] = {0x38,0xC1, 0x88,0xBC, 0xF8,0xC9, 0x20,0x00,
                           0x54,0xD6, 0x7C,0xC7, 0x20,0x00, 0x74,0xC7,
                           0x84,0xB9, 0x20,0x00, 0x85,0xC7, 0xC8,0xB2,
                           0xE4,0xB2, 0x2E,0x00, 0x64,0x00, 0x6F,0x00,
                           0x63,0x00, 0x00,0x00};

UINT     length;

/* Get the length of "my_unicode_name". */

length = fx_unicode_length_get(my_unicode_name);

/* A value of 17 will be returned for the length of the "my_unicode_name". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_71">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_unicode_services">filex Unicode Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_unicode_length_get_extended">fx_unicode_length_get_extended</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets length of a Unicode name from a buffer of a specified length.</p>
</div>
<div class="sect2">
<h3 id="_prototype_72">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_unicode_length_get_extended(
    UCHAR *unicode_name,
    UINT buffer_length);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_70">Description</h3>
<div class="paragraph">
<p>This service gets the length of the supplied Unicode name. A Unicode character is represented by two bytes. A Unicode name is a series of two-byte Unicode characters terminated by two <strong>NULL</strong> bytes (two bytes of 0 value).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This service is identical to <strong>*fx_unicode_length_get*</em> except the caller passes in the size of the <em>unicode_name</em> buffer, including the two *NULL</strong> characters.*
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_73">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>unicode_name</em>: Pointer to the Unicode name.</p>
</li>
<li>
<p><em>buffer_length</em>: Size of the Unicode name buffer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_72">Return Values</h3>
<div class="paragraph">
<p><strong>length</strong>: Length of Unicode name (number of Unicode characters in the name).</p>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_72">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_72">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UCHAR         my_unicode_name[] = {0x38,0xC1, 0x88,0xBC, 0xF8,0xC9, 0x20,0x00,
                                 0x54,0xD6, 0x7C,0xC7, 0x20,0x00, 0x74,0xC7,
                                 0x84,0xB9, 0x20,0x00, 0x85,0xC7, 0xC8,0xB2,
                                 0xE4,0xB2, 0x2E,0x00, 0x64,0x00, 0x6F,0x00,
                                 0x63,0x00, 0x00,0x00};

UINT         length;

/* Get the length of "my_unicode_name". */

length = fx_unicode_length_get_extended(my_unicode_name, sizeof(my_unicode_name));

/* A value of 17 will be returned for the length of the "my_unicode_name". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_72">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_unicode_services">filex Unicode Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_unicode_name_get">fx_unicode_name_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the Unicode name from a short name.</p>
</div>
<div class="sect2">
<h3 id="_prototype_73">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_unicode_name_get(
    FX_MEDIA *media_ptr,
    CHAR *source_short_name,
    UCHAR *destination_unicode_name,
    ULONG *destination_unicode_length);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_71">Description</h3>
<div class="paragraph">
<p>This service retrieves the Unicode name associated with the supplied short name (8.3 format) within the current default directory&#8212;&#8203;no path information is allowed in the short name parameter. If successful, the Unicode name associated with the short name is returned by the service.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This service can be used to get Unicode names for both files and subdirectories.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_74">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>short_name</em> Pointer to short name (8.3 format).</p>
</li>
<li>
<p><em>destination_unicode_name</em>: Pointer to the destination for the Unicode name associated with the supplied short name.</p>
</li>
<li>
<p><em>destination_unicode_length</em>: Pointer to returned Unicode name length.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_73">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful Unicode name retrieval.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT table.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Short name was not found or the Unicode destination size is too small.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or name pointers.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_73">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_73">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        ram_disk;
UCHAR           my_unicode_name[256*2];
ULONG           unicode_name_length;

/* Get the Unicode name associated with the short name "ABC0~111.TXT".
    Note that the Unicode destination must have 2 times the
    number of maximum characters in the name. */

length = fx_unicode_name_get(&amp;ram_disk, "ABC0~111.TXT", my_unicode_name, unicode_name_length);

/* If successful, the Unicode name is returned in "my_unicode_name". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_73">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_unicode_services">filex Unicode Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_unicode_name_get_extended">fx_unicode_name_get_extended</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the Unicode name from a short name in a buffer of a specified length.</p>
</div>
<div class="sect2">
<h3 id="_prototype_74">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_unicode_name_get_extended(
    FX_MEDIA *media_ptr,
    CHAR *source_short_name,
    UCHAR *destination_unicode_name,
    ULONG *destination_unicode_length,
    ULONG unicode_name_buffer_length);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_72">Description</h3>
<div class="paragraph">
<p>This service retrieves the Unicode-name associated with the supplied short name (8.3 format) within the current default directory&#8212;&#8203;no path information is allowed in the short name parameter. If successful, the Unicode name associated with the short name is returned by the service.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This service is identical to <strong>*fx_unicode_name_get*</em>, except the caller supplies the size of the destination Unicode buffer as an input argument. This allows the service to guarantee that it will not overwrite the destination Unicode buffer</strong>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This service can be used to get Unicode names for both files and subdirectories.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_75">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>short_name</em>: Pointer to short name (8.3 format).</p>
</li>
<li>
<p><em>destination_unicode_name</em>: Pointer to the destination for the Unicode name associated with the supplied short name.</p>
</li>
<li>
<p><em>destination_unicode_length</em>: Pointer to returned Unicode name length.</p>
</li>
<li>
<p><em>unicode_name_buffer_length</em>: Size of the Unicode name buffer. Note: A NULL terminator is required, which makes an extra byte.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_74">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful Unicode name retrieval.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT table.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Short name was not found or the Unicode destination size is too small.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or name pointers.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20) Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_74">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_74">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA         ram_disk;
UCHAR             my_unicode_name[256*2];
ULONG             unicode_name_length;

/* Get the Unicode name associated with the short name "ABC0~111.TXT".
    Note that the Unicode destination must have 2 times the number of maximum characters in the name. */

length = fx_unicode_name_get_extended(&amp;ram_disk, "ABC0~111.TXT",
    my_unicode_name,&amp;unicode_name_length, sizeof(ny_unicode_name));

/* If successful, the Unicode name is returned in "my_unicode_name". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_74">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_unicode_services">filex Unicode Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_unicode_short_name_get">fx_unicode_short_name_get</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the short name from a Unicode name.</p>
</div>
<div class="sect2">
<h3 id="_prototype_75">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_unicode_short_name_get(
    FX_MEDIA *media_ptr,
    UCHAR *source_unicode_name,
    ULONG source_unicode_length,
    CHAR *destination_short_name);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This service retrieves the short name (8.3 format) associated with the Unicode-name within the current default directory&#8212;&#8203;no path information is allowed in the Unicode name parameter. If successful, the short name associated with the Unicode name is returned by the service.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This service can be used to get short names for both files and subdirectories.</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_76">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>source_unicode_name</em>: Pointer to Unicode name.</p>
</li>
<li>
<p><em>source_unicode_length</em>: Length of Unicode name.</p>
</li>
<li>
<p><em>destination_short_name</em>: Pointer to destination for the short name (8.3 format). This must be at least 13 bytes in size.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_75">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful short name retrieval.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT table.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08) File is corrupted</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04)    Unicode name was not found.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or name pointers.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20)    Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_75">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_75">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">FX_MEDIA        ram_disk;
UCHAR           my_short_name[13];
UCHAR           my_unicode_name[] = {0x38,0xC1, 0x88,0xBC, 0xF8,0xC9, 0x20,0x00,
                                     0x54,0xD6, 0x7C,0xC7, 0x20,0x00, 0x74,0xC7,
                                     0x84,0xB9, 0x20,0x00, 0x85,0xC7, 0xC8,0xB2,
                                     0xE4,0xB2, 0x2E,0x00, 0x64,0x00, 0x6F,0x00,
                                     0x63,0x00, 0x00,0x00};

/* Get the short name associated with the Unicode name contained in the array "my_unicode_name". */

length = fx_unicode_short_name_get(&amp;ram_disk, my_unicode_name, 17, my_short_name);

/* If successful, the short name is returned in "my_short_name". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_75">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_unicode_services">filex Unicode Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fx_unicode_short_name_get_extended">fx_unicode_short_name_get_extended</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gets the short name from Unicode name in a buffer of a specified length.</p>
</div>
<div class="sect2">
<h3 id="_prototype_76">Prototype</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">UINT fx_unicode_short_name_get_extended(
    FX_MEDIA *media_ptr,
    UCHAR *source_unicode_name,
    ULONG source_unicode_length,
    CHAR *destination_short_name,
    ULONG short_name_buffer_length);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_description_73">Description</h3>
<div class="paragraph">
<p>This service retrieves the short name (8.3 format) associated with the Unicode-name within the current default directory&#8212;&#8203;no path information is allowed in the Unicode name parameter. If successful, the short name associated with the Unicode name is returned by the service.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<em>This service is identical to <strong>*fx_unicode_short_name_get*</em>, except the caller supplies the size of the destination buffer as an input argument. This allows the service to guarantee the short name does not exceed the destination buffer.</strong>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<em>This service can be used to get short names for both files and subdirectories</em>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_input_parameters_77">Input Parameters</h3>
<div class="ulist">
<ul>
<li>
<p><em>media_ptr</em>: Pointer to media control block.</p>
</li>
<li>
<p><em>source_unicode_name</em>: Pointer to Unicode name.</p>
</li>
<li>
<p><em>source_unicode_length</em>: Length of Unicode name.</p>
</li>
<li>
<p><em>destination_short_name</em>: Pointer to destination for the short name (8.3 format). This must be at least 13 bytes in size.</p>
</li>
<li>
<p><em>short_name_buffer_length</em>: Size of the destination buffer. The buffer size must be at least 14 bytes.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_return_values_76">Return Values</h3>
<div class="ulist">
<ul>
<li>
<p><strong>FX_SUCCESS</strong> (0x00) Successful short name retrieval.</p>
</li>
<li>
<p><strong>FX_FAT_READ_ERROR</strong> (0x03) Unable to read FAT table.</p>
</li>
<li>
<p><strong>FX_FILE_CORRUPT</strong> (0x08)    File is corrupted</p>
</li>
<li>
<p><strong>FX_IO_ERROR</strong> (0x90) Driver I/O error.</p>
</li>
<li>
<p><strong>FX_MEDIA_NOT_OPEN</strong> (0x11) Specified media is not open.</p>
</li>
<li>
<p><strong>FX_NOT_FOUND</strong> (0x04) Unicode name was not found.</p>
</li>
<li>
<p><strong>FX_SECTOR_INVALID</strong> (0x89) Invalid sector.</p>
</li>
<li>
<p><strong>FX_PTR_ERROR</strong> (0x18) Invalid media or name pointers.</p>
</li>
<li>
<p><strong>FX_CALLER_ERROR</strong> (0x20)    Caller is not a thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allowed_from_76">Allowed From</h3>
<div class="paragraph">
<p>Threads</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_76">Example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define         SHORT_NAME_BUFFER_SIZE 13
FX_MEDIA        ram_disk;
UCHAR           my_short_name[SHORT_NAME_BUFFER_SIZE];
UCHAR           my_unicode_name[] = {0x38,0xC1, 0x88,0xBC, 0xF8,0xC9, 0x20,0x00,
                                     0x54,0xD6, 0x7C,0xC7, 0x20,0x00, 0x74,0xC7,
                                     0x84,0xB9, 0x20,0x00, 0x85,0xC7, 0xC8,0xB2,
                                     0xE4,0xB2, 0x2E,0x00, 0x64,0x00, 0x6F,0x00,
                                     0x63,0x00, 0x00,0x00};

/* Get the short name associated with the Unicode name contained in the array "my_unicode_name". */

length = fx_unicode_short_name_get_extended(&amp;ram_disk,
    my_unicode_name, 17, my_short_name, SHORT_NAME_BUFFER_SIZE);

/* If successful, the short name is returned in "my_short_name". */</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see_also_76">See Also</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#_unicode_services">filex Unicode Services</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-02-07 07:51:22 UTC
</div>
</div>
</body>
</html>